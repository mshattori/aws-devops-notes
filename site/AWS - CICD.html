<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AWS - CICD - AWS DevOps Notes</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    
    <header>
        <h1>AWS - CICD</h1>
    </header>
    
    <main>
        
<article>
    <h1 id="devops-cicd-basics">DevOps &amp; CI/CD basics</h1>
<p>DevOps = Dev + SysOps</p>
<p>手法</p>
<ul>
<li>マイクロサービスアーキテクチャ</li>
<li>Infrastructure as Code</li>
<li>CI/CD パイプライン</li>
</ul>
<h2 id="_1">マイクロサービスアーキテクチャ</h2>
<ul>
<li>two-pizza teams<ul>
<li>2つのピザを食べ切れるくらいの規模(6~8 名)にチームとサービスを分解。</li>
<li>俊敏性を高めるため。</li>
</ul>
</li>
<li>APIによる疎結合のサービス連携</li>
</ul>
<h2 id="cicd">CI/CD</h2>
<p>Continuous Integration</p>
<ul>
<li>コミットと同時に自動でビルド・テストが走る。元来はテスト自動化が動機っぽい。</li>
<li>Build して artifact が保存されるまで。</li>
<li>UT 含むが(たぶん)デプロイして実行するインテグレーションテストは含まない。</li>
</ul>
<p>Continuous Delivery vs. Continuous Deployment</p>
<ul>
<li>Continuous Delivery: 人が確認・承認した上でデプロイ</li>
<li>Continuous Deployment は人手のプロセスがなく自動デプロイされる。</li>
</ul>
<p><img alt="" src="_attachment/image_533.png" /></p>
<ul>
<li>BB: AWS Code Services: <a href="https://d1.awsstatic.com/webinars/jp/pdf/services/20170322_AWS-BlackBelt-CodeCommit-CodeBuild.pdf">https://d1.awsstatic.com/webinars/jp/pdf/services/20170322_AWS-BlackBelt-CodeCommit-CodeBuild.pdf</a></li>
<li>BB: AWS Code Services Part 2: <a href="https://d1.awsstatic.com/webinars/jp/pdf/services/20170628_AWS-BlackBelt_CodeSeries_CodeDeploy_and_CodePipeline.pdf">https://d1.awsstatic.com/webinars/jp/pdf/services/20170628_AWS-BlackBelt_CodeSeries_CodeDeploy_and_CodePipeline.pdf</a></li>
</ul>
<hr />
<h1 id="aws-codecommit">AWS CodeCommit</h1>
<p>特徴</p>
<ul>
<li>フルマネージドの Git サービス。</li>
<li>サイズが制限なく、コードは AWS アカウントにプライベート。</li>
<li>送信時 (SSH/HTTPS) および保存時 (KMS) の暗号化。</li>
<li>IAM ロール, CloudWatch, CloudTrail により他の AWS サービスとの連携が容易</li>
<li>サードパーティーと連携可能</li>
<li>Ref. <a href="https://pages.awscloud.com/rs/112-TZM-766/images/20201020_BlackBelt_AWS_CodeCommit_AWS_CodeArtifact.pdf">https://pages.awscloud.com/rs/112-TZM-766/images/20201020_BlackBelt_AWS_CodeCommit_AWS_CodeArtifact.pdf</a></li>
</ul>
<p><img alt="" src="_attachment/image_534.png" /></p>
<p>使い方</p>
<ul>
<li>AWS CLI かコンソールで CodeCommit 上にリモートレポジトリを作る。</li>
<li>あとの git clone, push, pull などの作業は普通の Git と同じ。</li>
</ul>
<h3 id="_2">認証方法</h3>
<ul>
<li>IAM コンソールで認証情報を登録する。</li>
<li><img alt="" src="_attachment/image_535.png" /></li>
<li>SSH: キーペアを作り IAM ユーザに公開鍵を登録。</li>
<li>HTTPS: IAM ユーザの Git 認証情報 (ユーザ名/パスワード) を生成する。</li>
</ul>
<h3 id="_3">認証情報ヘルパー</h3>
<ul>
<li>認証情報ヘルパーを使えば aws-cli 経由でプロファイルに指定したユーザの権限で認証してくれるので、認証情報の登録が不要。</li>
</ul>
<pre><code>git config --global credential.helper '!aws --profile dev codecommit credential-helper $@'
git config --global credential.UseHttpPath true
</code></pre>
<ul>
<li>~/.gitconfig に次のように記載される。</li>
</ul>
<pre><code>[credential]   
    helper = !aws --profile dev codecommit credential-helper $@
    UseHttpPath = true
</code></pre>
<ul>
<li>なお、SSH URL でのクローンは認証情報が求められ出来なかった。</li>
<li>Ref. <a href="https://docs.aws.amazon.com/ja_jp/codecommit/latest/userguide/setting-up-https-unixes.html">https://docs.aws.amazon.com/ja_jp/codecommit/latest/userguide/setting-up-https-unixes.html</a></li>
<li>NOTE: Mac, Windows とも 403 エラーになる。<ul>
<li><a href="https://docs.aws.amazon.com/ja_jp/codecommit/latest/userguide/troubleshooting-ch.html">https://docs.aws.amazon.com/ja_jp/codecommit/latest/userguide/troubleshooting-ch.html</a></li>
<li>Mac の場合、Git が Keychain Access で認証情報を保存するが 15 分で期限切れになるため。一番簡単な対応方法は ~/.gitconfig で次のように空の helper を指定する。</li>
</ul>
</li>
</ul>
<pre><code>[credential]
  helper =
  helper = !aws --profile CodeCommitProfile codecommit credential-helper $@
  UseHttpPath = true
</code></pre>
<p><img alt="" src="_attachment/image_536.png" /></p>
<ul>
<li>AWSCodeCommitFullAccess, AWSCodeCommitPowerUser,  AWSCodeCommitReadOnly などの AWS マネージドポリシーがあるが、これらのポリシーではアカウントの全リポジ トリへのアクセスが許可されてしまう。</li>
<li>ベストプラクティスは、個々のリポジトリ固有のカスタマーマネージドポリシーを作成すること。</li>
<li><strong>リソースポリシーはサポートされていない</strong>。プリンシパルにマネージドポリシーをアタッチし、Resource セクションに リポジトリのARN を指定する。</li>
</ul>
<p>master ブランチへの push や merge を拒否するポリシーの例:</p>
<p><a href="https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-conditional-branch.html">https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-conditional-branch.html</a></p>
<pre><code>{
    &quot;Version&quot;: &quot;2012-10-17&quot;,
    &quot;Statement&quot;: [
        {
            &quot;Effect&quot;: &quot;Deny&quot;,
            &quot;Action&quot;: [
                &quot;codecommit:GitPush&quot;,
                &quot;codecommit:DeleteBranch&quot;,
                &quot;codecommit:PutFile&quot;,
                &quot;codecommit:MergeBranchesByFastForward&quot;,
                &quot;codecommit:MergeBranchesBySquash&quot;,
                &quot;codecommit:MergeBranchesByThreeWay&quot;,
                &quot;codecommit:MergePullRequestByFastForward&quot;,
                &quot;codecommit:MergePullRequestBySquash&quot;,
                &quot;codecommit:MergePullRequestByThreeWay&quot;
            ],
            &quot;Resource&quot;: &quot;arn:aws:codecommit:*:*:*&quot;,
            &quot;Condition&quot;: {
                &quot;StringEqualsIfExists&quot;: {
                    &quot;codecommit:References&quot;: [
                        &quot;refs/heads/main&quot;
                    ]
                },
                &quot;Null&quot;: {
                    &quot;codecommit:References&quot;: &quot;false&quot;
                }
            }
        }
    ]
}
</code></pre>
<p>CodeCommit の暗号化</p>
<ul>
<li>デフォルトで AWS 管理キー (AWS managed CMKs) で暗号化される。</li>
</ul>
<p>外部レポジトリからのマイグレーション</p>
<ul>
<li>CodeCommit にリポジトリを作成し、外部リポジトリを一旦ローカルに clone してから CodeCommit リポジトリを remote に設定して push する。</li>
</ul>
<p>プルリクエスト</p>
<ul>
<li>AWS コンソールまたは AWS CLI から作成できる。</li>
<li>送信元ブランチのコンテンツを、マージ先ブランチ (送信先ブランチ) と比較する。</li>
<li><img alt="" src="_attachment/image_538.png" /></li>
<li>プルリクのマージの承認ルールというのが追加されている。</li>
</ul>
<p>クライアント側フック
- リポジトリの .git/hooks サブディレクトリにインストールされる。</p>
<p>サーバ側フック
- CodeCommit ではサーバ側のフックは CodeCommit イベントで処理される。</p>
<p>CodeCommit リポジトリトリガー</p>
<ul>
<li>コード Push などのリポジトリイベントで SNS, Lambda をトリガー。</li>
<li><img alt="" src="_attachment/image_539.png" /></li>
<li>関連リソースは CodeCommit と同じリージョンにある必要がある</li>
<li><a href="https://docs.aws.amazon.com/ja_jp/codecommit/latest/userguide/how-to-notify.html">https://docs.aws.amazon.com/ja_jp/codecommit/latest/userguide/how-to-notify.html</a></li>
<li>Lambda 側からトリガーを追加してもここに反映される:</li>
<li><img alt="" src="_attachment/image_540.png" /></li>
<li><img alt="" src="_attachment/image_541.png" /></li>
<li><a href="https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-notify-lambda.html">https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-notify-lambda.html</a></li>
</ul>
<p>通知ルール
- SNS か AWS Chatbot に通知を投げる。
- <img alt="" src="_attachment/image_542.png" />
- <a href="https://docs.aws.amazon.com/ja_jp/codecommit/latest/userguide/how-to-repository-email.html">https://docs.aws.amazon.com/ja_jp/codecommit/latest/userguide/how-to-repository-email.html</a>
- 通知ルールは Code シリーズ共通のリソース。通知ルールを使うと Code シリーズから CodeStar サービスにイベントを送る EventBridge ルールが自動で追加される。
- <img alt="" src="_attachment/image_543.png" /></p>
<p>CodeBuild/CodePipeline 連携</p>
<ul>
<li>EventBridge ルールを作成してイベントソースを CodeCommit にする。</li>
<li>コード変更時にビルドをかけるには "CodeCommit Repository State Change" イベント。</li>
<li>ターゲットを CodeBuild プロジェクトや CodePipeline パイプラインの ARN とする。</li>
<li><a href="https://docs.aws.amazon.com/ja_jp/codepipeline/latest/userguide/pipelines-trigger-source-repo-changes-cli.html">https://docs.aws.amazon.com/ja_jp/codepipeline/latest/userguide/pipelines-trigger-source-repo-changes-cli.html</a></li>
</ul>
<pre><code>{
  &quot;source&quot;: [&quot;aws.codecommit&quot;],
  &quot;detail-type&quot;: [&quot;CodeCommit Repository State Change&quot;]
}
</code></pre>
<p>CloudTrail 連携</p>
<ul>
<li>CodeCommit API コールをキャプチャして S3 バケットに保存可能</li>
</ul>
<h1 id="_4">ブランチ戦略</h1>
<p><img alt="" src="_attachment/image_544.png" /></p>
<ul>
<li>メインブランチ、開発ブランチ、Feature ブランチ、リリースブランチ、修正ブランチ等、複数のブランチを使い分けるモデル。</li>
<li>コミットがあちこちのブランチに散らばるので管理が大変になりがち。</li>
<li><a href="https://aws.amazon.com/jp/blogs/devops/implementing-gitflow-using-aws-codepipeline-aws-codecommit-aws-codebuild-and-aws-codedeploy/">https://aws.amazon.com/jp/blogs/devops/implementing-gitflow-using-aws-codepipeline-aws-codecommit-aws-codebuild-and-aws-codedeploy/</a></li>
</ul>
<h3 id="_5">トランクベース開発</h3>
<p><img alt="" src="_attachment/image_545.png" /></p>
<ul>
<li>トランクと呼ばれる 1 つの共有ブランチにコミットの大半をマージする。</li>
<li>リリース時はリリースブランチを切り、次のリリースまでの短期間使用される。</li>
<li>ほとんどのコミットはトランクに行われ、リリースブランチにマージされる。</li>
<li>Amazon では開発者がコミットをトランクに定期的に (理想的には 1 日数回) マージする「トランクベース開発」により継続的インテグレーションを実践するよう強く推奨。</li>
<li>チームが小さな変更を定期的にマージできる場合、マージの複雑さと労力を最小限に抑えることができる。</li>
<li>トランクベースの継続的インテグレーション・デリバリーを組み合わせることで、本番環境に変更を加えるまでのリードタイ ムを短縮できる。</li>
</ul>
<hr />
<h1 id="aws-codebuild">AWS CodeBuild</h1>
<h2 id="_6">概要</h2>
<ul>
<li>CI サーバ (Build/Test) のマネージドサービス。</li>
<li>ソースコード取得<ul>
<li>CodeCommit, S3, GitHub</li>
</ul>
</li>
<li>ビルド環境<ul>
<li>Docker イメージで用意される。</li>
</ul>
</li>
<li>ビルドコマンド<ul>
<li>buildspec.yml に記述。</li>
<li>ビルドコマンド出力はログに送信される。</li>
</ul>
</li>
<li>アーティファクト<ul>
<li>S3 バケットにアップロード。</li>
</ul>
</li>
</ul>
<p><img alt="" src="_attachment/image_546.png" /><img alt="" src="_attachment/File_9.png" /></p>
<h2 id="_7">ビルドプロジェクト</h2>
<p>ソース、ビルド環境、buildspec ファイル名、アーティファクト (出力先 S3 バケット名) 等を指定する。</p>
<p>Ref. <a href="https://docs.aws.amazon.com/ja_jp/codebuild/latest/userguide/create-project-console.html">https://docs.aws.amazon.com/ja_jp/codebuild/latest/userguide/create-project-console.html</a></p>
<h3 id="_8">ソース</h3>
<ul>
<li>ソースプロバイダーの種類<ul>
<li>S3, CodeCommit, GitHub, GitHub Enterprise, Bitbucket</li>
<li><img alt="" src="_attachment/image_547.png" /><img alt="" src="_attachment/image_548.png" /></li>
<li><br></li>
</ul>
</li>
</ul>
<h3 id="_9"><br></h3>
<h3 id="_10">ビルド環境</h3>
<ul>
<li>ビルドサーバの Docker イメージを指定する。</li>
<li>マネージド型イメージ<ul>
<li>CodeBuild の Docker イメージレポジトリで管理されたイメージ。</li>
</ul>
</li>
<li>カスタムイメージ<ul>
<li>Docker Hub, ECR にあるイメージを指定。</li>
</ul>
</li>
<li>マネージド型イメージで提供される OS<ul>
<li>Amazon Linux 2, Ubuntu, Windows Server のイメージが提供されている。<ul>
<li>Windows Server は us-east 等、特定リージョンのみ。</li>
</ul>
</li>
</ul>
</li>
<li><img alt="" src="_attachment/image_549.png" /></li>
<li>Ref.<ul>
<li><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref.html#build-env-ref-available">https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref.html#build-env-ref-available</a></li>
<li><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html">https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html</a></li>
<li><a href="https://blog.shibayan.jp/entry/20180527/1527423170">https://blog.shibayan.jp/entry/20180527/1527423170</a></li>
</ul>
</li>
<li>サービスロール<ul>
<li>コンテナにサービスロールがアタッチされる。</li>
</ul>
</li>
<li>タイムアウト<ul>
<li>最長8時間までのタイムアウトを指定できる。</li>
<li>Lambda で出来ない時間のかかるパフォーマンステスト等を実施できる。</li>
</ul>
</li>
<li>VPC<ul>
<li>ビルド環境に VPC を指定して VPC 内で実行して内部のリソースへのアクセスも可能。</li>
</ul>
</li>
<li>環境変数<ul>
<li>環境変数の上書き指定。SSM パラメータストアからの取得も指定可能。</li>
<li><img alt="" src="_attachment/image_550.png" /></li>
</ul>
</li>
</ul>
<h3 id="_11">アーティファクト</h3>
<ul>
<li>保存先の S3 バケットを指定する。(オプショナル)</li>
<li>暗号化<ul>
<li>デフォルトで S3-KMS で用いられる AWS managed CMK を使って暗号化する。<ul>
<li>バケットのデフォルト暗号化を他の設定 SSE-S3 にしていても CodeBuiild 側で KMS 暗号化を行う。</li>
</ul>
</li>
<li>Customer managed CMK もここで指定できる。</li>
</ul>
</li>
</ul>
<h3 id="_12">ログ</h3>
<ul>
<li>オプショナルで CloudWatch Log と S3 バケットにログを保存できる。</li>
<li>CodeBuild コンソールに出力されるログは環境が終了すると消える。</li>
</ul>
<h3 id="_13">ビルドキャッシュ</h3>
<ul>
<li>アーティファクトセクションのキャッシュタイプで有効化。</li>
<li><img alt="" src="_attachment/image_551.png" /></li>
<li>ビルドツールや依存モジュールのダウンロードやビルド時間を短縮できる。</li>
<li>対象ファイルは buildspec.yaml の cache セクションで指定。<ul>
<li><img alt="" src="_attachment/image_552.png" /></li>
</ul>
</li>
<li>S3<ul>
<li>It stores the cache in an Amazon S3 bucket that is available across multiple build hosts.</li>
<li>This is a good option for small to intermediate sized build artifacts that are more expensive to build than to download.</li>
<li>This is not the best option for large build artifacts because they can take a long time to transfer over your network, which can affect build performance. It also is not the best option if you use Docker layers.</li>
</ul>
</li>
<li>Local<ul>
<li>Local caching stores a cache locally on a build host that is available to that build host only.</li>
<li>This is a good option for intermediate to large build artifacts because the cache is immediately available on the build host.<ul>
<li>DockerLayerCache ... コンテナイメージのビルドのためのキャッシュ</li>
<li>SourceCache ... .git メタデータのキャッシュ</li>
<li>CustomCache ... buildspec.yaml で指定するキャッシュ</li>
</ul>
</li>
<li><img alt="" src="_attachment/image_553.png" /></li>
</ul>
</li>
<li><img alt="" src="_attachment/image_554.png" /></li>
<li>S3 から手動で削除してキャッシュを失効させる。または S3 ライフサイクルポリシーを使用して キャッシュを失効させることも可能。</li>
<li>プロジェクトを更新してキャッシュ動作をオーバーライドする。 プロジェクトを更新するには、AWS コンソール、CLI、 SDK を使用します。新しい InvalidateProjectCache API を使用し てキャッシュ設定を無効化することも可能です。この API により新しい InvalidationKey が強制的に生成され、今後のビルドでは空のキャッシュ が渡されることが保証されます。実行中のビルドとの不整合が発生する可 能性があるため、この API では既存のキャッシュの削除が行われません。</li>
<li>ビルド環境のすべてのフォルダに対してキャッシュを有効にできるが、 ビルド間で頻繁に変更されない依存関係やファイルのみをキャッシュするようにすべき。予期しないアプリケーションの動作を避けるために、設定と機密情報をキャッシュしないようにする。</li>
<li><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-caching.html">https://docs.aws.amazon.com/codebuild/latest/userguide/build-caching.html</a></li>
<li><a href="https://aws.amazon.com/jp/blogs/devops/how-to-enable-caching-for-aws-codebuild/">https://aws.amazon.com/jp/blogs/devops/how-to-enable-caching-for-aws-codebuild/</a></li>
</ul>
<h2 id="buildspec-buildspecyml">BuildSpec (buildspec.yml)</h2>
<ul>
<li>ソースの root ディレクトリに配置。(ビルドプロジェクトで異なるパスも指定可能)</li>
<li>各ビルドフェーズのコマンド、アーティファクトとして保存するファイルを指定。</li>
</ul>
<p><img alt="" src="_attachment/image_555.png" /><img alt="" src="_attachment/image_556.png" /></p>
<ul>
<li>install フェーズ<ul>
<li>runtime-versions でビルドランタイムのインストール指定。</li>
<li><img alt="" src="_attachment/File_10.png" /></li>
<li>dotnet, java, golang, php, nodejs, python, ruby をサポート。</li>
<li>command ブロックで install フェーズでもコマンド実行可能。</li>
</ul>
</li>
<li>post_build フェーズ<ul>
<li>UT やコンテナのプッシュ等を実施。</li>
</ul>
</li>
<li>run-as: Linux-user-name<ul>
<li>全体および各フェーズに指定可能。</li>
</ul>
</li>
<li>finally ブロック<ul>
<li>各セクションに指定。command ブロックでエラーがあったときも必ず実行される。</li>
</ul>
</li>
</ul>
<p>artifact セクション</p>
<ul>
<li>artifact として S3 に保存するファイルを指定。</li>
<li>**/* のようなワイルドカードも使える。</li>
</ul>
<p>env セクション</p>
<ul>
<li>環境変数設定。パラメータストアからも簡単に取得できる。</li>
</ul>
<pre><code>env:
  variables:
    JAVA_HOME: &quot;/usr/lib/jvm/java-8-openjdk-amd64&quot;
  parameter-store:
    LOGIN_PASSWORD: /CodeBuild/dockerLoginPassword
</code></pre>
<ul>
<li>pre-define の環境変数も大量にある。<ul>
<li><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-env-vars.html">https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-env-vars.html</a></li>
</ul>
</li>
</ul>
<p>Docker イメージをビルドする buidspec.yaml 例:</p>
<ul>
<li>docker login でレポジトリにログイン。</li>
<li>buidspec.yaml と同じディレクトリの (暗黙に選択される) Dockerfile  で docker build を実行。</li>
<li>post_build で ECR に push する。artifacts セクション不要。</li>
<li>サービスロールに ECR アクセスの権限が必要。</li>
</ul>
<pre><code>version: 0.2

phases:
  pre_build:
    commands:
      - echo Logging in to Amazon ECR...
      - aws --version
      - REPOSITORY_URI=041845206805.dkr.ecr.us-west-2.amazonaws.com/gold-repo
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $REPOSITORY_URI
      - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - IMAGE_TAG=${COMMIT_HASH:=latest}
  build:
    commands:
      - echo Build started on `date`
      - echo Building the Docker image...
      - docker build -t $REPOSITORY_URI:latest .
      - docker tag $REPOSITORY_URI:latest $REPOSITORY_URI:$IMAGE_TAG
  post_build:
    commands:
      - echo Build completed on `date`
      - echo Pushing the Docker images...
      - docker push $REPOSITORY_URI:latest
      - docker push $REPOSITORY_URI:$IMAGE_TAG
</code></pre>
<p>Ref.</p>
<ul>
<li><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-syntax">https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-syntax</a></li>
<li><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/use-case-based-samples.html">https://docs.aws.amazon.com/codebuild/latest/userguide/use-case-based-samples.html</a></li>
</ul>
<h2 id="_14">ビルドの保護</h2>
<p>AWS 管理ポリシー</p>
<ul>
<li>AWSCodeBuildAdminAccess – CodeBuild へのフルアクセスを提供。</li>
<li>AWSCodeBuildDeveloperAccess – CodeBuild へのアクセスを提供するがビルドプロジェクトの管理は許可しない。</li>
<li>AWSCodeBuildReadOnlyAccess – CodeBuild への読み取り専用アクセス。</li>
<li>AmazonS3ReadOnlyAccess – CodeBuild が作成するビルド出力 アーティファクトへのアクセス。</li>
</ul>
<p>IAM ロールでビルドアクションの制御する例</p>
<p><img alt="" src="_attachment/image_557.png" /></p>
<h2 id="codepipeline">CodePipeline 連携</h2>
<p><img alt="" src="_attachment/File_11.png" /></p>
<h2 id="eventbridge">EventBridge による連携</h2>
<p>CodeBuild プロジェクトをターゲットにしたビルド開始</p>
<p>CodeBuild をイベントソースにした Lambda 等との連携:</p>
<ul>
<li>CodeBuild Stage Change: IN_PROGRESS, SUCCEEDED, FAILED, STOPPED</li>
<li>CodeBuild Phase Change: BuildSpec に出てくる各フェーズの遷移</li>
</ul>
<p>Validating AWS CodeCommit Pull Requests with AWS CodeBuild and AWS Lambda</p>
<ul>
<li>CloudWatch Event (=EventBridge) で PR を契機に CodeBuild でコードの自動テストを行い、結果を PR にコメント付与する例。</li>
<li><img alt="" src="_attachment/image_558.png" /></li>
<li>CodeCommit をイベントソースとして CodeBuild を開始、CodeBuild をイベントソースとして Lambda で結果を通知。</li>
<li>Lambda はテスト開始時とテスト結果を PR にコメント追加するのに使用されている。</li>
<li><a href="https://aws.amazon.com/jp/blogs/devops/validating-aws-codecommit-pull-requests-with-aws-codebuild-and-aws-lambda/">https://aws.amazon.com/jp/blogs/devops/validating-aws-codecommit-pull-requests-with-aws-codebuild-and-aws-lambda/</a></li>
</ul>
<h2 id="_15"><br></h2>
<hr />
<h1 id="aws-codedeploy">AWS CodeDeploy</h1>
<p><img alt="" src="_attachment/File_12.png" /></p>
<ul>
<li>リビジョン(=アーティファクト)取得元<ul>
<li>S3, GitHub のいずれか。</li>
<li>S3 の場合はデプロイ先 EC2 インスタンスのロールに S3 へのアクセス許可も必要。</li>
<li>(アーティファクトを各インスタンスのエージェントが pull するため)</li>
</ul>
</li>
<li>デプロイ先<ul>
<li>EC2/オンプレサーバ (要 CodeDeploy エージェント)</li>
<li>ECS (Fargate)</li>
<li>Lambda</li>
</ul>
</li>
</ul>
<p><img alt="" src="_attachment/image_559.png" /></p>
<h2 id="_16">リビジョン</h2>
<p>デプロイ対象アプリケーションの(AppSpecを含む)パッケージ(の特定バージョン)をリビジョンと呼ぶ。</p>
<p><img alt="" src="_attachment/image_560.png" /></p>
<h2 id="codedeploy">CodeDeploy によるデプロイの流れ</h2>
<ol>
<li>あらかじめアプリケーションとデプロイグループを作成しておく。</li>
<li>S3 (Git) にリビジョンを push する。(aws deploy push)</li>
<li>デプロイを作成することでデプロイプロセスが開始する。(aws deploy create-deployment)<ul>
<li>この際、アプリケーション名・デプロイグループ・リビジョンの場所を指定する。</li>
<li>デプロイタイプ (Blue/Green 等) に応じてデプロイメントがスケジュールされ、各インスタンス内のエージェントがリビジョンを pull して AppSpec に従って展開する。</li>
</ul>
</li>
</ol>
<p><img alt="" src="_attachment/image_561.png" /></p>
<h3 id="_17">ラボで実行したコマンド例</h3>
<p>S3 バケットを作成後、ローカルにあるアプリケーションをリビジョンとして S3 バケットに push:</p>
<pre><code>aws deploy push --application-name CodeDeploy-Demo --source HeartBeat-App --s3-location s3://$bucketName/HeartBeat-App.zip
</code></pre>
<ul>
<li>ローカルディレクトリのファイルが zip されて S3 にアップロードされる。</li>
<li>裏で RegisterApplicationRevision コマンドで S3 のオブジェクトとリビジョンの紐付けを行なっている。</li>
<li>S3 バケットのバージョニングを有効にしておけば push するごとにバージョンが上がってリビジョンと紐づけられる。</li>
</ul>
<p>リビジョンをデプロイ:</p>
<pre><code>aws deploy create-deployment --application-name CodeDeploy-Demo --deployment-group-name HeartBeat-Deployment --deployment-config-name CodeDeployDefault.AllAtOnce --description &quot;Initial Deployment&quot; --s3-location bucket=$bucketName,key=HeartBeat-App.zip,bundleType=zip
</code></pre>
<p>アプリケーション更新の流れも同じ</p>
<p>新しいリビジョンを同じ S3 バケットにプッシュ:</p>
<pre><code>aws deploy push --application-name CodeDeploy-Demo --source HeartBeat-App --s3-location s3://$bucketName/HeartBeat-App.zip
</code></pre>
<p>同じコマンドでデプロイ:</p>
<pre><code>aws deploy create-deployment --application-name CodeDeploy-Demo --deployment-group-name HeartBeat-Deployment --deployment-config-name CodeDeployDefault.AllAtOnce --description &quot;Updated Deployment&quot; --s3-location bucket=$bucketName,key=HeartBeat-App.zip,bundleType=zip
</code></pre>
<h2 id="_18">アプリケーション</h2>
<p>デプロイ先プラットフォームを指定して作成する</p>
<p><img alt="" src="_attachment/image_562.png" /></p>
<h2 id="_19">デプロイグループ</h2>
<p>EC2/オンプレではターゲットに以下が選択できる。1つのデプロイグループ内に複数の組み合わせを指定可能。</p>
<p><img alt="" src="_attachment/image_563.png" /></p>
<p>EC2/オンプレのインスタンスはタググループで指定できる。</p>
<p><img alt="" src="_attachment/image_564.png" /></p>
<p>EC2 Auto Scaling グループ</p>
<ul>
<li>Auto Scaling グループ内の既存インスタンスにデプロイを実施する。</li>
<li>スケールアウトで新しいインスタンスが立ち上がる際も自動的に新しいリビジョンのデプロイが行われる。</li>
</ul>
<p><img alt="" src="_attachment/File_13.png" /></p>
<ul>
<li>インプレースとBlue/Green 両方で Auto Scaling グループを選択可能。</li>
<li>Blue/Green では Auto Scaling グループ全体の置き換えによるデプロイメントを指定できる。(Ref. AutoScalingReplacingUpdate)</li>
<li><img alt="" src="_attachment/image_565.png" /></li>
<li>インスタンスの手動プロビジョンは  deployment 作成時に個別にインスタンスを指定することになる。</li>
</ul>
<p>ECS の場合は ECS クラスター名と ELB を指定。</p>
<p><img alt="" src="_attachment/image_566.png" /></p>
<h2 id="_20">デプロイタイプ</h2>
<p>デプロイグループで指定する。</p>
<ul>
<li>EC2: インプレースデプロイ, Blue/Green デプロイ</li>
<li>オンプレ: インプレースデプロイのみ</li>
<li>ECS, Lambda:  Blue/Green デプロイのみ</li>
</ul>
<p><img alt="" src="_attachment/image_567.png" /></p>
<p>Blue/Green ではルーティングの設定を行う:</p>
<ul>
<li>EC2 インスタンス/Auto Scaling グループの Blue/Green では ELB の指定が必須</li>
</ul>
<p><img alt="" src="_attachment/image_568.png" /></p>
<p>インプレース, Blue/Green ともにデプロイの単位を以下から選択する:</p>
<p><img alt="" src="_attachment/image_569.png" /></p>
<p>Lambda:</p>
<p><img alt="" src="_attachment/image_570.png" /></p>
<ul>
<li>Canary は2段階。Liner は10%ずつ段階的に。</li>
</ul>
<p>ECS:</p>
<p><img alt="" src="_attachment/image_571.png" /></p>
<h3 id="_21">トリガー (通知)</h3>
<ul>
<li>デプロイグループ設定でイベントを SNS 通知するトリガーを設定できる。</li>
<li>デプロイグループごとに最大 10 個。</li>
<li><img alt="" src="_attachment/image_572.png" /></li>
<li>CLI での表示例:</li>
<li><img alt="" src="_attachment/image_573.png" /></li>
</ul>
<p><a href="https://docs.aws.amazon.com/ja_jp/codedeploy/latest/userguide/monitoring-sns-event-notifications-edit-trigger.html">https://docs.aws.amazon.com/ja_jp/codedeploy/latest/userguide/monitoring-sns-event-notifications-edit-trigger.html</a></p>
<h2 id="appspec-file-appspecyml">AppSpec File (appspec.yml)</h2>
<p>デプロイ処理の定義</p>
<ul>
<li>リビジョンの root ディレクトリに配置する。</li>
<li>CodeDeploy エージェントによって実行される。</li>
</ul>
<p><img alt="" src="_attachment/image_574.png" /></p>
<p>例:</p>
<pre><code>version: 0.0
os: windows
files:
  - source: Heartbeat.dll
    destination: c:\HeartbeatService
  - source: HeartbeatService.exe
    destination: c:\HeartbeatService
  - source: HeartbeatService.exe.config
    destination: c:\HeartbeatService
  - source: log4net.dll
    destination: c:\HeartbeatService
  - source: Logger.dll
    destination: c:\HeartbeatService
  - source: wintail.exe
    destination: c:\temp

hooks:
  ApplicationStop:
    - location: uninstall.ps1
      timeout: 30
  AfterInstall:
    - location: install.ps1
      timeout: 30
    - location: copywintail.ps1
      timeout: 30
</code></pre>
<p>Hooks セクション</p>
<ul>
<li>デプロイ前後に独自スクリプトや Lambda などを実行可能<ul>
<li>ValidateService で外部 Lambda からアクセスして動作検証など</li>
</ul>
</li>
<li>timeout: タイムアウト指定</li>
<li>runas: 実行ユーザ指定</li>
<li>Hooks で実行するスクリプトもリビジョンにバンドルする。</li>
<li>EC2 - インプレース:</li>
<li><img alt="" src="_attachment/File_14.png" /></li>
<li>Ref. <a href="https://docs.aws.amazon.com/ja_jp/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html">https://docs.aws.amazon.com/ja_jp/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html</a></li>
<li>EC2 - Blue/Green:<ul>
<li>イミュータブルなので Blue 側は BlockTraffic 関連のイベントしか走らない。</li>
<li>Green の AfterAllowTraffic 後に Blue の BlockTraffic に移行。</li>
<li><img alt="" src="_attachment/image_575.png" /></li>
</ul>
</li>
</ul>
<p>プラットフォーム毎に記述内容は異なる。</p>
<h3 id="lambda-appspec">Lambda の AppSpec</h3>
<p>Resource セクション</p>
<ul>
<li>ターゲットの Lambda 関数名・エイリアス・現在と移行先のバージョンを指定。</li>
</ul>
<p>Hooks セクション</p>
<ul>
<li>EC2/オンプレインスタンスのように内部でコマンドを実行できる訳ではないので、Hook で呼び出す Lambda 関数名を指定する。</li>
<li><img alt="" src="_attachment/image_576.png" /></li>
</ul>
<p><img alt="" src="_attachment/image_577.png" /></p>
<h3 id="ecs-appspec">ECS の AppSpec</h3>
<p>ECS ではコンテナイメージが別途コンテナディレクトリに登録される必要があるので、AppSpec はコードと一緒に置かず S3 にファイル単体を置いても良い。</p>
<p><img alt="" src="_attachment/image_578.png" /><img alt="" src="_attachment/image_579.png" /><img alt="" src="_attachment/image_580.png" /></p>
<ul>
<li>BeforeInstall<ul>
<li>ECS アプリケーションが置き換えタスクセットにイ ンストールされる前に実行。</li>
</ul>
</li>
<li>AfterInstall<ul>
<li>ECS アプリケーションが置き換えタスクセットにイ ンストールされた後、トラフィック受信前に実行。</li>
</ul>
</li>
<li>AfterAllowTestTraffic<ul>
<li>更新後 ECS アプリケーションがテストリスナーからトラフィックを受信すると実行。</li>
<li>デプロイを続行するかどうか判断するための検証テスト等を実行する。</li>
<li>デプロイグループで ELB のテストリスナー(オプショナル)を指定しない場合は呼ばれない。</li>
</ul>
</li>
<li>BeforeAllowTraffic<ul>
<li>本番トラフィッ クが更新後 ECS アプリケーションに配信される前に実行。</li>
</ul>
</li>
<li>AfterAllowTraffic<ul>
<li>本番トラフィックが更新後 ECS ア プリケーションに配信されると実行。</li>
</ul>
</li>
</ul>
<p>AfterAllowTestTraffic と Test Listener</p>
<ul>
<li>CodeDeploy の ECS のデプロイメントでは新しい Task Set と ELB のターゲットグループが作られる。</li>
<li>AfterAllowTestTraffic のタイミングで Test Listener のルーティング先が新しいターゲットグループになる。</li>
<li>Test Listener は Production Listener と別ポート (8080) 等でルーティングが異なるリスナー。</li>
<li>AfterAllowTestTraffic フックの Lambda で Test Listener にリクエストを投げて Validation を実施する。</li>
<li><img alt="" src="_attachment/image_581.png" /></li>
<li><a href="https://docs.amazonaws.cn/en_us/codedeploy/latest/userguide/tutorial-ecs-deployment-with-hooks.html">https://docs.amazonaws.cn/en_us/codedeploy/latest/userguide/tutorial-ecs-deployment-with-hooks.html</a></li>
</ul>
<h3 id="appspec">AppSpec 内で利用できる環境変数</h3>
<ul>
<li>APPLICATION_NAME<ul>
<li>e.g. WordPress_App</li>
</ul>
</li>
<li>DEPLOYMENT_ID<ul>
<li>e.g. d-AB1CDEF23</li>
</ul>
</li>
<li>DEPLOYMENT_GROUP_NAME<ul>
<li>e.g.  WordPress_DepGroup</li>
</ul>
</li>
<li>DEPLOYMENT_GROUP_ID<ul>
<li>e.g.  b1a2189b-dd90-4ef5-8f40-4c1c5EXAMPLE</li>
</ul>
</li>
<li>LIFECYCLE_EVENT<ul>
<li>e.g. AfterInstall</li>
</ul>
</li>
</ul>
<p>Bundle from S3:</p>
<ul>
<li>BUNDLE_BUCKET<ul>
<li>e.g. my-s3-bucket</li>
</ul>
</li>
<li>BUNDLE_KEY<ul>
<li>e.g. WordPress_App.zip</li>
</ul>
</li>
<li>BUNDLE_VERSION<ul>
<li>e.g.  3sL4kqtJlcpXroDTDmJ+rmSpXd3dIbrHY+MTRCxf3vjVBH40Nr8X8gdRQBpUMLUo</li>
<li>This variable is only set if the Amazon S3 bucket has object versioning enabled.</li>
</ul>
</li>
<li>BUNDLE_ETAG<ul>
<li>The object etag for the bundle.</li>
<li>e.g. b10a8db164e0754105b7a99be72e3fe5-4</li>
</ul>
</li>
</ul>
<p>Bundle from GitHub:</p>
<ul>
<li>BUNDLE_COMMIT<ul>
<li>e.g. d2a84f4b8b650937ec8f73cd8be2c74add5a911ba64df27458ed8229da804a26).</li>
</ul>
</li>
</ul>
<p>NOTE: カスタム環境変数を渡す方法はない</p>
<h2 id="_22">ロールバック</h2>
<p>マニュアルロールバック:</p>
<ul>
<li>以前のリビジョンで新しい deployment を作成してデプロイするだけ。</li>
</ul>
<p>自動ロールバック:</p>
<ul>
<li>デプロイグループの詳細設定で設定可能。</li>
<li>いずれかのインスタンスでデプロイ失敗かアラーム (CPU 使用率 80% 以上等) が発生した場合に以前のリビジョンにデプロイしなおす。</li>
<li>アラームを使用する場合、アラームもデプロイグループに指定しておく。</li>
<li><img alt="" src="_attachment/image_582.png" /></li>
<li><a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/deployments-rollback-and-redeploy.html#deployments-rollback-and-redeploy-automatic-rollbacks">https://docs.aws.amazon.com/codedeploy/latest/userguide/deployments-rollback-and-redeploy.html#deployments-rollback-and-redeploy-automatic-rollbacks</a></li>
</ul>
<h2 id="_23">ポリシー関連</h2>
<p><img alt="" src="_attachment/image_583.png" /></p>
<p>サービスロール</p>
<ul>
<li>サービスロールはデプロイグループに指定し、デプロイターゲットへのアクセスを許可する。</li>
<li>ロールの作成時はスライドの通り信頼ポリシーで CodeDeploy に AssumeRole を許可。</li>
<li>次の AWS 管理ポリシーをロールにアタッチする。</li>
<li>AWSCodeDeployRole:<ul>
<li>インスタンスのタグを読み取る、または EC2 Auto Scaling グループ名により EC2 インスタンスを識別。</li>
<li>EC2 Auto Scaling グループ、ライフサイクルフック、スケーリングポリシーの読み取り・作成・更新・削除。</li>
<li>SNS トピックに情報を公開。</li>
<li>CloudWatch アラームに関する情報を取得。</li>
<li>ELB の読み取り・更新。</li>
</ul>
</li>
<li>AWSCodeDeployRoleForECS<ul>
<li>ECS タスクセットの読み取り・更新・削除。</li>
<li>ELB ターゲットグループ、リスナー、ルールを更新。</li>
<li>Lambda 関数を呼び出し。</li>
<li>S3 バケットのリビジョンファイルにアクセス。</li>
<li>CloudWatch アラームに関する情報を取得。</li>
<li>SNS トピックに情報を公開。</li>
</ul>
</li>
<li>AWSCodeDeployRoleForLambda<ul>
<li>Lambda 関数およびエイリアスの読み取り・更新・呼び出し。</li>
<li>S3 バケットのリビジョンファイルにアクセス。</li>
<li>CloudWatch アラームに関する情報を取得。</li>
<li>Amazon SNS トピックに情報を公開。</li>
</ul>
</li>
</ul>
<p>インスタンスロール</p>
<ul>
<li>S3 バケットからリビジョンを取得するため s3:Get*,   s3:List* の許可が必要。</li>
</ul>
<h2 id="cloudwatch-event">CloudWatch Event 連携</h2>
<p>ユースケース例</p>
<ul>
<li>Use a Lambda function to pass a notification to a Slack channel whenever deployments fail.</li>
<li>Push data about deployments or instances to a Kinesis stream to support comprehensive, real-time status monitoring via a dashboard.</li>
<li>Automatically stop, terminate, reboot, or recover Amazon EC2 instances when a deployment or instance event you specify occurs.</li>
<li><img alt="" src="_attachment/image_584.png" /></li>
<li><a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/monitoring-cloudwatch-events.html">https://docs.aws.amazon.com/codedeploy/latest/userguide/monitoring-cloudwatch-events.html</a></li>
</ul>
<h2 id="codedeploy_1">CodeDeploy エージェント</h2>
<ul>
<li>EC2, オンプレサーバにインストールする。</li>
<li>Amazon Linux, Ubuntu, RHEL, Windows Server 向けのバイナリがある。</li>
<li>OSS なので他の環境にも展開可能。</li>
</ul>
<p>Windows の EC2 インスタンスに指定する UserData の例:</p>
<pre><code>&lt;powershell&gt;
Read-S3Object -BucketName aws-codedeploy-us-west-2/latest -Key codedeploy-agent.msi -File c:\temp\codedeploy-agent.msi
Start-Sleep -s 60
Start-Process c:\temp\codedeploy-agent.msi '/qn /l**v c:\temp\host-agent-install-log.txt'
&lt;/powershell&gt;
</code></pre>
<ul>
<li>S3 から pull するためインスタンスロールに s3:Get*,   s3:List* パーミッションが必要。</li>
<li>CodeDeploy エンドポイントに HTTPS/443 でアクセスする。<ul>
<li>パブリックサブネットならインターネット経由、プライベートなら VPC エンドポイント経由。</li>
</ul>
</li>
<li>インスタンス上のインストールログを CloudWatch Logs で見るには CloudWatch を別途インストールする。</li>
</ul>
<h3 id="_24">オンプレインスタンスの登録</h3>
<p>各インスタンス毎に IAM ユーザを作成する方法 (小規模システム)と、 IAM ロールを STS で使う方法 (大規模システム) がある。</p>
<p>CloudDeploy エージェントの設定ファイルに認証情報を設定し、register-on-premises-instance コマンドで CodeDeploy サービスに IAM ユーザまたは STS セッションの ARN を登録する。</p>
<ul>
<li>Ref. <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/on-premises-instances-register.html">https://docs.aws.amazon.com/codedeploy/latest/userguide/on-premises-instances-register.html</a></li>
</ul>
<p>IAM ユーザを使用する例:</p>
<ul>
<li>ユーザを作成して "s3:Get*",   "s3:List*" を許可する。</li>
<li>ユーザのアクセスキーを取得して CodeDeploy エージェントの設定ファイルに設定する。(エージェントがインストール済なら設定後リスタート)</li>
</ul>
<pre><code>---
aws_access_key_id: secret-key-id
aws_secret_access_key: secret-access-key
iam_user_arn: iam-user-arn
region: supported-region
</code></pre>
<pre><code>- /etc/codedeploy-agent/conf/codedeploy.onpremises.yml
- C:\\ProgramData\\Amazon\\CodeDeploy\\conf.onpremises.yml
</code></pre>
<ul>
<li>CodeDeploy エージェントをインストール。</li>
<li>CLI がインストールされた環境で register-on-premises-instance を実行してユーザを登録する。</li>
</ul>
<pre><code>aws deploy register-on-premises-instance --instance-name AssetTag12010298EX --iam-user-arn arn:aws:iam::444455556666:user/CodeDeployUser-OnPrem
</code></pre>
<ul>
<li>登録後はコンソールからオンプレインスタンスが見られるようになる。</li>
<li><img alt="" src="_attachment/image_585.png" /></li>
<li>コンソールか CLI でインスタンスにタグを設定する。</li>
<li>以降のデプロイグループへの登録等は EC2 インスタンス同様。</li>
</ul>
<hr />
<h1 id="aws-codepipeline">AWS CodePipeline</h1>
<p>CI/CDパイプラインのオーケストレーション。</p>
<p><img alt="" src="_attachment/File_15.png" /></p>
<h2 id="_25">ステージ</h2>
<ul>
<li>パイプラインの各ステージに１つ以上のアクションを追加していく。</li>
<li>管理コンソールのウィザードでは次の3ステージが作成される。<ul>
<li>ソースステージ</li>
<li>ビルドステージ (オプショナル)</li>
<li>デプロイステージ (オプショナル)</li>
</ul>
</li>
<li>少なくとも２つ以上のステージが必要。(ビルド・デプロイ両方ともスキップはできない)</li>
<li>ステージは後から追加できる。</li>
</ul>
<h3 id="_26">ソースステージ</h3>
<p><img alt="" src="_attachment/image_586.png" /></p>
<ul>
<li>入力アーティファクトが更新されると自動でパイプラインが起動される。</li>
</ul>
<p><img alt="" src="_attachment/image_587.png" /></p>
<ul>
<li>CloudWatch Events (EventBridge) で自動的に Codepipeline 呼び出しが行われるようにルールが設定される。</li>
<li>AWS リソースの CodeCommit, ECR, S3 は CloudWatch Events/EventBridge で監視。</li>
<li>外部リソースの GitHub, Bitbucket  は CodeStarSourceConnection プロバイダーで Webhook で監視するとのこと。</li>
<li>検出オプション「AWS CodePipeline」はポーリングらしい。どういう時に使う？</li>
<li>複数のソースプロバイダを指定することもできる。パイプライン発火時は全てのプロバイダから最新のソースを取得する。</li>
<li>Ref. Source actions and change detection methods:</li>
<li><a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-about-starting.html#change-detection-methods">https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-about-starting.html#change-detection-methods</a></li>
</ul>
<h3 id="_27">ビルドステージ (オプショナル)</h3>
<ul>
<li>ビルドだけでなくテストにも使われる。</li>
</ul>
<p><img alt="" src="_attachment/image_588.png" /></p>
<h3 id="_28">デプロイステージ (オプショナル)</h3>
<p><img alt="" src="_attachment/image_589.png" /></p>
<ul>
<li>ECS, ECS(Blue/Green) は CodeDeploy 使わなくても直接 CodePipeline に統合されている。</li>
</ul>
<p>別リージョンのビルド/デプロイプロバイダーを呼び出すことも可能:</p>
<p><img alt="" src="_attachment/image_590.png" /></p>
<h2 id="_29">アクション</h2>
<p><img alt="" src="_attachment/File_16.png" /></p>
<ul>
<li>Approval アクション: 手動承認 → SNS<ul>
<li>SNS 連携でパイプラインのステージに承認アクションを追加できる。</li>
<li>必要な IAMアクセス権限を持つユーザによってアクションを承認または拒否するワークフローを設定。</li>
<li>Codepipeline コンソール上または SNS で通知される URL で Approve/Reject できる。(サブスクライバは任意に追加可能)</li>
<li><img alt="" src="_attachment/image_591.png" /></li>
</ul>
</li>
<li>Invoke アクション: Lambda で追加処理を実行できる。<ul>
<li>codepipeline.putJobSuccessResult()/putJobFailureResult() で結果を返す。<ul>
<li>continuationToken パラメーターが Job の識別 ID となる。</li>
</ul>
</li>
<li>Lambda 実行ロールでこれらのアクションを許可する必要がある:<ul>
<li>codepipeline:PutJobSuccessResult</li>
<li>codepipeline:PutJobFailureResult</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="_30">パラレルアクションとシーケンシャルアクション</h3>
<p><img alt="" src="_attachment/image_592.png" /><img alt="" src="_attachment/image_593.png" /></p>
<p>パラレルアクション=アクショングループ</p>
<ul>
<li><img alt="" src="_attachment/image_594.png" /></li>
</ul>
<h2 id="_31">パイプラインのコーディング</h2>
<p><img alt="" src="_attachment/image_595.png" /></p>
<ul>
<li>最初のステージにソースアクションを含める必要がある 。<ul>
<li>最初のステー ジのみにソースアクションを設定できる。</li>
</ul>
</li>
<li>ソースアクションのステージの他に 1 つ以上のステージが必要。(=2つ以上のステージが必要)</li>
<li>パイプライン内のステージ名は一意である必要がある。</li>
<li><strong>runOrder</strong><ul>
<li>シーケンスの順番。パラレルアクションは同じ runOrder になる。</li>
</ul>
</li>
</ul>
<h2 id="_32">アーティファクト</h2>
<p>各ステージのアーティファクトが S3 に置かれ、次のステージに渡される。S3 バージョンも使用して作成の度にバージョニングされる。</p>
<p><img alt="" src="_attachment/image_596.png" /><img alt="" src="_attachment/image_597.png" /></p>
<ul>
<li>各アクションで Input/Output artifacts の名前を指定する。</li>
</ul>
<h3 id="_33">アーティファクトの暗号化</h3>
<ul>
<li>CodePipeline はアーティファクトを保管するための S3 バケットを作成し、デフォルトで S3 の AWS 管理キー (aws/s3) を作成して SSE-KMS で暗号化する。</li>
<li>カスタマー管理キーでないとキーポリシーを変更できずクロスアカウントでの使用ができない。また、削除やローテーションの鍵管理ができないため、カスタマー管理キーの使用が推奨される。</li>
<li><a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/S3-artifact-encryption.html">https://docs.aws.amazon.com/codepipeline/latest/userguide/S3-artifact-encryption.html</a></li>
<li><img alt="" src="_attachment/image_598.png" /></li>
</ul>
<h2 id="_34">クロスリージョンアクション</h2>
<p>クロスリージョンでビルドプロバイダー/デプロイプロバイダー等を呼び出すことが可能。</p>
<ul>
<li>ソースアクション、サードパーティーアクション、カスタムアクションはクロスリージョン不可。</li>
</ul>
<p>各リージョンにアーティファクトストア (S3バケット) と SSE-KMS キーが必要となる。</p>
<p>リージョン間でのアーティファクトのコピーが行われる。</p>
<p>クロスリージョンのサービスをデプロイする例:</p>
<p><img alt="" src="_attachment/image_599.png" /></p>
<p><a href="https://aws.amazon.com/jp/blogs/devops/using-aws-codepipeline-to-perform-multi-region-deployments/">https://aws.amazon.com/jp/blogs/devops/using-aws-codepipeline-to-perform-multi-region-deployments/</a></p>
<p><a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-create-cross-region.html">https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-create-cross-region.html</a></p>
<h2 id="_35">クロスアカウント</h2>
<p>パイプラインのある開発アカウントとデプロイ先の本番アカウントでアカウントが分かれているのが普通なので、クロスアカウントアクセスを設定する必要がある。</p>
<p><img alt="" src="_attachment/image_600.png" /></p>
<ul>
<li><a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-create-cross-account.html">https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-create-cross-account.html</a></li>
</ul>
<p>アカウント A 側リソース:</p>
<ul>
<li>アーティファクトが置かれる S3 バケット</li>
<li>ソースとデプロイステージがあるパイプライン</li>
</ul>
<p>アカウント B 側リソース:</p>
<ul>
<li>CodeDeploy アプリケーション</li>
<li>EC2 インスタンスがあるデプロイグループ</li>
</ul>
<p>アカウント A 側のステップ :</p>
<ol>
<li>アカウント B の ARN またはアカウント ID を入手。</li>
<li>パイプラインのリージョンで KMS カスタマーマネージドキーを作成し、キーの使用権限を  CodePipeline サービスロールとアカウント B に付与。キーはパイプラインアーティファクトの暗号化に使用される。</li>
<li>アカウント B に S3 バケットへのアクセスを許可する S3 バケットポリシーを作成。</li>
<li>アカウント A がアカウント B によって設定されたロールを引き受けるこ とを許可するポリシーを作成し、そのポリシーを CodePipeline サービスロールにアタッチ。</li>
<li>デフォルトのキーではなく KMS カスタマーマネージドキーを使用 するパイプラインを編集。</li>
</ol>
<p>アカウント B 側ステップ:</p>
<ol>
<li>アカウント A の ARN またはアカウント ID を入手。</li>
<li>CodeDeploy に設定された EC2 インスタンスロールに適用される、S3 バケットへのアクセスを許可するポリシーを作成。</li>
<li>CodeDeploy に設定された EC2 インスタンスロールに適用される、KMS カスタマーマネージドキーへのアクセスを許可するポリシーを作成。</li>
<li>IAM ロールを設定し、そのロールにアカウ ント A がロールを引き受けることを許可する信頼関係ポリシーをアタッチします。</li>
<li>パイプラインで必要なデプロイリソースへのアクセスを許可するポリシー を作成し、それを上記の IAM ロールにアタッチ。</li>
<li>S3 バケットへのアクセスを許可するポリシーを作成し、それを上記の IAM ロールにアタッチ。</li>
</ol>
<p>パイプラインの編集:</p>
<ul>
<li>AWS CLI を使用して作業する<ul>
<li>おそらくクロスアカウントの Deploy プロバイダの設定が管理コンソールで出来ないため。</li>
</ul>
</li>
<li>パイプラインを JSON で取得する</li>
</ul>
<pre><code>aws codepipeline get-pipeline --name MyFirstPipeline &gt;pipeline.json
</code></pre>
<ul>
<li>KMS キーをパイプラインの artifactStore に指定する</li>
</ul>
<pre><code>{
  &quot;artifactStore&quot;: {
    &quot;location&quot;: &quot;codepipeline-us-east-1-1234567890&quot;,
    &quot;type&quot;: &quot;S3&quot;,
    &quot;encryptionKey&quot;: {
      &quot;id&quot;: &quot;arn:aws:kms:us-east-1:012ID_ACCOUNT_A:key/2222222-3333333-4444-556677EXAMPLE&quot;,
      &quot;type&quot;: &quot;KMS&quot;
    }
  }
}
</code></pre>
<ul>
<li>クロスアカウントロールの ARN を指定したデプロイアクションを含むステージを追加</li>
</ul>
<pre><code>            {
                &quot;name&quot;: &quot;Staging&quot;,
                &quot;actions&quot;: [
                    {
                        &quot;inputArtifacts&quot;: [
                            {
                                &quot;name&quot;: &quot;MyAppBuild&quot;
                            }
                        ],
                        &quot;name&quot;: &quot;ExternalDeploy&quot;,
                        &quot;actionTypeId&quot;: {
                            &quot;category&quot;: &quot;Deploy&quot;,
                            &quot;owner&quot;: &quot;AWS&quot;,
                            &quot;version&quot;: &quot;1&quot;,
                            &quot;provider&quot;: &quot;CodeDeploy&quot;
                        },
                        &quot;outputArtifacts&quot;: [],
                        &quot;configuration&quot;: {
                            &quot;ApplicationName&quot;: &quot;AccountBApplicationName&quot;,
                            &quot;DeploymentGroupName&quot;: &quot;AccountBApplicationGroupName&quot;
                        },
                        &quot;runOrder&quot;: 1,
                        &quot;roleArn&quot;: &quot;arn:aws:iam::012ID_ACCOUNT_B:role/CrossAccount_Role&quot;
                    }
                ]
            }
</code></pre>
<ul>
<li>編集された JSON ファイルを保存してパイプライン更新コマンドを実行</li>
</ul>
<p>Ref. クロスアカウントロール</p>
<ul>
<li><img alt="" src="_attachment/File.jpeg" /></li>
</ul>
<h2 id="_36">ラボで使用したパイプラインの例</h2>
<p><img alt="" src="_attachment/image_601.png" /></p>
<p>Source ステージ</p>
<ul>
<li>CodeCommit</li>
</ul>
<p>Static_Check ステージ</p>
<ul>
<li>Lambda アクション</li>
<li>CloudFormation テンプレートの Security Group をチェックする</li>
</ul>
<p>Build ステージ</p>
<ul>
<li>CodeBuild アクション</li>
<li>ラボでは post_build のユニットテストの Fail を CodeBuild のログで確認した。</li>
</ul>
<p>Test_Stack ステージ</p>
<ul>
<li>GenerateChangeSet: CloudFormation アクション</li>
<li>DeployChangeSet: CloudFormation アクション</li>
<li>Doploy: CodeDeploy アクション</li>
</ul>
<p>ServiceStatus ステージ</p>
<ul>
<li>Lambda アクション</li>
<li>動的確認として Test_Stack でデプロイされたアプリケーションへの疎通確認をする</li>
</ul>
<p>Approval ステージ</p>
<ul>
<li>Approval アクション</li>
<li>DeleteTestStack: CloudFormation アクション</li>
</ul>
<p>Prod_Stack ステージ</p>
<ul>
<li>Test_Stack ステージ 同様</li>
</ul>
<p><img alt="" src="_attachment/image_602.png" /></p>
<p>ユースケース例</p>
<p><a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/best-practices.html#use-cases">https://docs.aws.amazon.com/codepipeline/latest/userguide/best-practices.html#use-cases</a></p>
<h2 id="cloudwatch-eventseventbridge">CloudWatch Events/EventBridge 連携</h2>
<p>CodePipeline をイベントソースにターゲットの Lambda 等と連携。</p>
<p>単にパイプライン中に Lambda 呼びたければ Invoke アクションがあるので、Fail の際などに呼ぶ場合にこちらを使う。</p>
<p><img alt="" src="_attachment/image_603.png" /></p>
<ul>
<li>CodePipeline Pipeline Execution State Change</li>
<li>CodePipeline Stage Execution State Change</li>
<li>CodePipeline Action Execution State Change</li>
<li>それぞれ、SUCCEEDED, FAILED, STOPPING, STOPPED, RESUMED, CANCELED などの状態がある。</li>
<li>Approve action の reject は FAILED になる。</li>
<li>Ref. <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/detect-state-changes-cloudwatch-events.html#detect-state-events-types">https://docs.aws.amazon.com/codepipeline/latest/userguide/detect-state-changes-cloudwatch-events.html#detect-state-events-types</a></li>
</ul>
<hr />
<h1 id="aws-codestar">AWS CodeStar</h1>
<p>概要</p>
<ul>
<li>Code サービスによる CI/CD パイプラインをアプリのテンプレートから簡単に作成できる。</li>
<li>リポジトリ: CodeCommit / GitHub</li>
<li>デプロイターゲット: EC2 / Lambda / Beanstalk</li>
<li>パイプライン: CodePipeline</li>
<li>ビルドプロジェクト: CodeBuild </li>
<li>デプロイツール: CodeDeploy, CloudFormation, Beanstalk</li>
<li>CloudWatch メトリクス</li>
<li>プロジェクト管理ダッシュボード<ul>
<li>Atlassian JIRA による管理ダッシュボードが用意される。</li>
<li>チームのバックログからコードデプロイまで、開発プロセスの進行状況をトラッキングできる。</li>
</ul>
</li>
</ul>
<p>プロジェクトテンプレート</p>
<ul>
<li>デプロイターゲットごとに色々なテンプレートが用意されている。</li>
</ul>
<p><img alt="" src="_attachment/File_17.png" /></p>
<p>プロジェクトコードがリポジトリにコミットされる:</p>
<p><img alt="" src="_attachment/image_604.png" /></p>
<p>Cloud9 やその他の IDE でリポジトリからコードを clone して開発:</p>
<p><img alt="" src="_attachment/image_605.png" /></p>
<p>template.yml</p>
<ul>
<li>CodeStar プロジェクトテンプレートは CloudFormation テンプレートの CodeStar 拡張で定義されている。</li>
</ul>
<pre><code>AWSTemplateFormatVersion: 2010-09-09
Transform:
- AWS::Serverless-2016-10-31
- AWS::CodeStar

Parameters:
  ProjectId:
    Type: String
    Description: CodeStar projectId used to associate new resources to team members
  CodeDeployRole:
    Type: String
    Description: IAM role to allow AWS CodeDeploy to manage deployment of AWS Lambda functions
  Stage:
    Type: String
    Description: The name for a project pipeline stage, such as Staging or Prod, for which resources are provisioned and deployed.
    Default: ''

Globals:
  Function:
    AutoPublishAlias: live
    DeploymentPreference:
      Enabled: true
      Type: Canary10Percent5Minutes
      Role: !Ref CodeDeployRole

Resources:
  HelloWorld:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub 'awscodestar-${ProjectId}-lambda-HelloWorld'
      Handler: index.handler
      Runtime: python3.7
      Role:
        Fn::GetAtt:
        - LambdaExecutionRole
        - Arn
      Events:
        GetEvent:
          Type: Api
          Properties:
            Path: /
            Method: get
        PostEvent:
          Type: Api
          Properties:
            Path: /
            Method: post
  LambdaExecutionRole:
    Description: Creating service role in IAM for AWS Lambda
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'CodeStar-${ProjectId}-Execution${Stage}'
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [lambda.amazonaws.com]
          Action: sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      PermissionsBoundary: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/CodeStar_${ProjectId}_PermissionsBoundary'
</code></pre>
<ul>
<li><a href="https://docs.aws.amazon.com/ja_jp/codestar/latest/userguide/templates.html">https://docs.aws.amazon.com/ja_jp/codestar/latest/userguide/templates.html</a></li>
</ul>
<hr />
<h1 id="jenkins">Jenkins</h1>
<p>ユースケース:</p>
<ul>
<li>CodePipeline からの Jenkins プロバイダーの呼び出し。</li>
<li>Jenkins から ECR/ECS, Lambda へのデプロイ等。</li>
</ul>
<p><img alt="" src="_attachment/image_606.png" /></p>
<ul>
<li>Worker (=Slave) は Master と同一インスタンスにも別インスタンスにも配置できる。</li>
<li>マルチマスターも可能。(マスターの Multi-AZ 配置など)</li>
</ul>
<p><img alt="" src="_attachment/image_607.png" /></p>
<h3 id="amazon-ec2">Amazon EC2 プラグイン</h3>
<p>Jenkins ワーカーノードの自動スケーリング。</p>
<p>Jenkins プライマリの Amazon EC2 プラグインが EC2 API で負荷に応じて自動的にワーカーノードを作成・削除する。</p>
<p><img alt="" src="_attachment/image_608.png" /></p>
<ul>
<li>プライマリの Amazon EC2 プラグインにより、新しい EC2 インスタンスを自動的に作成して Jenkins エージェントとして接続する</li>
<li>過負荷になると、Jenkins プライマリによって、ビルドがエージェントにオフロードされる。</li>
<li>負荷が低下すると、Jenkins プライマリにより余分なワーカーノードが自動的に終了される。</li>
<li>同様に ECS でエージェントを起動するプラグリンもある。</li>
</ul>
<h3 id="aws-codebuild_1">AWS CodeBuild プラグイン</h3>
<ul>
<li>Jenkins ビルドタスクを CodeBuild に投げて実行させられる。</li>
<li>CloudWatch Logs によりビルドログ保存。S3 にアーティファクト保存。</li>
</ul>
<p><img alt="" src="_attachment/image_609.png" /></p>
<p>その他のプラグイン</p>
<ul>
<li>AWS CodePipeline ... CodePipline のアクションプロバイダ統合で必要。</li>
<li>S3 publisher</li>
<li>Artifact Manager on S3</li>
</ul>
<hr />
<p>テスト自動化</p>
<p><img alt="" src="_attachment/image_610.png" /></p>
<ul>
<li>UAT: User Acceptance Test</li>
<li>A/B テスト<ul>
<li>2 つ以上のさまざまなバージョンの機能が別のユー ザに提供されるテスト方式。</li>
<li>各実装の使用に関するメトリクスを収集し、UX エンジニアはこのデータを検証し てどの実装を採用すべきかを判断する。</li>
<li>Route 53 の加重ラウンドロビンなどで実現。</li>
</ul>
</li>
</ul>
<h2 id="mock">Mock サーバ</h2>
<p>通常、モックサーバは HTTP の API コール をシミュレーションするために使用される。</p>
<p>API Gateway の Mock 統合が使える。</p>
<p><img alt="" src="_attachment/image_611.png" /></p>
<ul>
<li>耐障害性テスト: HA が機能するか確認。プライマリインスタンスを落としてみたり。</li>
<li>AWS Fault Injection Simulator<ul>
<li><a href="https://aws.amazon.com/jp/fis/">https://aws.amazon.com/jp/fis/</a></li>
<li>スポットインスタンスの中断とかを実施できる。</li>
</ul>
</li>
</ul>
<p><img alt="" src="_attachment/image_612.png" /></p>
<ul>
<li>ビッグバン – すべてのモジュールが同時に統合およびテストされます。</li>
<li>トップダウン – GUI などの最上位レベルのモジュールからテストが開始さ れ、次に後続のモジュールがテストされます。</li>
<li>ボトムアップ – 制御フローの下部からテストが実行されます。</li>
</ul>
<h2 id="blazemeter">BlazeMeter</h2>
<ul>
<li>JMeterのマネージドサービス</li>
<li>負荷 テスト、ストレステスト、パフォーマンステストの実施。</li>
<li>CodePipelineのアクションプロバイダー (テストプロバイダー)として指定できるようなっている</li>
</ul>
<p><img alt="" src="_attachment/image_613.png" /></p>
<h2 id="codepipeline_1">CodePipeline のテストアクションプロバイダー</h2>
<p><img alt="" src="_attachment/image_614.png" /></p>
<ul>
<li>Device Farm:  実際のスマホやタブレットで、Android, iOS, Web アプリを物理的にテストできるサービス。</li>
</ul>
<p><br></p>
</article>

    </main>
    <footer>
        <p>&copy; 2025 AWS DevOps Notes</p>
    </footer>
    <script src="static/script.js"></script>
</body>
</html>