<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AWS - CICD - AWS DevOps Notes</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    
    <header>
        <h1>AWS - CICD</h1>
    </header>
    
    <main>
        
<article>
    <h1 id="devops-cicd-basics">DevOps &amp; CI/CD basics</h1>
<p>DevOps = Dev + SysOps</p>
<p>手法</p>
<ul>
<li>マイクロサービスアーキテクチャ</li>
<li>Infrastructure as Code</li>
<li>CI/CD パイプライン</li>
</ul>
<h2 id="_1">マイクロサービスアーキテクチャ</h2>
<ul>
<li>two-pizza teams<ul>
<li>2つのピザを食べ切れるくらいの規模(6~8 名)にチームとサービスを分解。</li>
<li>俊敏性を高めるため。</li>
</ul>
</li>
<li>APIによる疎結合のサービス連携</li>
</ul>
<h2 id="cicd">CI/CD</h2>
<p>Continuous Integration</p>
<ul>
<li>コミットと同時に自動でビルド・テストが走る。元来はテスト自動化が動機っぽい。</li>
<li>Build して artifact が保存されるまで。</li>
<li>UT 含むが(たぶん)デプロイして実行するインテグレーションテストは含まない。</li>
</ul>
<p>Continuous Delivery vs. Continuous Deployment</p>
<ul>
<li>Continuous Delivery: 人が確認・承認した上でデプロイ</li>
<li>Continuous Deployment は人手のプロセスがなく自動デプロイされる。</li>
</ul>
<p><img alt="" src="_attachment/image_533.png" /></p>
<ul>
<li>BB: AWS Code Services: <a href="https://d1.awsstatic.com/webinars/jp/pdf/services/20170322_AWS-BlackBelt-CodeCommit-CodeBuild.pdf">https://d1.awsstatic.com/webinars/jp/pdf/services/20170322_AWS-BlackBelt-CodeCommit-CodeBuild.pdf</a></li>
<li>BB: AWS Code Services Part 2: <a href="https://d1.awsstatic.com/webinars/jp/pdf/services/20170628_AWS-BlackBelt_CodeSeries_CodeDeploy_and_CodePipeline.pdf">https://d1.awsstatic.com/webinars/jp/pdf/services/20170628_AWS-BlackBelt_CodeSeries_CodeDeploy_and_CodePipeline.pdf</a></li>
</ul>
<hr />
<h1 id="aws-codecommit">AWS CodeCommit</h1>
<p>特徴</p>
<ul>
<li>フルマネージドの Git サービス。</li>
<li>サイズが制限なく、コードは AWS アカウントにプライベート。</li>
<li>送信時 (SSH/HTTPS) および保存時 (KMS) の暗号化。</li>
<li>IAM ロール, CloudWatch, CloudTrail により他の AWS サービスとの連携が容易</li>
<li>サードパーティーと連携可能</li>
<li>Ref. <a href="https://pages.awscloud.com/rs/112-TZM-766/images/20201020_BlackBelt_AWS_CodeCommit_AWS_CodeArtifact.pdf">https://pages.awscloud.com/rs/112-TZM-766/images/20201020_BlackBelt_AWS_CodeCommit_AWS_CodeArtifact.pdf</a></li>
</ul>
<p><img alt="" src="_attachment/image_534.png" /></p>
<p>使い方</p>
<ul>
<li>AWS CLI かコンソールで CodeCommit 上にリモートレポジトリを作る。</li>
<li>あとの git clone, push, pull などの作業は普通の Git と同じ。</li>
</ul>
<h3 id="_2">認証方法</h3>
<ul>
<li>IAM コンソールで認証情報を登録する。</li>
<li><img alt="" src="_attachment/image_535.png" /></li>
<li>SSH: キーペアを作り IAM ユーザに公開鍵を登録。</li>
<li>HTTPS: IAM ユーザの Git 認証情報 (ユーザ名/パスワード) を生成する。</li>
</ul>
<h3 id="_3">認証情報ヘルパー</h3>
<ul>
<li>認証情報ヘルパーを使えば aws-cli 経由でプロファイルに指定したユーザの権限で認証してくれるので、認証情報の登録が不要。</li>
</ul>
<pre><code>git config --global credential.helper '!aws --profile dev codecommit credential-helper $@'
git config --global credential.UseHttpPath true
</code></pre>
<ul>
<li>~/.gitconfig に次のように記載される。</li>
</ul>
<pre><code>[credential]   
    helper = !aws --profile dev codecommit credential-helper $@
    UseHttpPath = true
</code></pre>
<p><img alt="" src="_attachment/image_536.png" /></p>
<ul>
<li>AWSCodeCommitFullAccess, AWSCodeCommitPowerUser,  AWSCodeCommitReadOnly などの AWS マネージドポリシーがあるが、これらのポリシーではアカウントの全リポジ トリへのアクセスが許可されてしまう。</li>
<li>ベストプラクティスは、個々のリポジトリ固有のカスタマーマネージドポリシーを作成すること。</li>
<li><strong>リソースポリシーはサポートされていない</strong>。プリンシパルにマネージドポリシーをアタッチし、Resource セクションに リポジトリのARN を指定する。</li>
</ul>
<p>master ブランチへの push や merge を拒否するポリシーの例:</p>
<p><a href="https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-conditional-branch.html">https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-conditional-branch.html</a></p>
<pre><code>{
    &quot;Version&quot;: &quot;2012-10-17&quot;,
    &quot;Statement&quot;: [
        {
            &quot;Effect&quot;: &quot;Deny&quot;,
            &quot;Action&quot;: [
                &quot;codecommit:GitPush&quot;,
                &quot;codecommit:DeleteBranch&quot;,
                &quot;codecommit:PutFile&quot;,
                &quot;codecommit:MergeBranchesByFastForward&quot;,
                &quot;codecommit:MergeBranchesBySquash&quot;,
                &quot;codecommit:MergeBranchesByThreeWay&quot;,
                &quot;codecommit:MergePullRequestByFastForward&quot;,
                &quot;codecommit:MergePullRequestBySquash&quot;,
                &quot;codecommit:MergePullRequestByThreeWay&quot;
            ],
            &quot;Resource&quot;: &quot;arn:aws:codecommit:*:*:*&quot;,
            &quot;Condition&quot;: {
                &quot;StringEqualsIfExists&quot;: {
                    &quot;codecommit:References&quot;: [
                        &quot;refs/heads/main&quot;
                    ]
                },
                &quot;Null&quot;: {
                    &quot;codecommit:References&quot;: &quot;false&quot;
                }
            }
        }
    ]
}
</code></pre>
<p>CodeCommit の暗号化</p>
<ul>
<li>デフォルトで AWS 管理キー (AWS managed CMKs) で暗号化される。</li>
</ul>
<p>外部レポジトリからのマイグレーション</p>
<ul>
<li>CodeCommit にリポジトリを作成し、外部リポジトリを一旦ローカルに clone してから CodeCommit リポジトリを remote に設定して push する。</li>
</ul>
<p>プルリクエスト</p>
<ul>
<li>AWS コンソールまたは AWS CLI から作成できる。</li>
<li>送信元ブランチのコンテンツを、マージ先ブランチ (送信先ブランチ) と比較する。</li>
<li><img alt="" src="_attachment/image_538.png" /></li>
<li>プルリクのマージの承認ルールというのが追加されている。</li>
</ul>
<p>クライアント側フック</p>
<ul>
<li>リポジトリの .git/hooks サブディレクトリにインストールされる。</li>
</ul>
<p>サーバ側フック</p>
<ul>
<li>CodeCommit ではサーバ側のフックは CodeCommit イベントで処理される。</li>
</ul>
<p>CodeCommit リポジトリトリガー</p>
<ul>
<li>コード Push などのリポジトリイベントで SNS, Lambda をトリガーしアクションを実行。</li>
<li><img alt="" src="_attachment/image_539.png" /></li>
<li>関連リソースは CodeCommit と同じリージョンにある必要がある</li>
<li><a href="https://docs.aws.amazon.com/ja_jp/codecommit/latest/userguide/how-to-notify.html">https://docs.aws.amazon.com/ja_jp/codecommit/latest/userguide/how-to-notify.html</a></li>
<li>Lambda 側からトリガーを追加してもここに反映される:</li>
<li><img alt="" src="_attachment/image_540.png" /></li>
<li><img alt="" src="_attachment/image_541.png" /></li>
<li><a href="https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-notify-lambda.html">https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-notify-lambda.html</a></li>
</ul>
<p>通知ルール</p>
<ul>
<li>SNS か AWS Chatbot に通知を投げる。</li>
<li><img alt="" src="_attachment/image_542.png" /></li>
<li><a href="https://docs.aws.amazon.com/ja_jp/codecommit/latest/userguide/how-to-repository-email.html">https://docs.aws.amazon.com/ja_jp/codecommit/latest/userguide/how-to-repository-email.html</a></li>
<li>CodeStar Notifications が提供する機能。CodeCommit/CodeBuild/CodePipeline 等のイベントに共通して適用可能。</li>
<li>通知ルール作成時、選択イベントに一致する EventBridge ルールが自動生成され、通知先へルーティングされる。</li>
<li><img alt="" src="_attachment/image_543.png" /></li>
</ul>
<p>CodeBuild/CodePipeline 連携</p>
<ul>
<li>EventBridge ルールを作成してイベントソースを CodeCommit にする。</li>
<li>コード変更時にビルドをかけるには "CodeCommit Repository State Change" イベント。</li>
<li>ターゲットを CodeBuild プロジェクトや CodePipeline パイプラインの ARN とする。</li>
<li><a href="https://docs.aws.amazon.com/ja_jp/codepipeline/latest/userguide/pipelines-trigger-source-repo-changes-cli.html">https://docs.aws.amazon.com/ja_jp/codepipeline/latest/userguide/pipelines-trigger-source-repo-changes-cli.html</a></li>
</ul>
<pre><code>{
  &quot;source&quot;: [&quot;aws.codecommit&quot;],
  &quot;detail-type&quot;: [&quot;CodeCommit Repository State Change&quot;]
}
</code></pre>
<p>CloudTrail 連携</p>
<ul>
<li>CodeCommit API コールをキャプチャして S3 バケットに保存可能</li>
</ul>
<h1 id="_4">ブランチ戦略</h1>
<p><img alt="" src="_attachment/image_544.png" /></p>
<ul>
<li>メインブランチ、開発ブランチ、Feature ブランチ、リリースブランチ、修正ブランチ等、複数のブランチを使い分けるモデル。</li>
<li>コミットがあちこちのブランチに散らばるので管理が大変になりがち。</li>
<li><a href="https://aws.amazon.com/jp/blogs/devops/implementing-gitflow-using-aws-codepipeline-aws-codecommit-aws-codebuild-and-aws-codedeploy/">https://aws.amazon.com/jp/blogs/devops/implementing-gitflow-using-aws-codepipeline-aws-codecommit-aws-codebuild-and-aws-codedeploy/</a></li>
</ul>
<h3 id="_5">トランクベース開発</h3>
<p><img alt="" src="_attachment/image_545.png" /></p>
<ul>
<li>トランクと呼ばれる 1 つの共有ブランチにコミットの大半をマージする。</li>
<li>リリース時はリリースブランチを切り、次のリリースまでの短期間使用される。</li>
<li>ほとんどのコミットはトランクに行われ、リリースブランチにマージされる。</li>
<li>Amazon では開発者がコミットをトランクに定期的に (理想的には 1 日数回) マージする「トランクベース開発」により継続的インテグレーションを実践するよう強く推奨。</li>
<li>チームが小さな変更を定期的にマージできる場合、マージの複雑さと労力を最小限に抑えることができる。</li>
<li>トランクベースの継続的インテグレーション・デリバリーを組み合わせることで、本番環境に変更を加えるまでのリードタイ ムを短縮できる。</li>
</ul>
<hr />
<h1 id="aws-codebuild">AWS CodeBuild</h1>
<h2 id="_6">概要</h2>
<ul>
<li>CI サーバ (Build/Test) のマネージドサービス。</li>
<li>ソースコード取得<ul>
<li>CodeCommit, S3, GitHub</li>
</ul>
</li>
<li>ビルド環境<ul>
<li>Docker イメージで用意される。</li>
</ul>
</li>
<li>ビルドコマンド<ul>
<li>buildspec.yml に記述。</li>
<li>ビルドコマンド出力はログに送信される。</li>
</ul>
</li>
<li>アーティファクト<ul>
<li>S3 バケットにアップロード。</li>
</ul>
</li>
</ul>
<p><img alt="" src="_attachment/image_546.png" />
<img alt="" src="_attachment/File_9.png" /></p>
<h2 id="_7">ビルドプロジェクト</h2>
<p>ソース、ビルド環境、buildspec ファイル名、アーティファクト (出力先 S3 バケット名) 等を指定する。</p>
<p>Ref. <a href="https://docs.aws.amazon.com/ja_jp/codebuild/latest/userguide/create-project-console.html">https://docs.aws.amazon.com/ja_jp/codebuild/latest/userguide/create-project-console.html</a></p>
<h3 id="_8">ソース</h3>
<ul>
<li>ソースプロバイダーの種類<ul>
<li>S3, CodeCommit, GitHub, GitHub Enterprise, Bitbucket</li>
<li><img alt="" src="_attachment/image_547.png" /></li>
<li><img alt="" src="_attachment/image_548.png" /></li>
</ul>
</li>
</ul>
<h3 id="_9">ビルド環境</h3>
<ul>
<li>ビルドサーバの Docker イメージを指定する。</li>
<li>マネージド型イメージ<ul>
<li>CodeBuild の Docker イメージレポジトリで管理されたイメージ。</li>
</ul>
</li>
<li>カスタムイメージ<ul>
<li>Docker Hub, ECR にあるイメージを指定。</li>
</ul>
</li>
<li>
<p>マネージド型イメージで提供される OS</p>
<ul>
<li>Amazon Linux 2, Ubuntu, Windows Server のイメージが提供されている。<ul>
<li>Windows Server は us-east 等、特定リージョンのみ。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><img alt="" src="_attachment/image_549.png" /></p>
</li>
<li>Ref.<ul>
<li><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref.html#build-env-ref-available">https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref.html#build-env-ref-available</a></li>
<li><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html">https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html</a></li>
<li><a href="https://blog.shibayan.jp/entry/20180527/1527423170">https://blog.shibayan.jp/entry/20180527/1527423170</a></li>
</ul>
</li>
<li>サービスロール<ul>
<li>CodeBuild サービスが各種サービスにアクセスするのに必要なロール。<ul>
<li>CodeCommit ... ソース取得</li>
<li>S3 ... ソース/アーティファクト入出力</li>
<li>ECR ... ビルドサーバのカスタムイメージ取得、ビルドしたイメージのプッシュ</li>
</ul>
</li>
<li><strong>ビルドサーバのコンテナ環境にもサービスロールの権限が引き継がれる</strong> (クリデンシャルが環境変数経由で渡される)</li>
</ul>
</li>
<li>タイムアウト<ul>
<li>最長8時間までのタイムアウトを指定できる。</li>
<li>Lambda で出来ない時間のかかるパフォーマンステスト等を実施できる。</li>
</ul>
</li>
<li>VPC<ul>
<li>ビルド環境に VPC を指定して VPC 内部のリソースへのアクセスも可能。</li>
</ul>
</li>
<li>環境変数<ul>
<li>環境変数の上書き指定。SSM パラメータストアからの取得も指定可能。</li>
<li><img alt="" src="_attachment/image_550.png" /></li>
</ul>
</li>
</ul>
<h3 id="_10">アーティファクト</h3>
<ul>
<li>保存先の S3 バケットを指定する。(オプショナル)</li>
<li>暗号化<ul>
<li>デフォルト: SSE-KMS の aws/s3 AWS managed CMK を使って暗号化。<ul>
<li>バケットのデフォルト暗号化を SSE-S3 にしていても CodeBuiild 側が SSE-KMS を付与してアップロード。</li>
</ul>
</li>
<li>カスタム: Customer managed CMK をプロジェクトで設定する。</li>
</ul>
</li>
</ul>
<h3 id="_11">ログ</h3>
<ul>
<li>オプショナルで CloudWatch Log と S3 バケットにログを保存できる。</li>
<li>CodeBuild コンソールに出力されるログは環境が終了すると消える。</li>
</ul>
<h3 id="_12">ビルドキャッシュ</h3>
<ul>
<li>ビルド環境の特定のパスをキャッシュすることで、ビルドツール・依存モジュールのダウンロードやビルド時間を短縮できる。</li>
<li>アーティファクトセクションのキャッシュタイプで有効化。</li>
<li><img alt="" src="_attachment/image_551.png" /></li>
<li>対象ファイルは buildspec.yaml の cache セクションで指定。<ul>
<li><img alt="" src="_attachment/image_552.png" /></li>
</ul>
</li>
<li>S3<ul>
<li>It stores the cache in an Amazon S3 bucket that is <strong>available across multiple build hosts</strong>.</li>
<li>This is a good option for small to intermediate sized build artifacts that are more expensive to build than to download.</li>
<li>This is <strong>not the best option for large build artifacts because they can take a long time to transfer over your network</strong>, which can affect build performance. It also is not the best option if you use Docker layers.</li>
</ul>
</li>
<li>Local<ul>
<li>Local caching stores a cache locally on a build host that is <strong>available to that build host only</strong>.</li>
<li>This is a good option for intermediate to large build artifacts because the cache is immediately available on the build host.</li>
<li><strong>Options</strong>:<ul>
<li>DockerLayerCache ... コンテナイメージのビルドのためのキャッシュ</li>
<li>SourceCache ... .git メタデータのキャッシュ</li>
<li>CustomCache ... buildspec.yaml で指定するキャッシュ</li>
</ul>
</li>
<li><img alt="" src="_attachment/image_553.png" /></li>
</ul>
</li>
</ul>
<h4 id="_13">ビルドキャッシュの運用</h4>
<p>CodeBuild キャッシュの失効・削除</p>
<ul>
<li>S3 に保存されたキャッシュを手動で削除して失効させる</li>
<li>S3 ライフサイクルポリシーでキャッシュ失効（有効期限・削除ルール）を自動化</li>
</ul>
<p>プロジェクト側での無効化・上書き</p>
<ul>
<li>プロジェクト設定を更新してキャッシュ動作を上書き</li>
<li>InvalidateProjectCache API でキャッシュを無効化<ul>
<li>既存キャッシュの実体は削除されない（実行中ビルドとの不整合回避のため）</li>
<li>以降のビルドで新しいキーが使われ、古いキャッシュは参照されない</li>
</ul>
</li>
</ul>
<p>キャッシュ対象の指針</p>
<ul>
<li>キャッシュはビルド環境の任意フォルダに有効化できるが、頻繁に変化しない依存関係・ファイルに限定する</li>
<li>予期しない動作を避けるため、設定ファイルや機密情報はキャッシュしない</li>
</ul>
<p>Ref.</p>
<ul>
<li><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-caching.html">https://docs.aws.amazon.com/codebuild/latest/userguide/build-caching.html</a></li>
<li><a href="https://aws.amazon.com/jp/blogs/devops/how-to-enable-caching-for-aws-codebuild/">https://aws.amazon.com/jp/blogs/devops/how-to-enable-caching-for-aws-codebuild/</a></li>
</ul>
<h2 id="buildspec-buildspecyml">BuildSpec (buildspec.yml)</h2>
<ul>
<li>ソースの root ディレクトリに配置。(ビルドプロジェクトで異なるパスも指定可能)</li>
<li>各ビルドフェーズのコマンド、アーティファクトとして保存するファイルを指定。</li>
</ul>
<p><img alt="" src="_attachment/image_555.png" />
<img alt="" src="_attachment/image_556.png" /></p>
<p>phases セクション</p>
<ul>
<li>install フェーズ<ul>
<li>runtime-versions でビルドランタイムのインストール指定。</li>
<li><img alt="" src="_attachment/File_10.png" /></li>
<li>dotnet, java, golang, php, nodejs, python, ruby をサポート。</li>
<li>command ブロックで install フェーズでもコマンド実行可能。</li>
</ul>
</li>
<li>post_build フェーズ<ul>
<li>UT やコンテナのプッシュ等を実施。</li>
</ul>
</li>
<li>run-as: Linux-user-name<ul>
<li>全体および各フェーズに指定可能。</li>
</ul>
</li>
<li>finally ブロック<ul>
<li>各セクションに指定。command ブロックでエラーがあったときも必ず実行される。</li>
</ul>
</li>
</ul>
<p>artifacts セクション</p>
<ul>
<li>artifact として S3 に保存するファイルを指定。</li>
<li>**/* のようなワイルドカードも使える。</li>
</ul>
<p>env セクション</p>
<ul>
<li>環境変数設定。パラメータストアからも簡単に取得できる。</li>
</ul>
<pre><code>env:
  variables:
    JAVA_HOME: &quot;/usr/lib/jvm/java-8-openjdk-amd64&quot;
  parameter-store:
    LOGIN_PASSWORD: /CodeBuild/dockerLoginPassword
</code></pre>
<ul>
<li>pre-define の環境変数も大量にある。<ul>
<li><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-env-vars.html">https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-env-vars.html</a></li>
</ul>
</li>
</ul>
<p>Docker イメージをビルドする buidspec.yaml 例:</p>
<ul>
<li>docker login でレポジトリにログイン。</li>
<li>buidspec.yaml と同じディレクトリの (暗黙に選択される) Dockerfile  で docker build を実行。</li>
<li>post_build で ECR に push する。artifacts セクション不要。</li>
<li>サービスロールに ECR アクセスの権限が必要。</li>
</ul>
<pre><code>version: 0.2

phases:
  pre_build:
    commands:
      - echo Logging in to Amazon ECR...
      - aws --version
      - REPOSITORY_URI=041845206805.dkr.ecr.us-west-2.amazonaws.com/gold-repo
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $REPOSITORY_URI
      - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - IMAGE_TAG=${COMMIT_HASH:=latest}
  build:
    commands:
      - echo Build started on `date`
      - echo Building the Docker image...
      - docker build -t $REPOSITORY_URI:latest .
      - docker tag $REPOSITORY_URI:latest $REPOSITORY_URI:$IMAGE_TAG
  post_build:
    commands:
      - echo Build completed on `date`
      - echo Pushing the Docker images...
      - docker push $REPOSITORY_URI:latest
      - docker push $REPOSITORY_URI:$IMAGE_TAG
</code></pre>
<p>Ref.</p>
<ul>
<li><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-syntax">https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-syntax</a></li>
<li><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/use-case-based-samples.html">https://docs.aws.amazon.com/codebuild/latest/userguide/use-case-based-samples.html</a></li>
</ul>
<h2 id="_14">ビルドの保護</h2>
<p>AWS 管理ポリシー</p>
<ul>
<li>AWSCodeBuildAdminAccess – CodeBuild へのフルアクセスを提供。</li>
<li>AWSCodeBuildDeveloperAccess – CodeBuild へのアクセスを提供するがビルドプロジェクトの管理は許可しない。</li>
<li>AWSCodeBuildReadOnlyAccess – CodeBuild への読み取り専用アクセス。</li>
<li>AmazonS3ReadOnlyAccess – ビルド出力アーティファクト (S3) へのアクセス。</li>
</ul>
<p>IAM ロールでビルドアクションを制御する例</p>
<pre><code>{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: &quot;codebuild:CreateProject&quot;,
      &quot;Resource&quot;: &quot;arn:aws:codebuild:us-east-1:123456789012:project/*&quot;
    },
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: &quot;iam:PassRole&quot;,
      &quot;Resource&quot;: &quot;arn:aws:iam:123456789012:role/CodeBuildServiceRole&quot;
    }
  ]
}

</code></pre>
<h2 id="codepipeline">CodePipeline 連携</h2>
<ul>
<li>CodePipeline の Build アクションまたは Test アクションに連携サービスとして追加可能</li>
<li>CodeBuild を CI サーバとして利用</li>
</ul>
<h2 id="eventbridge">EventBridge による連携</h2>
<ul>
<li>CodeBuild プロジェクトをターゲットにしてビルド開始</li>
<li>CodeBuild をイベントソースにして Lambda 等と連携<ul>
<li><strong>CodeBuild Stage Change</strong> ... IN_PROGRESS, SUCCEEDED, FAILED, STOPPED</li>
<li><strong>CodeBuild Phase Change</strong> ... BuildSpec に出てくる各フェーズの遷移</li>
</ul>
</li>
</ul>
<p>例: Validating AWS CodeCommit Pull Requests with AWS CodeBuild and AWS Lambda</p>
<ul>
<li>PR を契機に CodeBuild でコードの自動テストを行い、結果を PR にコメント付与する例</li>
<li>CodeCommit をイベントソースとして CodeBuild を開始、CodeBuild をイベントソースとして Lambda で結果を通知。</li>
<li>Lambda はテスト開始時とテスト結果を PR にコメント追加するのに使用されている。</li>
<li>(ClaudWatch Event → EventBridge で読み替え)</li>
<li><img alt="" src="_attachment/image_558.png" /></li>
<li><a href="https://aws.amazon.com/jp/blogs/devops/validating-aws-codecommit-pull-requests-with-aws-codebuild-and-aws-lambda/">https://aws.amazon.com/jp/blogs/devops/validating-aws-codecommit-pull-requests-with-aws-codebuild-and-aws-lambda/</a></li>
</ul>
<hr />
<h1 id="aws-codedeploy">AWS CodeDeploy</h1>
<p><img alt="" src="_attachment/File_12.png" /></p>
<ul>
<li>リビジョン(=アーティファクト)取得元<ul>
<li>S3, GitHub のいずれか。</li>
<li>S3 の場合はデプロイ先 EC2 インスタンスのロールに S3 へのアクセス許可も必要。<ul>
<li>アーティファクトを各インスタンスのエージェントが pull するため</li>
</ul>
</li>
</ul>
</li>
<li>デプロイ先<ul>
<li>EC2/オンプレサーバ (<strong>要 CodeDeploy エージェント</strong>)<ul>
<li>インスタンスはデプロイグループ（例: dev / test / prod）ごとにグループ化</li>
</ul>
</li>
<li>ECS (Fargate)</li>
<li>Lambda<ul>
<li>NOTE: CodeDeploy 自体はリソースのプロビジョニングは行わない</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="_15">リビジョン</h2>
<p>デプロイ対象アプリケーションの(AppSpecを含む)パッケージ(の特定バージョン)をリビジョンと呼ぶ。</p>
<p><img alt="" src="_attachment/image_560.png" /></p>
<h2 id="codedeploy">CodeDeploy によるデプロイの流れ</h2>
<ol>
<li>あらかじめアプリケーション (=デプロイ設定) とデプロイグループを作成しておく。</li>
<li>S3 にソースコードをリビジョンとして push する。(aws deploy push)<ul>
<li>GitHub の場合は aws deploy register-application-revision で repo/commit をリビジョンとして登録</li>
</ul>
</li>
<li>
<p>デプロイを作成することでデプロイプロセスが開始。(aws deploy create-deployment)</p>
<ul>
<li>この際、アプリケーション名・デプロイグループ・リビジョンを指定。</li>
<li>デプロイタイプ (Blue/Green 等) に応じてデプロイメントがスケジュールされ、各インスタンス内のエージェントがリビジョンを pull して AppSpec に従って展開。</li>
</ul>
</li>
</ol>
<p><img alt="" src="_attachment/image_561.png" /></p>
<h3 id="_16">ラボで実行したコマンド例</h3>
<p>S3 バケットを作成後、ローカルにあるアプリケーションをリビジョンとして S3 バケットに push:</p>
<pre><code>aws deploy push --application-name CodeDeploy-Demo --source HeartBeat-App --s3-location s3://$bucketName/HeartBeat-App.zip
</code></pre>
<ul>
<li>ローカルディレクトリのファイルが zip されて S3 にアップロードされる。</li>
<li>裏で RegisterApplicationRevision コマンドで S3 のオブジェクトとリビジョンの紐付けを行なっている。</li>
<li>S3 バケットのバージョニングを有効にしておけば push するごとにバージョンが上がってリビジョンと紐づけられる。</li>
</ul>
<p>リビジョンをデプロイ:</p>
<pre><code>aws deploy create-deployment --application-name CodeDeploy-Demo --deployment-group-name HeartBeat-Deployment --deployment-config-name CodeDeployDefault.AllAtOnce --description &quot;Initial Deployment&quot; --s3-location bucket=$bucketName,key=HeartBeat-App.zip,bundleType=zip
</code></pre>
<p>アプリケーション更新の流れも同じ</p>
<p>新しいリビジョンを同じ S3 バケットにプッシュ:</p>
<pre><code>aws deploy push --application-name CodeDeploy-Demo --source HeartBeat-App --s3-location s3://$bucketName/HeartBeat-App.zip
</code></pre>
<p>同じコマンドでデプロイ:</p>
<pre><code>aws deploy create-deployment --application-name CodeDeploy-Demo --deployment-group-name HeartBeat-Deployment --deployment-config-name CodeDeployDefault.AllAtOnce --description &quot;Updated Deployment&quot; --s3-location bucket=$bucketName,key=HeartBeat-App.zip,bundleType=zip
</code></pre>
<h2 id="_17">アプリケーション</h2>
<p>デプロイ先プラットフォームを指定して作成する</p>
<p><img alt="" src="_attachment/image_562.png" /></p>
<h2 id="_18">デプロイグループ</h2>
<p>EC2/オンプレは以下から選択できる。1つのデプロイグループ内に複数の組み合わせを指定可能。</p>
<p><img alt="" src="_attachment/image_563.png" /></p>
<p>「EC2インスタンス」「オンプレインスタンス」ではタググループで指定可能:</p>
<p><img alt="" src="_attachment/image_564.png" /></p>
<p>Auto Scaling グループと Code Deploy</p>
<ul>
<li>ASGがスケールアウトする際、新規起動インスタンスに最新リビジョンが自動デプロイ。<ul>
<li>ASGのLifecycle Hook (EC2_INSTANCE_LAUNCHING) で、起動直後のインスタンスにデプロイを実行。</li>
</ul>
</li>
<li>追加インスタンスのみが対象（既存インスタンスはそのまま）。</li>
<li>Deployment Group に ASG を関連付けるだけで利用可。</li>
<li>インプレース・Blue/Green 両方を利用可能。</li>
</ul>
<p>環境設定</p>
<ul>
<li>EC2 Auto Scaling グループの自動コピー: ASG 全体の置き換えによるデプロイ (Blue/Green 専用)</li>
<li>インスタンスの手動プロビジョン:  デプロイの作成時に個別にインスタンスを指定する。</li>
<li><img alt="" src="_attachment/image_565.png" /></li>
</ul>
<p>ECS の場合は ECS クラスター名と ELB を指定。</p>
<p><img alt="" src="_attachment/image_566.png" /></p>
<h2 id="_19">デプロイタイプ</h2>
<p>デプロイグループで指定する。以下の２種類。</p>
<p>1) <strong>インプレース</strong> ... EC2, オンプレ (ECS, Lambdaは不可)</p>
<ul>
<li>複数台なら段階的にローリングデプロイできる</li>
</ul>
<p>2) <strong>Blue/Green</strong> ... EC2, ECS, Lambda (オンプレは不可)</p>
<ul>
<li>トラフィックルーティングで並行環境を切り替え</li>
<li>Lambda：エイリアスの加重ルーティング</li>
<li>EC2/ECS：ELBのターゲットグループ切替</li>
</ul>
<p><img alt="" src="_attachment/image_567.png" /></p>
<h3 id="_20">デプロイ設定</h3>
<p>Blue/Green に関連する設定</p>
<ul>
<li>EC2 インスタンス/Auto Scaling グループの Blue/Green には ELB 指定が必要</li>
<li>トラフィック再ルーティングの開始:  即時 or 検証後に手動・承認で実行</li>
<li>デプロイ成功後の旧環境インスタンスの保持 ...  保持すればロールバックが容易</li>
</ul>
<p><img alt="" src="_attachment/image_568.png" /></p>
<h4 id="bluegreen">デプロイ並行度の設定 (インプレース, Blue/Green 共通)</h4>
<p>EC2</p>
<ul>
<li><img alt="" src="_attachment/image_569.png" /></li>
</ul>
<p>ECS</p>
<ul>
<li><img alt="" src="_attachment/image_571.png" /></li>
</ul>
<p>Lambda</p>
<ul>
<li>
<p><img alt="" src="_attachment/image_570.png" /></p>
</li>
<li>
<p>Liner は10%ずつを段階的に。Canary は 10%→100%の2段階。</p>
</li>
</ul>
<h3 id="_21">トリガー (通知)</h3>
<ul>
<li>デプロイグループ設定でイベントを SNS 通知するトリガーを設定できる。</li>
<li>デプロイグループごとに最大 10 個。</li>
<li><img alt="" src="_attachment/image_572.png" /></li>
<li>CLI での表示例:</li>
<li><img alt="" src="_attachment/image_573.png" /></li>
</ul>
<p><a href="https://docs.aws.amazon.com/ja_jp/codedeploy/latest/userguide/monitoring-sns-event-notifications-edit-trigger.html">https://docs.aws.amazon.com/ja_jp/codedeploy/latest/userguide/monitoring-sns-event-notifications-edit-trigger.html</a></p>
<h2 id="appspec-file-appspecyml">AppSpec File (appspec.yml)</h2>
<p>デプロイ処理の定義</p>
<ul>
<li>リビジョンの root ディレクトリに配置する。</li>
<li>CodeDeploy エージェントによって実行される。</li>
<li>コピーするファイルの source/destination と各ステップで実行する hooks スクリプトを記述</li>
</ul>
<p>例: Linux</p>
<pre><code>&quot;version&quot;: 0.0                     ← 必ず 0.0 であること
os: linux                          ← Windows と Linux のサポート
files:                             ← インストールイベント中にインストールされるファイル
  &quot;source&quot;: Config/config.txt
    destination: /webapps/Config
  - source: source
    destination: /webapps/myApp
hooks:                             ← イベントで実行されるスクリプト
  BeforeInstall:
    - location: Scripts/UnzipResourceBundle.sh
    - location: Scripts/UnzipDataBundle.sh
  AfterInstall:
    - location: Scripts/RunResourceTests.sh
      timeout: 180
  ApplicationStart:
    - location: Scripts/RunFunctionalTests.sh
      timeout: 3600
  ValidateService:
    - location: Scripts/MonitorService.sh
      timeout: 3600
      runas: codedeployuser

</code></pre>
<p>例: Windows</p>
<pre><code>version: 0.0
os: windows
files:
  - source: Heartbeat.dll
    destination: c:\HeartbeatService
  - source: HeartbeatService.exe
    destination: c:\HeartbeatService
  - source: HeartbeatService.exe.config
    destination: c:\HeartbeatService
  - source: log4net.dll
    destination: c:\HeartbeatService
  - source: Logger.dll
    destination: c:\HeartbeatService
  - source: wintail.exe
    destination: c:\temp

hooks:
  ApplicationStop:
    - location: uninstall.ps1
      timeout: 30
  AfterInstall:
    - location: install.ps1
      timeout: 30
    - location: copywintail.ps1
      timeout: 30
</code></pre>
<h3 id="hooks">Hooks セクション</h3>
<ul>
<li>デプロイ前後に独自スクリプトや Lambda などを実行可能<ul>
<li>ValidateService で外部 Lambda からアクセスして動作検証など</li>
</ul>
</li>
<li>timeout: タイムアウト指定</li>
<li>runas: 実行ユーザ指定</li>
<li>Hooks で実行するスクリプトもリビジョンにバンドルする。</li>
</ul>
<p><strong>EC2 - インプレース</strong></p>
<ul>
<li><img alt="" src="_attachment/File_14.png" /></li>
<li>ApplicationStop ... アプリの停止処理を実装</li>
<li>BeforeInstall ... 旧アプリのバックアップや旧ファイルの削除、インストール前の前処理を実装</li>
<li>AfterInstall ... 依存関係のインストールやビルド・展開、バックアップからのマイグレーションなど、実質的なセットアップを実装</li>
<li>ApplicationStart ... アプリの起動処理を実装</li>
<li>ValidateService ... ApplicationStart フック完了後に実行される<ul>
<li>アプリの初期化の完了をヘルスチェックなどで確認し、必要な検証を行う。</li>
</ul>
</li>
<li>Ref. <a href="https://docs.aws.amazon.com/ja_jp/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html">https://docs.aws.amazon.com/ja_jp/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html</a></li>
</ul>
<p><strong>EC2 - Blue/Green</strong></p>
<ul>
<li>Green の AfterAllowTraffic 後に Blue の BlockTraffic に移行。</li>
<li>イミュータブルなので停止される Blue 側は BlockTraffic 関連のイベントしか走らない。<ul>
<li><img alt="" src="_attachment/image_575.png" /></li>
</ul>
</li>
</ul>
<h3 id="lambda-appspec">Lambda の AppSpec</h3>
<pre><code>version: 0.0
Resources:
  - myLambdaFunction:
      type: Type: AWS::Lambda::Function
      Properties:
        &quot;name&quot;: myLambdaFunction:
        Alias: &quot;myLambdaFunctionAlias&quot;
        CurrentVersion: &quot;1&quot;
        TargetVersion: &quot;2&quot;
Hooks:
  - BeforeAllowTraffic: &quot;LambdaFunctionToValidateBeforeTrafficShift&quot;
  - AfterAllowTraffic: &quot;LambdaFunctionToValidateAfterTrafficShift&quot;

</code></pre>
<p>Resource セクション</p>
<ul>
<li>ターゲットの Lambda 関数名・エイリアス・現在と移行先のバージョンを指定。</li>
<li><code>CurrentVersion</code>, <code>TargetVersion</code> で移行元・移行先を指定し、リビジョン指定（S3/GitHub）は不要</li>
</ul>
<p>Hooks セクション</p>
<ul>
<li>EC2/オンプレのように内部でスクリプト実行できる訳ではないので、Hook には呼び出す Lambda 関数名を指定する。</li>
<li><img alt="" src="_attachment/image_576.png" /></li>
</ul>
<h3 id="ecs-appspec">ECS の AppSpec</h3>
<p>ECS はコンテナイメージが別途コンテナディレクトリに登録され、AppSpec はコンテナ内に置けないため、S3 にファイル単体で置く。(または CreateDeployment API/CLI の AppSpecContent パラメータでインライン指定)</p>
<p>ECS デプロイでは、CodeDeploy 自体が ECS の内部構成（タスク定義やロードバランサなど）を直接知らないため、<strong>AppSpec で入れ替えるサービス・コンテナ・ポートを明示的に指定する必要</strong>がある。</p>
<p>CodeDeploy のリビジョン指定は行わず、ECS の <strong>タスク定義リビジョン</strong>で切り替え。</p>
<pre><code>version: 0.0
Resources:
  - TargetService:
      type: AWS::ECS::Service
      Properties:
        TaskDefinition: &quot;arn:aws:ecs:us-east-1:111222333444:task-definition/my-task-definition-family-name:1&quot;
        LoadBalancerInfo:
          ContainerName: &quot;SampleApplicationName&quot;
          ContainerPort: 80
# Optional properties
        PlatformVersion: &quot;LATEST&quot;
        NetworkConfiguration:
          AwsVpcConfiguration:
            Subnets: [&quot;subnet-1234abcd&quot;,&quot;subnet-5678abcd&quot;]
            SecurityGroups: [&quot;sg-12345678&quot;]
            AssignPublicIp: &quot;ENABLED&quot;
Hooks:
  - BeforeInstall: &quot;BeforeInstallHookFunctionName&quot;
  - AfterInstall: &quot;AfterInstallHookFunctionName&quot;
  - AfterAllowTestTraffic: &quot;AfterAllowTestTrafficHookFunctionName&quot;
  - BeforeAllowTraffic: &quot;BeforeAllowTrafficHookFunctionName&quot;
  - AfterAllowTraffic: &quot;AfterAllowTrafficHookFunctionName&quot;
</code></pre>
<ul>
<li>BeforeInstall<ul>
<li>ECS アプリケーションが置き換えタスクセットにインストールされる前に実行。</li>
</ul>
</li>
<li>AfterInstall<ul>
<li>ECS アプリケーションが置き換えタスクセットにインストールされた後、トラフィック受信前に実行。</li>
</ul>
</li>
<li>AfterAllowTestTraffic<ul>
<li>更新後 ECS アプリケーションがテストリスナーからトラフィックを受信すると実行。</li>
<li>デプロイを続行するかどうか判断するための検証テスト等を実行する。</li>
<li>デプロイグループで ELB のテストリスナー(オプショナル)を指定しない場合は呼ばれない。</li>
</ul>
</li>
<li>BeforeAllowTraffic<ul>
<li>本番トラフィックが ECS アプリケーションに配信される前に実行。</li>
</ul>
</li>
<li>AfterAllowTraffic<ul>
<li>本番トラフィックが ECS アプリケーションに配信されると実行。</li>
</ul>
</li>
</ul>
<p>AfterAllowTestTraffic と Test Listener</p>
<ul>
<li>CodeDeploy の ECS デプロイでは新しい Task Set と ELB ターゲットグループが作られる。</li>
<li>AfterAllowTestTraffic のタイミングで Test Listener のルーティング先が新しいターゲットグループになる。</li>
<li>Test Listener は Production Listener と別ポート (8080) 等でルーティングが異なるリスナー。</li>
<li>AfterAllowTestTraffic フックの Lambda で Test Listener にリクエストを投げて Validation を実施する。</li>
<li><img alt="" src="_attachment/image_581.png" /></li>
<li><a href="https://docs.amazonaws.cn/en_us/codedeploy/latest/userguide/tutorial-ecs-deployment-with-hooks.html">https://docs.amazonaws.cn/en_us/codedeploy/latest/userguide/tutorial-ecs-deployment-with-hooks.html</a></li>
</ul>
<h3 id="appspec">AppSpec 内で利用できる環境変数</h3>
<ul>
<li>APPLICATION_NAME<ul>
<li>e.g. WordPress_App</li>
</ul>
</li>
<li>DEPLOYMENT_ID<ul>
<li>e.g. d-AB1CDEF23</li>
</ul>
</li>
<li>DEPLOYMENT_GROUP_NAME<ul>
<li>e.g.  WordPress_DepGroup</li>
</ul>
</li>
<li>DEPLOYMENT_GROUP_ID<ul>
<li>e.g.  b1a2189b-dd90-4ef5-8f40-4c1c5EXAMPLE</li>
</ul>
</li>
<li>LIFECYCLE_EVENT<ul>
<li>e.g. AfterInstall</li>
</ul>
</li>
</ul>
<p>Bundle from S3:</p>
<ul>
<li>BUNDLE_BUCKET<ul>
<li>e.g. my-s3-bucket</li>
</ul>
</li>
<li>BUNDLE_KEY<ul>
<li>e.g. WordPress_App.zip</li>
</ul>
</li>
<li>BUNDLE_VERSION<ul>
<li>e.g.  3sL4kqtJlcpXroDTDmJ+rmSpXd3dIbrHY+MTRCxf3vjVBH40Nr8X8gdRQBpUMLUo</li>
<li>This variable is only set if the Amazon S3 bucket has object versioning enabled.</li>
</ul>
</li>
<li>BUNDLE_ETAG<ul>
<li>The object etag for the bundle.</li>
<li>e.g. b10a8db164e0754105b7a99be72e3fe5-4</li>
</ul>
</li>
</ul>
<p>Bundle from GitHub:</p>
<ul>
<li>BUNDLE_COMMIT<ul>
<li>e.g. d2a84f4b8b650937ec8f73cd8be2c74add5a911ba64df27458ed8229da804a26).</li>
</ul>
</li>
</ul>
<p>NOTE: カスタム環境変数を渡す方法はない</p>
<h2 id="_22">ロールバック</h2>
<p>マニュアルロールバック:</p>
<ul>
<li>以前のリビジョンで新しい deployment を作成してデプロイするだけ。</li>
</ul>
<p>自動ロールバック:</p>
<ul>
<li>デプロイグループの詳細設定で設定可能。</li>
<li>いずれかのインスタンスでデプロイ失敗かアラーム (CPU 使用率 80% 以上等) が発生した場合に以前のリビジョンにデプロイしなおす。</li>
<li>アラームを使用する場合、アラームもデプロイグループに指定しておく。</li>
<li><img alt="" src="_attachment/image_582.png" /></li>
<li><a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/deployments-rollback-and-redeploy.html#deployments-rollback-and-redeploy-automatic-rollbacks">https://docs.aws.amazon.com/codedeploy/latest/userguide/deployments-rollback-and-redeploy.html#deployments-rollback-and-redeploy-automatic-rollbacks</a></li>
</ul>
<h2 id="_23">ポリシー関連</h2>
<p><img alt="" src="_attachment/image_583.png" /></p>
<h3 id="_24">サービスロール</h3>
<ul>
<li>サービスロールは<strong>デプロイグループに指定</strong>し、デプロイターゲットへのアクセスを許可する。</li>
<li>ロール作成時はスライドの通り信頼ポリシーで CodeDeploy に AssumeRole を許可し、次の AWS 管理ポリシーをロールにアタッチする。</li>
<li><strong>AWSCodeDeployRole</strong>（EC2/オンプレ用）<ul>
<li>インスタンスのタグを読み取る、または Auto Scaling グループ名で EC2 インスタンスを識別。</li>
<li>EC2 Auto Scaling グループ、ライフサイクルフック、スケーリングポリシーの読み取り・作成・更新・削除。</li>
<li>ELB の読み取り・更新。</li>
<li>CloudWatch アラームに関する情報を取得。</li>
<li>SNS トピックに情報を公開。</li>
</ul>
</li>
<li><strong>AWSCodeDeployRoleForECS</strong><ul>
<li>ECS タスクセットの読み取り・更新・削除。</li>
<li>ELB ターゲットグループ、リスナー、ルールを更新。</li>
<li>Lambda 関数の呼び出し。(Hooks)</li>
<li>S3 バケットのリビジョンファイルにアクセス。</li>
<li>CloudWatch アラームに関する情報を取得。</li>
<li>SNS トピックに情報を公開。</li>
</ul>
</li>
<li><strong>AWSCodeDeployRoleForLambda</strong><ul>
<li>Lambda 関数およびエイリアスの読み取り・更新・呼び出し。</li>
<li>S3 バケットのリビジョンファイルにアクセス。</li>
<li>CloudWatch アラームに関する情報を取得。</li>
<li>SNS トピックに情報を公開。</li>
</ul>
</li>
</ul>
<h3 id="ec2">インスタンスロール (EC2)</h3>
<ul>
<li>CodeDeploy エージェントが S3 バケットからリビジョンを取得するため s3:Get*,   s3:List* を許可。</li>
</ul>
<h2 id="eventbridge_1">EventBridge 連携</h2>
<p>ユースケース例</p>
<ul>
<li>Use a Lambda function to pass a notification to a Slack channel whenever deployments fail.</li>
<li>Push data about deployments or instances to a Kinesis stream to support comprehensive, real-time status monitoring via a dashboard.</li>
<li>Automatically stop, terminate, reboot, or recover Amazon EC2 instances when a deployment or instance event you specify occurs.</li>
<li><img alt="" src="_attachment/image_584.png" /></li>
<li><a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/monitoring-cloudwatch-events.html">https://docs.aws.amazon.com/codedeploy/latest/userguide/monitoring-cloudwatch-events.html</a></li>
</ul>
<h2 id="codedeploy_1">CodeDeploy エージェント</h2>
<ul>
<li>EC2, オンプレサーバにインストールする。</li>
<li>Amazon Linux, Ubuntu, RHEL, Windows Server 向けのバイナリがある。</li>
<li>OSS なので他の環境にも展開可能。</li>
</ul>
<p>Windows の EC2 インスタンスでエージェントをインストールする UserData の例:</p>
<pre><code>&lt;powershell&gt;
Read-S3Object -BucketName aws-codedeploy-us-west-2/latest -Key codedeploy-agent.msi -File c:\temp\codedeploy-agent.msi
Start-Sleep -s 60
Start-Process c:\temp\codedeploy-agent.msi '/qn /l**v c:\temp\host-agent-install-log.txt'
&lt;/powershell&gt;
</code></pre>
<ul>
<li>S3 から pull するためインスタンスロールに s3:Get*,   s3:List* パーミッションが必要。</li>
<li>CodeDeploy エンドポイントに HTTPS/443 でアクセスする。<ul>
<li>パブリックサブネットならインターネット経由、プライベートなら VPC エンドポイント経由。</li>
</ul>
</li>
<li>インスタンス上のインストールログを CloudWatch Logs で見るには CloudWatch エージェントを別途インストールする。</li>
</ul>
<h3 id="_25">オンプレインスタンスの登録</h3>
<p>各インスタンス毎に IAM ユーザを作成してアクセスキーを発行する方法 (小規模システム)と、 IAM ロールを STS で使う方法 (大規模システム) がある。</p>
<p>CloudDeploy エージェントの設定ファイルに認証情報を設定し、<code>aws deploy register-on-premises-instance</code> コマンドで CodeDeploy サービスに IAM ユーザまたは STS セッションの ARN を登録する。</p>
<ul>
<li>Ref. <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/on-premises-instances-register.html">https://docs.aws.amazon.com/codedeploy/latest/userguide/on-premises-instances-register.html</a></li>
</ul>
<p>IAM ユーザを使用する例:</p>
<ul>
<li>ユーザを作成して "s3:Get*",   "s3:List*" を許可する。</li>
<li>ユーザのアクセスキーを取得して CodeDeploy エージェントの設定ファイルに設定する。(エージェントがインストール済なら設定後リスタート)</li>
</ul>
<pre><code>---
aws_access_key_id: secret-key-id
aws_secret_access_key: secret-access-key
iam_user_arn: iam-user-arn
region: supported-region
</code></pre>
<pre><code>- /etc/codedeploy-agent/conf/codedeploy.onpremises.yml
- C:\\ProgramData\\Amazon\\CodeDeploy\\conf.onpremises.yml
</code></pre>
<ul>
<li>CodeDeploy エージェントをインストール。</li>
<li>CLI がインストールされた環境で register-on-premises-instance を実行してユーザを登録する。</li>
</ul>
<pre><code>aws deploy register-on-premises-instance --instance-name AssetTag12010298EX --iam-user-arn arn:aws:iam::444455556666:user/CodeDeployUser-OnPrem
</code></pre>
<ul>
<li>登録後はコンソールからオンプレインスタンスが見られるようになる。</li>
<li><img alt="" src="_attachment/image_585.png" /></li>
<li>コンソールか CLI でインスタンスにタグを設定する。</li>
<li>以降のデプロイグループへの登録等は EC2 インスタンス同様。</li>
</ul>
<hr />
<h1 id="aws-codepipeline">AWS CodePipeline</h1>
<p>CI/CDパイプラインのオーケストレーション。</p>
<p><img alt="" src="_attachment/File_15.png" /></p>
<h2 id="_26">ステージ</h2>
<ul>
<li>パイプラインの各ステージに１つ以上のアクションを追加していく。</li>
<li>管理コンソールのウィザードでは次の3ステージが作成される。<ul>
<li>ソースステージ</li>
<li>ビルドステージ (オプショナル)</li>
<li>デプロイステージ (オプショナル)</li>
</ul>
</li>
<li>少なくとも２つ以上のステージが必要。(ビルド・デプロイ両方ともスキップはできない)</li>
<li>ステージは後から追加できる。</li>
</ul>
<h3 id="_27">ソースステージ</h3>
<p><img alt="" src="_attachment/image_586.png" /></p>
<ul>
<li>入力アーティファクトが更新されると自動でパイプラインが起動される。</li>
</ul>
<p><img alt="" src="_attachment/image_587.png" />
ソース検出のルール設定</p>
<ul>
<li>AWS リソース（CodeCommit / S3 / ECR）<ul>
<li>→ EventBridge（CloudWatch Events）で自動監視・トリガ設定</li>
</ul>
</li>
<li>外部リソース（GitHub / Bitbucket）<ul>
<li>→ CodeStarSourceConnection により Webhook 監視</li>
</ul>
</li>
<li>AWS CodePipeline（Webhook/EventBridge 非対応の場合のオプション）<ul>
<li>→ パイプラインがソースを<strong>ポーリング</strong>して変更を検出</li>
</ul>
</li>
<li>複数ソース指定可<ul>
<li>→ いずれかで変更があればパイプラインが起動し、<strong>全ソースの最新リビジョンを取得</strong>して実行。</li>
</ul>
</li>
<li>Ref. Source actions and change detection methods:<ul>
<li><a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-about-starting.html#change-detection-methods">https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-about-starting.html#change-detection-methods</a></li>
</ul>
</li>
</ul>
<h3 id="_28">ビルドステージ (オプショナル)</h3>
<ul>
<li>ビルドだけでなくテストにも使われる。</li>
</ul>
<p><img alt="" src="_attachment/image_588.png" /></p>
<h3 id="_29">デプロイステージ (オプショナル)</h3>
<p><img alt="" src="_attachment/image_589.png" /></p>
<ul>
<li>CodeDeploy だけでなく各種リソースへのデプロイが統合されている<ul>
<li>CloudFormation, Beanstalk, OpsWorks 等</li>
<li>ECS, ECS(Blue/Green) は CodeDeploy 使わなくても直接統合されている</li>
</ul>
</li>
</ul>
<p>別リージョンのビルド/デプロイプロバイダーを呼び出すことも可能:</p>
<p><img alt="" src="_attachment/image_590.png" /></p>
<h2 id="_30">アクション</h2>
<p><img alt="" src="_attachment/File_16.png" /></p>
<p><strong>Approval アクション</strong>: 手動承認 → SNS</p>
<ul>
<li>SNS 連携でパイプラインのステージに承認アクションを追加できる。</li>
<li>必要な IAMアクセス権限を持つユーザによってアクションを承認または拒否するワークフローを設定。</li>
<li>Codepipeline コンソール上または SNS で通知される URL から Approve/Reject できる。(SNS サブスクライバは任意に追加可能)</li>
<li><img alt="" src="_attachment/image_591.png" /></li>
</ul>
<p><strong>Invoke アクション</strong>: Lambda で追加処理を実行</p>
<ul>
<li><code>codepipeline.putJobSuccessResult()</code> / <code>putJobFailureResult()</code> で結果を返す。<ul>
<li>continuationToken パラメーターが Job の識別 ID となる。</li>
</ul>
</li>
<li>Lambda 実行ロールでこれらのアクションを許可する必要がある:<ul>
<li>codepipeline:PutJobSuccessResult</li>
<li>codepipeline:PutJobFailureResult</li>
</ul>
</li>
</ul>
<h3 id="_31">パラレルアクションとシーケンシャルアクション</h3>
<p><img alt="" src="_attachment/image_592.png" /></p>
<p><img alt="" src="_attachment/image_593.png" /></p>
<p>パラレルアクション=アクショングループ</p>
<ul>
<li><img alt="" src="_attachment/image_594.png" /></li>
</ul>
<h2 id="_32">パイプラインのコーディング</h2>
<p>AWSコンソールを使わず、CFn テンプレートや CLI のインラインでパイプラインをコーディング。
<img alt="" src="_attachment/image_595.png" /></p>
<ul>
<li>最初のステージにソースアクションを含める必要がある 。<ul>
<li>最初のステージのみにソースアクションを設定できる。</li>
</ul>
</li>
<li>ソースアクションのステージの他に 1 つ以上のステージが必要。(=2つ以上のステージが必要)</li>
<li>パイプライン内のステージ名は一意である必要がある。</li>
<li><strong>runOrder</strong> ... シーケンスの順番。パラレルアクションは同じ runOrder になる。</li>
</ul>
<h2 id="_33">アーティファクト</h2>
<p>各ステージのアーティファクトが S3 に置かれ、次のステージに渡される。S3 バージョンも使用して作成の度にバージョニングされる。</p>
<p><img alt="" src="_attachment/image_596.png" /></p>
<ul>
<li>各アクションで Input/Output artifacts の名前を指定する。</li>
<li>クロスリージョン指定可能。</li>
<li>KMS で暗号化される。</li>
<li><img alt="" src="_attachment/image_598.png" /></li>
</ul>
<h3 id="_34">アーティファクトの暗号化</h3>
<ul>
<li>CodePipeline はアーティファクトを保管するための S3 バケットを作成し、デフォルトで S3 の AWS 管理キー (aws/s3) を作成して SSE-KMS で暗号化。</li>
<li>
<p>カスタマー管理キーの使用を推奨:</p>
<ul>
<li>カスタマー管理キーでないとキーポリシーを変更できずクロスアカウントでアーティファクトの使用ができない。</li>
<li>また、削除やローテーションの鍵管理もできない</li>
</ul>
</li>
<li>
<p><a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/S3-artifact-encryption.html">https://docs.aws.amazon.com/codepipeline/latest/userguide/S3-artifact-encryption.html</a></p>
</li>
</ul>
<h2 id="_35">クロスリージョンアクション</h2>
<p>クロスリージョンでビルドプロバイダー/デプロイプロバイダー等を呼び出すことが可能。</p>
<ul>
<li>ソースアクション、サードパーティーアクション、カスタムアクションはクロスリージョン不可。</li>
</ul>
<p>各リージョンにアーティファクトストア (S3バケット) と SSE-KMS キーが必要となる。</p>
<ul>
<li>リージョン間でのアーティファクトのコピーが行われる。</li>
</ul>
<p>クロスリージョンのサービスをデプロイする例:</p>
<p><img alt="" src="_attachment/image_599.png" /></p>
<p><a href="https://aws.amazon.com/jp/blogs/devops/using-aws-codepipeline-to-perform-multi-region-deployments/">https://aws.amazon.com/jp/blogs/devops/using-aws-codepipeline-to-perform-multi-region-deployments/</a></p>
<p><a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-create-cross-region.html">https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-create-cross-region.html</a></p>
<h2 id="_36">クロスアカウント</h2>
<p>パイプラインのある開発アカウントとデプロイ先の本番アカウントでアカウントが分かれているのが普通なので、クロスアカウントアクセスを設定する必要がある。</p>
<p><img alt="" src="_attachment/image_600.png" /></p>
<ul>
<li><a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-create-cross-account.html">https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-create-cross-account.html</a></li>
</ul>
<p>アカウント A 側リソース:</p>
<ul>
<li>アーティファクトが置かれる S3 バケット</li>
<li>ソースとデプロイステージがあるパイプライン</li>
</ul>
<p>アカウント B 側リソース:</p>
<ul>
<li>CodeDeploy アプリケーション</li>
<li>EC2 インスタンスがあるデプロイグループ</li>
</ul>
<p>アカウント A 側ステップ:</p>
<ol>
<li>アカウント B の ARN またはアカウント ID を入手。</li>
<li>パイプラインのリージョンで KMS カスタマーマネージドキーを作成し、キーの使用権限を  CodePipeline サービスロールとアカウント B に付与。キーはパイプラインアーティファクトの暗号化に使用される。</li>
<li>アカウント B に S3 バケットへのアクセスを許可する S3 バケットポリシーを作成。</li>
<li>アカウント A がアカウント B によって設定されたロールを引き受けることを許可するポリシーを作成し、そのポリシーを CodePipeline サービスロールにアタッチ。</li>
<li>デフォルトのキーではなく KMS カスタマーマネージドキーを使用するパイプラインを編集。</li>
</ol>
<p>アカウント B 側ステップ:</p>
<ol>
<li>アカウント A の ARN またはアカウント ID を入手。</li>
<li>CodeDeploy に設定された EC2 インスタンスロールに適用される、S3 バケットへのアクセスを許可するポリシーを作成。</li>
<li>CodeDeploy に設定された EC2 インスタンスロールに適用される、KMS カスタマーマネージドキーへのアクセスを許可するポリシーを作成。</li>
<li>IAM ロールを設定し、そのロールにアカウント A がロールを引き受けることを許可する信頼ポリシーをアタッチ。（CodePipline が Assume して使うクロスアカウントロール）</li>
<li>パイプラインで必要な CodeDeploy リソースへのアクセスを許可するポリシーを作成し、上記の IAM ロールにアタッチ。</li>
<li>S3 バケットへのアクセスを許可するポリシーを作成し、上記の IAM ロールにアタッチ。（CodePipline がクロスアカウントロールで CodeDeploy のデプロイ命令を実行する際にも A 側の S3 バケットへのアクセスが必要となるため）</li>
</ol>
<p>パイプラインの編集</p>
<ul>
<li>AWS CLI を使用して作業する<ul>
<li>おそらくクロスアカウントの Deploy プロバイダの設定が管理コンソールで出来ないため。</li>
</ul>
</li>
<li>パイプラインを JSON で取得する</li>
</ul>
<pre><code>aws codepipeline get-pipeline --name MyFirstPipeline &gt;pipeline.json
</code></pre>
<ul>
<li>KMS キーをパイプラインの artifactStore に指定する</li>
</ul>
<pre><code>{
  &quot;artifactStore&quot;: {
    &quot;location&quot;: &quot;codepipeline-us-east-1-1234567890&quot;,
    &quot;type&quot;: &quot;S3&quot;,
    &quot;encryptionKey&quot;: {
      &quot;id&quot;: &quot;arn:aws:kms:us-east-1:012ID_ACCOUNT_A:key/2222222-3333333-4444-556677EXAMPLE&quot;,
      &quot;type&quot;: &quot;KMS&quot;
    }
  }
}
</code></pre>
<ul>
<li>クロスアカウントロールの ARN を指定したデプロイアクションを含むステージを追加</li>
</ul>
<pre><code>            {
                &quot;name&quot;: &quot;Staging&quot;,
                &quot;actions&quot;: [
                    {
                        &quot;inputArtifacts&quot;: [
                            {
                                &quot;name&quot;: &quot;MyAppBuild&quot;
                            }
                        ],
                        &quot;name&quot;: &quot;ExternalDeploy&quot;,
                        &quot;actionTypeId&quot;: {
                            &quot;category&quot;: &quot;Deploy&quot;,
                            &quot;owner&quot;: &quot;AWS&quot;,
                            &quot;version&quot;: &quot;1&quot;,
                            &quot;provider&quot;: &quot;CodeDeploy&quot;
                        },
                        &quot;outputArtifacts&quot;: [],
                        &quot;configuration&quot;: {
                            &quot;ApplicationName&quot;: &quot;AccountBApplicationName&quot;,
                            &quot;DeploymentGroupName&quot;: &quot;AccountBApplicationGroupName&quot;
                        },
                        &quot;runOrder&quot;: 1,
                        &quot;roleArn&quot;: &quot;arn:aws:iam::012ID_ACCOUNT_B:role/CrossAccount_Role&quot;
                    }
                ]
            }
</code></pre>
<ul>
<li>編集された JSON ファイルを保存してパイプライン更新コマンドを実行</li>
</ul>
<p>Ref. クロスアカウントロール</p>
<ul>
<li><img alt="" src="_attachment/File.jpeg" /></li>
</ul>
<h2 id="_37">ラボで使用したパイプラインの例</h2>
<p><img alt="" src="_attachment/image_601.png" /></p>
<p>Source ステージ</p>
<ul>
<li>CodeCommit</li>
</ul>
<p>Static_Check ステージ</p>
<ul>
<li>Lambda アクション</li>
<li>CloudFormation テンプレートの Security Group をチェックする</li>
</ul>
<p>Build ステージ</p>
<ul>
<li>CodeBuild アクション</li>
<li>ラボでは post_build のユニットテストの Fail を CodeBuild のログで確認した。</li>
</ul>
<p>Test_Stack ステージ</p>
<ul>
<li>GenerateChangeSet: CloudFormation アクション</li>
<li>DeployChangeSet: CloudFormation アクション</li>
<li>Doploy: CodeDeploy アクション</li>
</ul>
<p>ServiceStatus ステージ</p>
<ul>
<li>Lambda アクション</li>
<li>動的確認として Test_Stack でデプロイされたアプリケーションへの疎通確認をする</li>
</ul>
<p>Approval ステージ</p>
<ul>
<li>Approval アクション</li>
<li>DeleteTestStack: CloudFormation アクション</li>
</ul>
<p>Prod_Stack ステージ</p>
<ul>
<li>Test_Stack ステージ 同様</li>
</ul>
<p><img alt="" src="_attachment/image_602.png" /></p>
<p>ユースケース例</p>
<p><a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/best-practices.html#use-cases">https://docs.aws.amazon.com/codepipeline/latest/userguide/best-practices.html#use-cases</a></p>
<h2 id="eventbridge_2">EventBridge 連携</h2>
<p>CodePipeline をイベントソースにターゲットの Lambda 等と連携。</p>
<p>単にパイプライン中に Lambda 呼びたければ Invoke アクションがあるので、FAIL などのイベント発生時にトリガーする際にこちらを使う。</p>
<p><img alt="" src="_attachment/image_603.png" /></p>
<ul>
<li>CodePipeline Pipeline Execution State Change</li>
<li>CodePipeline Stage Execution State Change</li>
<li>CodePipeline Action Execution State Change</li>
<li>それぞれ、SUCCEEDED, FAILED, STOPPING, STOPPED, RESUMED, CANCELED などの状態がある。</li>
<li>Approve action の reject は FAILED になる。</li>
<li>Ref. <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/detect-state-changes-cloudwatch-events.html#detect-state-events-types">https://docs.aws.amazon.com/codepipeline/latest/userguide/detect-state-changes-cloudwatch-events.html#detect-state-events-types</a></li>
</ul>
<hr />
<h1 id="aws-codestar">AWS CodeStar</h1>
<p>概要</p>
<ul>
<li>Code サービスによる CI/CD パイプラインをアプリのテンプレートから簡単に作成できる。</li>
<li>リポジトリ: CodeCommit / GitHub</li>
<li>デプロイターゲット: <strong>EC2 / Lambda / Beanstalk</strong></li>
<li>パイプライン: CodePipeline</li>
<li>ビルドプロジェクト: CodeBuild </li>
<li>デプロイツール: CodeDeploy, CloudFormation, Beanstalk</li>
<li>CloudWatch メトリクス</li>
<li>プロジェクト管理ダッシュボード<ul>
<li>Atlassian JIRA による管理ダッシュボードが用意される。</li>
<li>チームのバックログからコードデプロイまで、開発プロセスの進行状況をトラッキングできる。</li>
</ul>
</li>
</ul>
<p>プロジェクトテンプレート</p>
<ul>
<li>デプロイターゲットごとに色々なテンプレートが用意されている。</li>
</ul>
<p><img alt="" src="_attachment/File_17.png" /></p>
<p>プロジェクトコードがリポジトリにコミットされる:</p>
<p><img alt="" src="_attachment/image_604.png" /></p>
<p>Cloud9 やその他の IDE でリポジトリからコードを clone して開発:</p>
<p><img alt="" src="_attachment/image_605.png" /></p>
<p>template.yml</p>
<ul>
<li>CodeStar プロジェクトテンプレートは CloudFormation テンプレートの CodeStar 拡張で定義されている。</li>
</ul>
<pre><code>AWSTemplateFormatVersion: 2010-09-09
Transform:
- AWS::Serverless-2016-10-31
- AWS::CodeStar

Parameters:
  ProjectId:
    Type: String
    Description: CodeStar projectId used to associate new resources to team members
  CodeDeployRole:
    Type: String
    Description: IAM role to allow AWS CodeDeploy to manage deployment of AWS Lambda functions
  Stage:
    Type: String
    Description: The name for a project pipeline stage, such as Staging or Prod, for which resources are provisioned and deployed.
    Default: ''

Globals:
  Function:
    AutoPublishAlias: live
    DeploymentPreference:
      Enabled: true
      Type: Canary10Percent5Minutes
      Role: !Ref CodeDeployRole

Resources:
  HelloWorld:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub 'awscodestar-${ProjectId}-lambda-HelloWorld'
      Handler: index.handler
      Runtime: python3.7
      Role:
        Fn::GetAtt:
        - LambdaExecutionRole
        - Arn
      Events:
        GetEvent:
          Type: Api
          Properties:
            Path: /
            Method: get
        PostEvent:
          Type: Api
          Properties:
            Path: /
            Method: post
  LambdaExecutionRole:
    Description: Creating service role in IAM for AWS Lambda
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'CodeStar-${ProjectId}-Execution${Stage}'
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [lambda.amazonaws.com]
          Action: sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      PermissionsBoundary: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/CodeStar_${ProjectId}_PermissionsBoundary'
</code></pre>
<ul>
<li><a href="https://docs.aws.amazon.com/ja_jp/codestar/latest/userguide/templates.html">https://docs.aws.amazon.com/ja_jp/codestar/latest/userguide/templates.html</a></li>
</ul>
<hr />
<h1 id="jenkins">Jenkins</h1>
<p>ユースケース:</p>
<ul>
<li>CodePipeline からの Jenkins プロバイダーの呼び出し。</li>
<li>Jenkins から ECR/ECS, Lambda へのデプロイ等。</li>
</ul>
<p><img alt="" src="_attachment/image_606.png" /></p>
<ul>
<li>Worker (=Slave) は Master と同一インスタンスにも別インスタンスにも配置できる。</li>
<li>マルチマスターも可能。(マスターの Multi-AZ 配置など)</li>
</ul>
<p><img alt="" src="_attachment/image_607.png" /></p>
<h3 id="amazon-ec2">Amazon EC2 プラグイン</h3>
<ul>
<li>Jenkins CI サーバー（ワーカーノード）の自動スケーリング。</li>
<li>Jenkins プライマリの Amazon EC2 プラグインが EC2 API で負荷に応じて自動的にワーカーノードを作成・削除する。</li>
</ul>
<p><img alt="" src="_attachment/image_608.png" /></p>
<ul>
<li>プライマリの Amazon EC2 プラグインにより、新しい EC2 インスタンスを自動的に作成して Jenkins エージェントとして接続する</li>
<li>過負荷になると、Jenkins プライマリによって、ビルドがエージェントにオフロードされる。</li>
<li>負荷が低下すると、Jenkins プライマリにより余分なワーカーノードが自動的に終了される。</li>
<li>同様に ECS でエージェントを起動するプラグインもある。</li>
</ul>
<h3 id="aws-codebuild_1">AWS CodeBuild プラグイン</h3>
<ul>
<li>Jenkins ビルドタスクを CodeBuild に投げて実行させられる。</li>
<li>CloudWatch Logs によりビルドログ保存。S3 にアーティファクト保存。</li>
</ul>
<p><img alt="" src="_attachment/image_609.png" /></p>
<p>その他のプラグイン</p>
<ul>
<li>AWS CodePipeline ... CodePipline のアクションプロバイダ統合で必要。</li>
<li>S3 publisher</li>
<li>Artifact Manager on S3</li>
</ul>
<hr />
<h1 id="cicd_1">CI/CDに関する概念・用語</h1>
<p>以下は、あなたの提供したスライド画像とテキスト内容をもとに再構成した
<strong>「CI/CD に関する概念・用語」章の整理済みノート（Markdown形式）</strong> です。
元ノートの簡潔・要点重視の文体に合わせています。</p>
<hr />
<h2 id="cicd_2">CI/CD に関する概念・用語</h2>
<h3 id="cicd_3">CI/CD パイプラインでのテストシナリオ</h3>
<p><strong>継続的インテグレーション（CI）</strong></p>
<ul>
<li>開発段階<ul>
<li>単体テスト</li>
<li>静的コード解析</li>
</ul>
</li>
<li>ビルド段階<ul>
<li>統合テスト</li>
<li>コンポーネントテスト</li>
<li>回帰テスト</li>
</ul>
</li>
</ul>
<p><strong>継続的デリバリー／デプロイ（CD）</strong></p>
<ul>
<li>ステージ環境<ul>
<li>システムテスト</li>
<li>パフォーマンステスト</li>
<li>負荷テスト</li>
<li>コンプライアンステスト</li>
<li>UAT (User Acceptance Test)</li>
</ul>
</li>
<li>本番環境<ul>
<li>A/B テスト</li>
<li>Canary 分析</li>
</ul>
</li>
</ul>
<h3 id="_38">テストに関する用語</h3>
<ul>
<li>
<p>単体テスト
    最小ユニットの個別テスト。</p>
</li>
<li>
<p>統合テスト
    結合されたユニットやモジュール間の相互関係をテスト。</p>
</li>
<li>
<p>耐障害性テスト
    システムがコンポーネント障害に対してどのように動作するかを確認。</p>
</li>
<li>
<p>負荷テスト
    高負荷状態での性能確認。</p>
</li>
<li>
<p><strong>合成テスト</strong>
    ユーザーエクスペリエンス全体を確認。</p>
</li>
<li>
<p>UAT（User Acceptance Test）
    ユーザー視点で受け入れ基準を満たすか検証。</p>
</li>
<li>
<p>Mock サーバ
    HTTP API コールを模擬して動作確認を行う。
    API Gateway の Mock 統合で実装可能。</p>
</li>
<li>
<p>A/B テスト
    2つ以上の機能バージョンを異なるユーザーに提供し、メトリクスを比較。
    Route 53 の加重ラウンドロビンで実現可能。</p>
</li>
</ul>
<h4 id="_39">統合テストの手法</h4>
<ul>
<li>ビッグバン方式：すべてのモジュールを同時に統合してテスト。</li>
<li>トップダウン方式：上位（GUIなど）から下位に向けて統合テスト。</li>
<li>ボトムアップ方式：制御フローの下層から上層へと積み上げテスト。</li>
</ul>
<h4 id="_40">耐障害性テスト</h4>
<ul>
<li>高可用性（HA）構成が期待通りに機能するか確認。</li>
<li>例：プライマリインスタンスを意図的に停止させるテスト。</li>
</ul>
<p><strong>AWS Fault Injection Simulator (FIS)</strong></p>
<ul>
<li>スポットインスタンスの中断</li>
<li>ネットワーク遅延や障害の注入</li>
<li>サービスの耐障害性確認</li>
<li><a href="https://aws.amazon.com/jp/fis/">https://aws.amazon.com/jp/fis/</a></li>
</ul>
<h3 id="codepipeline_1">CodePipeline のテストアクションプロバイダー統合</h3>
<ul>
<li>AWS CodeBuild</li>
<li>AWS Device Farm</li>
<li>BlazeMeter</li>
<li>Ghost Inspector</li>
<li>Micro Focus StormRunner Load</li>
<li>Nouvola</li>
<li>Runscope</li>
</ul>
<p>Device Farm</p>
<ul>
<li>実際の Android / iOS / Web アプリを物理デバイス上でテスト。</li>
</ul>
<p>BlazeMeter</p>
<ul>
<li>JMeter のマネージドサービス。負荷・性能を自動検証。</li>
<li>JMeter スクリプトを利用した負荷テスト、ストレステスト、パフォーマンステストの実施。</li>
<li>平均レイテンシや応答時間の可視化</li>
<li>CodePipeline のテストアクションプロバイダーとして利用可能。</li>
</ul>
</article>

    </main>
    <footer>
        <p>&copy; 2025 AWS DevOps Notes</p>
    </footer>
    <script src="static/script.js"></script>
</body>
</html>