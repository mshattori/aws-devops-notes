<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AWS - DevOps - Overview - AWS DevOps Notes</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    
    <header>
        <h1>AWS - DevOps - Overview</h1>
    </header>
    
    <main>
        
<article>
    <p>Ref.  <a href="References/AWS%20-%20Security%20-%20Overview.html">AWS - Security - Overview</a>
- 時間: 75問/180分 → 1問2分20秒
- 10分: 4問+
- 10問: 23分+
- 1時間: 25問</p>
<table>
<thead>
<tr>
<th>分野</th>
<th>タイトル</th>
<th>重み</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1分野</td>
<td>SDLC のオートメーション</td>
<td>22%</td>
</tr>
<tr>
<td>第2分野</td>
<td>設定管理と IaC</td>
<td>17%</td>
</tr>
<tr>
<td>第3分野</td>
<td>耐障害性の高いクラウドソリューション</td>
<td>15%</td>
</tr>
<tr>
<td>第4分野</td>
<td>モニタリングとロギング</td>
<td>15%</td>
</tr>
<tr>
<td>第5分野</td>
<td>インシデントとイベントへの対応</td>
<td>14%</td>
</tr>
<tr>
<td>第6分野</td>
<td>セキュリティとコンプライアンス</td>
<td>17%</td>
</tr>
</tbody>
</table>
<p><img alt="" src="_attachment/image_631.png" /></p>
<h2 id="_1">モダンアプリケーションアーキテクチャ</h2>
<p><img alt="" src="_attachment/image_632.png" />
<img alt="" src="_attachment/image_633.png" />
<img alt="" src="_attachment/image_634.png" /></p>
<ul>
<li>CloudMap コンテナのサービス間のルーティング</li>
<li>App Mesh サービスメッシュによるコンテナの連携のマネージドサービス</li>
</ul>
<hr />
<h1 id="aws">AWS サービスのスコープ分類</h1>
<h2 id="1-vpcvpc-scoped-services">1. VPC内リソース（VPC-scoped services）</h2>
<p>ネットワーク的に VPC 内に存在し、AZ（サブネット）に紐づき、専用の ENI を持つリソース。</p>
<table>
<thead>
<tr>
<th>サービス</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>EC2</strong></td>
<td>サブネット単位で配置。ENI を持つ。</td>
</tr>
<tr>
<td><strong>RDS</strong></td>
<td>マルチAZも含めてサブネットに配置される。</td>
</tr>
<tr>
<td><strong>ECS (EC2モード)</strong></td>
<td>EC2 が VPC 内に配置される。</td>
</tr>
<tr>
<td><strong>EKS ワーカー/Pod（ENI割当）</strong></td>
<td>Pod もENIを持ち VPCに属する場合もある。</td>
</tr>
<tr>
<td><strong>ElasticCache（Redis / Memcached）</strong></td>
<td>サブネットに紐づく。</td>
</tr>
<tr>
<td><strong>Redshift</strong></td>
<td>クラスタは VPC 内に配置。</td>
</tr>
<tr>
<td><strong>EFS</strong></td>
<td>VPC 内のNFS共有ストレージ。EC2/ECS/EKSからマウント可能</td>
</tr>
<tr>
<td><strong>OpenSearch</strong></td>
<td>VPC内に配置。</td>
</tr>
</tbody>
</table>
<h2 id="2-region-scoped-services">2. リージョン・スコープ （Region-scoped services）</h2>
<p>物理的な配置の概念はなく、AWSのコントロールプレーンサービスとしてリージョン単位で提供される。VPCと独立している。</p>
<table>
<thead>
<tr>
<th>サービス</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>S3</strong></td>
<td>バケットはリージョンに存在。</td>
</tr>
<tr>
<td><strong>Lambda</strong></td>
<td>AWS管理VPCで実行。</td>
</tr>
<tr>
<td><strong>CloudWatch</strong></td>
<td>リージョンごとにメトリクス保存。</td>
</tr>
<tr>
<td><strong>CloudTrail</strong></td>
<td>リージョン単位（＋Globalサービスイベント）。</td>
</tr>
<tr>
<td><strong>EventBridge</strong></td>
<td>イベントバスはリージョン単位。</td>
</tr>
<tr>
<td><strong>KMS</strong></td>
<td>CMK はリージョン固有。</td>
</tr>
<tr>
<td><strong>Secrets Manager</strong></td>
<td>シークレットはリージョン単位。</td>
</tr>
<tr>
<td><strong>SSM Parameter Store</strong></td>
<td>パラメータはリージョン単位。</td>
</tr>
<tr>
<td><strong>SNS / SQS</strong></td>
<td>キュー・トピックはリージョン単位。</td>
</tr>
<tr>
<td><strong>Step Functions</strong></td>
<td>ステートマシンはリージョン単位。</td>
</tr>
<tr>
<td><strong>Glue</strong></td>
<td>リージョン単位でデータカタログ管理。</td>
</tr>
</tbody>
</table>
<ul>
<li>ELB はリージョン・スコープだが、ターゲットは VPC 内リソース<ul>
<li>マルチ AZ にまたがる構造</li>
<li>VPC 非接続 Lambda もターゲットにできる</li>
</ul>
</li>
</ul>
<h2 id="3">3. <strong>グローバルサービス（リージョンを超えるサービス）</strong></h2>
<table>
<thead>
<tr>
<th>サービス</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Route 53</strong></td>
<td>DNSは完全にグローバル。</td>
</tr>
<tr>
<td><strong>CloudFront</strong></td>
<td>CDNグローバル。</td>
</tr>
<tr>
<td><strong>IAM（実質グローバル）</strong></td>
<td>“IAMはグローバルサービス”と明記される。</td>
</tr>
<tr>
<td><strong>WAF（グローバル / リージョン両方）</strong></td>
<td>CloudFront向けはグローバル。</td>
</tr>
<tr>
<td><strong>AWS Global Accelerator</strong></td>
<td>グローバルIPを提供。</td>
</tr>
<tr>
<td><strong>Organizations</strong></td>
<td>組織全体で管理。</td>
</tr>
<tr>
<td><strong>Control Tower</strong></td>
<td>マルチリージョン/複数アカウントを一元管理。</td>
</tr>
</tbody>
</table>
<ul>
<li>IAM は内部的なリージョンレプリケーションで実質グローバルサービス</li>
</ul>
<h1 id="4">4. リージョンを跨いでデータ/エンドポイントが存在する特殊タイプ</h1>
<table>
<thead>
<tr>
<th>サービス</th>
<th>補足</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>S3</strong></td>
<td>API・ネームスペースはグローバル。</td>
</tr>
<tr>
<td><strong>DynamoDB Global Tables</strong></td>
<td>複数リージョンで同期。</td>
</tr>
<tr>
<td><strong>Aurora Global Database</strong></td>
<td>リーダー領域が複数リージョンで構成される。</td>
</tr>
<tr>
<td><strong>EFS One Zone / Standard</strong></td>
<td>データはAZだがアクセス可能性はリージョン。</td>
</tr>
<tr>
<td><strong>CloudWatch Logs Cross-region</strong></td>
<td>実質リージョンごとのストレージ＋一部グローバル統合。</td>
</tr>
</tbody>
</table>
<ul>
<li>S3 はグローバルエンドポイント <code>s3.amazonaws.com</code> と <code>s3.ap-northeast-1.amazonaws.com</code> のようなリージョンエンドポイントがある。(グローバルエンドポイントは現在は非推奨)</li>
</ul>
<hr />
<h1 id="iam">IAM ロール関連</h1>
<ul>
<li>
<p>CodeBuild - サービスロール:</p>
<ul>
<li>CodeBuildサービスが各種AWSサービス（例：CodeCommitからのソース取得、S3へのアーティファクト保存、ECRへのプッシュ）にアクセスするために必要。</li>
<li>認証情報は環境変数を介してビルドサーバーのコンテナ環境に引き継ぎ。</li>
</ul>
</li>
<li>
<p>CodeDeploy - サービスロール:</p>
<ul>
<li>デプロイグループに指定し、デプロイターゲットのサービス等へのアクセスを許可。</li>
<li>AWSCodeDeployRole, AWSCodeDeployRoleForECS, AWSCodeDeployRoleForLambda など。</li>
</ul>
</li>
<li>
<p>CodeDeploy - インスタンスロール:</p>
<ul>
<li>CodeDeployエージェントがS3からリビジョンをpullするための、EC2インスタンスロールへの s3:Get<em>, s3:List</em> パーミッションの付与が必要。</li>
<li>CloudWatchエージェントでインストールログを CloudWatch Logs に送る場合もパーミッションが必要。</li>
</ul>
</li>
<li>
<p>CodeDeploy - オンプレミスインスタンス用のIAMロール:</p>
<ul>
<li>オンプレミスインスタンスが使用する、CodeDeployアクセス許可を持つIAMロールの作成。</li>
<li>オンプレミスインスタンス上で sts assume-role を使用した一時的な認証情報の取得。</li>
</ul>
</li>
<li>
<p>CodePipeline - クロスアカウントロール:</p>
<ul>
<li>開発アカウントのパイプラインから本番アカウントへデプロイを実行できるよう、クロスアカウントロールを作成し、パイ
    プラインのサービスロールに設定。</li>
<li>ロールの信頼ポリシーでリモートアカウントからの AssumeRole を許可。</li>
</ul>
</li>
<li>
<p>Elastic Beanstalk - IAMロール:</p>
<ul>
<li>環境構築時に自動的にプロビジョニングされるリソースの一つ。</li>
</ul>
</li>
<li>
<p>ECS - タスク実行ロール (executionRoleArn):</p>
<ul>
<li>コンテナランタイムが使用するロールで、コンテナイメージのプル、CloudWatch Logsへのログ書き込み、Secrets
    Manager/Systems Managerへのアクセス許可などに必要。</li>
</ul>
</li>
<li>
<p>ECS - タスクロール (taskRoleArn):</p>
<ul>
<li>コンテナ内のアプリケーションに割り当てるロール。</li>
<li>"ecs-tasks.amazonaws.com" に AssumeRole を許可する信頼ポリシーを持つ必要あり。</li>
</ul>
</li>
<li>
<p>ECS - コンテナインスタンスロール:</p>
<ul>
<li>ECSクラスターのEC2インスタンスのインスタンスロール。</li>
<li>ECS API系だけでなく、ECRの ecr::GetAuthorizationToken 権限も指定。</li>
</ul>
</li>
<li>
<p>Lambda - 実行ロール:</p>
<ul>
<li>Lambda関数がイベントソース（例: DynamoDB Streams）を読み込む権限など、AWSサービスへアクセスするために必要。</li>
</ul>
</li>
<li>
<p>CloudFormation - IAMリソース作成時のCapability:</p>
<ul>
<li>IAMリソース（ロールなど）を作成するテンプレートには CAPABILITY_IAM または CAPABILITY_NAMED_IAM の指定が必要。</li>
</ul>
</li>
<li>
<p>CloudFormation スタックセット - IAMロール:</p>
<ul>
<li>全アカウントに共通のIAMロールを配布するなどの用途で利用。</li>
</ul>
</li>
<li>
<p>Service Catalog - 起動制約 (Launch Constraint):</p>
<ul>
<li>エンドユーザーが製品（CloudFormationテンプレート）を起動する際に使用するロールの指定。</li>
</ul>
</li>
<li>
<p>Cognito ID プール - IAMロールのマッピング:</p>
<ul>
<li>外部IdPのユーザートークンのクレームに基づき、特定のIAMロールにマッピングするためのルールを設定。</li>
<li>ルールに合致しない未認証ID（ゲスト）用のロールも設定可能。</li>
</ul>
</li>
<li>
<p>STS (Security Token Service):</p>
<ul>
<li>AssumeRoleWithSAML: SAML 2.0対応IdPからの認証情報でロールを引き受け。</li>
<li>AssumeRoleWithWebIdentity: OIDC互換IdPからの認証情報でロールを引き受け。</li>
</ul>
</li>
<li>
<p>AWS SSO と AD連携:</p>
<ul>
<li>ADFS（Active Directory Federation Services）をIdPとして使い、ADユーザーがロールを引き受けるために使用。</li>
<li>AWS管理コンソールへのSSOでは、AssumeRoleWithSAML を許可するロールを関連付け。</li>
</ul>
</li>
<li>
<p>IAM Access Analyzer:</p>
<ul>
<li>リソースベースのポリシーを分析し、外部プリンシパルと共有されているIAMロールなどを検出。</li>
</ul>
</li>
<li>
<p>Organizations - SCP (Service Control Policy):</p>
<ul>
<li>メンバーアカウントのルートユーザーの権限を制限可能。</li>
<li>例として、本番OUにデプロイ操作をDenyしつつ、パイプラインが使用するロールのみを許可する、といったガードレールの
    適用。</li>
</ul>
</li>
</ul>
<hr />
<h1 id="cicd">CI/CD</h1>
<p><a href="AWS%20-%20CICD.html">AWS - CICD</a></p>
<p>Continuous Delivery vs Continuous Deployment (デプロイまで自動化)</p>
<h1 id="codecommit">CodeCommit</h1>
<p>認証情報は IAM コンソールで登録</p>
<ul>
<li>SSH: キーペアを作り IAM ユーザに公開鍵を登録。</li>
<li>HTTPS: IAM ユーザの Git 認証情報 (ユーザ名/パスワード) を生成する。</li>
</ul>
<p>認証情報ヘルパー</p>
<ul>
<li>git コマンドの認証情報ヘルパーで aws-cli 経由でユーザの認証情報を取得。</li>
</ul>
<p>KMS で保存コードをデフォルトで暗号化。</p>
<p>IAM ポリシーでリポジトリへのアクセス制御。(なお、リポジトリのリソースベースポリシーはない)</p>
<p>プルリクエストをコンソールまたは CLI で作成。</p>
<p>リポジトリトリガー (Trigger)</p>
<ul>
<li>コード Push などのリポジトリイベントで SNS, Lambda をトリガー。</li>
<li>GitHub のフックにあたるもの。</li>
</ul>
<p>通知ルール (Notification)</p>
<ul>
<li>SNS か AWS Chatbot に通知を投げる。主にプルリク系とブランチ系の通知。</li>
<li><img alt="" src="_attachment/image_635.png" /></li>
<li>Code シリーズ共通に存在する機能。</li>
</ul>
<p>CodeBuild/CodePipeline 連携</p>
<ul>
<li>EventBridge ルールを作成してイベントソースを CodeCommit にする。</li>
<li>ターゲットを CodeBuild プロジェクトや CodePipeline パイプラインの ARN とする。</li>
</ul>
<p>CloudTrail 連携</p>
<ul>
<li>CodeCommit API コールをキャプチャして証跡として S3 バケットに保存</li>
</ul>
<p>管理ポリシー</p>
<ul>
<li>AWSCodeCommitFullAccess<ul>
<li>Grants full access to CodeCommit.</li>
</ul>
</li>
<li>AWSCodeCommitPowerUser<ul>
<li>Allows users access to all of the functionality of CodeCommit and repository-related resources</li>
<li>Except it does not allow them to delete CodeCommit repositories or create or delete repository-related resources in other AWS services, such as CloudWatch Events.</li>
</ul>
</li>
<li>AWSCodeCommitReadOnly<ul>
<li>Grants read-only access to CodeCommit and repository-related resources in other AWS services, as well as the ability to create and manage their own CodeCommit-related resources (such as Git credentials and SSH keys for their IAM user to use when accessing repositories).</li>
</ul>
</li>
<li>開発ユーザ全員に AWSCodeCommitPowerUser を与え、Lead 以外は master ブランチへの Push や Merge を明示的 Deny する、という問題例がよく出る。</li>
</ul>
<h1 id="codebuild">CodeBuild</h1>
<p>環境を Docker イメージで立ち上げ、ビルドとテストに使用。</p>
<p>ソースプロバイダー</p>
<ul>
<li>S3, CodeCommit, GitHub, GitHub Enterprise, Bitbucket</li>
</ul>
<p>アーティファクト</p>
<ul>
<li>S3 バケットにアップロード。デフォルトで S3-KMS 暗号化。</li>
</ul>
<p>ビルドコマンド</p>
<ul>
<li>buildspec.yml に記述。</li>
</ul>
<p>タイムアウト</p>
<ul>
<li>最長8時間まで。(さらに長時間のテストは Step Functions の Activity 等を使う)</li>
<li>Lambda で出来ない時間のかかるパフォーマンステスト等を実施できる。</li>
</ul>
<p>VPC</p>
<ul>
<li>環境からの VPC アクセスのオプション指定。</li>
</ul>
<p>環境変数</p>
<ul>
<li>環境変数の設定。SSM パラメータストアからの取得も可能。</li>
</ul>
<p>ログ</p>
<ul>
<li>オプショナルで CloudWatch Logs と S3 バケットにログを保存。</li>
</ul>
<p>ビルドキャッシュ</p>
<ul>
<li>ビルドツールや依存モジュールのダウンロードやビルド時間を短縮できる。</li>
<li>キャッシュタイプ<ul>
<li>S3<ul>
<li>サイズが大きくなくビルドに時間がかかるモジュールに向く。</li>
</ul>
</li>
<li>ローカル<ul>
<li>ダウンロードに時間がかかるような大きなファイルに向く。</li>
<li>ビルドホストにマウントされるインスタンスストレージでのキャッシュ。<ul>
<li>DockerLayerCache ... コンテナイメージのビルドのためのキャッシュ</li>
<li>SourceCache ... .git メタデータのキャッシュ</li>
<li>CustomCache ... buildspec.yaml で指定するキャッシュ</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>buildspec.yml</p>
<ul>
<li>install フェーズ<ul>
<li>runtime-versions でビルドランタイムのインストール指定。</li>
<li>dotnet, java, golang, php, nodejs, python, ruby をサポート。</li>
</ul>
</li>
<li>pre_build, build, post_build フェーズ<ul>
<li>command ブロックで コマンド実行。</li>
</ul>
</li>
<li>run-as<ul>
<li>全体および各フェーズで実行ユーザ指定可能。</li>
</ul>
</li>
<li>finally ブロック<ul>
<li>各セクションに指定。command ブロックでエラーがあっても必ず実行される。</li>
</ul>
</li>
<li>artifact セクション<ul>
<li>artifact として S3 に保存するファイルを指定。</li>
</ul>
</li>
<li>env セクション<ul>
<li>環境変数設定。パラメータストアからも簡単に取得できる。</li>
</ul>
</li>
</ul>
<p>サービスロール</p>
<ul>
<li>CodeBuild サービスが各種サービスにアクセスするのに必要なロール。</li>
<li>CodeCommit からのソース取得, S3 へのアーティファクト保存, ECR へのプッシュ等</li>
<li>ビルドサーバのコンテナ環境にもサービスロール権限が引き継がれる (クリデンシャルが環境変数経由で渡される)</li>
</ul>
<p>IAM ポリシー</p>
<ul>
<li>ビルドプロジェクトへのアクセス制御</li>
<li>AWSCodeBuildAdminAccess, AWSCodeBuildDeveloperAccess, AWSCodeBuildReadOnlyAccess 等</li>
</ul>
<p>CodePipeline 連携</p>
<ul>
<li>Build または Test アクションに設定可能</li>
</ul>
<p>EventBridge 連携</p>
<ul>
<li>例: CodeCommit をイベントソース、CodeBuild プロジェクトをターゲットにして、PR 契機に自動ビルドを実施</li>
</ul>
<p>BuildArtifacts API</p>
<ul>
<li>ビルドアーティファクトの SHA256 ハッシュをとってパイプライン内でアーティファクトをチェックするという問題があった</li>
</ul>
<h1 id="codedeploy">CodeDeploy</h1>
<p>デプロイ先</p>
<ul>
<li>EC2/オンプレサーバ (要 CodeDeploy エージェント, Windows, Linux をサポート)</li>
<li>ECS (Fargate)</li>
<li>Lambda</li>
</ul>
<p>CodeDeploy アプリケーション</p>
<ul>
<li>設定の単位。</li>
</ul>
<p>リビジョン (EC2/オンプレのみ)</p>
<ul>
<li>S3, GitHub のいずれか。</li>
<li>S3 の場合はデプロイ先 EC2 インスタンスロールで CodeDeploy エージェントに S3 へのアクセス権限の付与が必要。</li>
<li>ECS はタスク定義の familiy+revision, Lambda はバージョンを更新する。</li>
</ul>
<p>デプロイグループ (EC2/オンプレのみ)</p>
<ul>
<li>タググループか EC2 ASG を指定。</li>
</ul>
<p>デプロイタイプ</p>
<ul>
<li>EC2: インプレースデプロイ, Blue/Green デプロイ<ul>
<li>ASG の Blue/Green では ASG 全体の置き換えによるデプロイメントも選択可能。</li>
<li>Blue/Green ではトラフィックのルーティングをコントロールする ELB の指定が必須。</li>
</ul>
</li>
<li>オンプレ: インプレースのみ</li>
<li>ECS, Lambda:  Blue/Green のみ<ul>
<li>ECS: サービスにタスクセットと ELB ターゲットグループを作成して加重ターゲットグループ</li>
<li>Lambda: 指定バージョン間で加重エイリアス</li>
</ul>
</li>
</ul>
<p>デプロイ設定</p>
<ul>
<li>EC2<ul>
<li>AllAtOnce, HalfAtATime, OneAtATime, Custom (=min. health hosts)</li>
</ul>
</li>
<li>Lambda:<ul>
<li>AllAtOnce, CanaryNPercentEveryNMinutes, LinearNPercentEveryNMinutes</li>
</ul>
</li>
<li>ECS:<ul>
<li>AllAtOnce, CanaryNPercentEveryNMinutes, LinearNPercentEveryNMinutes</li>
</ul>
</li>
</ul>
<p>トリガー</p>
<ul>
<li>DevpoymentStart, DeploymentSuccess, DeploymentFailure などのイベントを SNS 通知。</li>
</ul>
<p>AppSpec ファイル (appspec.yml/.json)</p>
<ul>
<li>デプロイ処理の具体的な定義。リビジョンの root ディレクトリに配置。</li>
<li>CodeDeploy エージェントによって実行される。</li>
<li>ECS ではコンテナイメージが別途コンテナディレクトリに登録される必要があるので、AppSpec はコードと一緒に置かず S3 にファイル単体を置いても良い。</li>
<li>files セクション<ul>
<li>source, destination</li>
</ul>
</li>
<li>resources セクション<ul>
<li>Lambda: Name, Alias, CurrentVersion, TargetVersion</li>
<li>ECS: TaskDefinition ARN (リビジョン番号含む), LoadBalancerInfo (ContainerName, ContainerPort)</li>
</ul>
</li>
<li>hooks セクション<ul>
<li>デプロイ前後に実行するスクリプトファイルを指定する (ECS, Lambda では Lambda 実行)</li>
<li>EC2 - インプレース<ul>
<li>ApplicationStop: 停止スクリプトを指定</li>
<li>ApplicationStart: 起動スクリプトを指定</li>
<li>ValidateService: 動作検証</li>
<li><img alt="" src="_attachment/File_18.png" /></li>
</ul>
</li>
<li>EC2 - Blue/Green<ul>
<li>ALB があるので AllowTraffic 前後のフックがある。</li>
<li>停止側のインスタンスには BlockTraffic 前後のフックしかない。</li>
<li><img alt="" src="_attachment/image_636.png" /></li>
<li>Blue/Green を採用し 50% のカスタムデプロイ設定を行い、BeforeAllowTraffic フックでデプロイ中に作成される一時ファイルを削除する例:<ul>
<li>Launch an Application Load Balancer and use a blue/green deployment for releasing new application versions.</li>
<li>Associate the Auto Scaling group and the Application Load Balancer target group with the deployment group.</li>
<li>Create a custom deployment configuration for the deployment group in CodeDeploy with minimum healthy hosts defined as 50% and configure it to also terminate the original instances in the Auto Scaling group after deployment.</li>
<li>Use the BeforeAllowTraffic hook within appsec.yml to purge the temporary files.</li>
</ul>
</li>
</ul>
</li>
<li>Lambda<ul>
<li>インストール系のフックがない。</li>
<li><img alt="" src="_attachment/image_637.png" /></li>
</ul>
</li>
<li>ECS<ul>
<li>AfterAllowTestTraffic フックがある。デプロイグループでテストリスナー(オプショナル)を指定しない場合は呼ばれない。</li>
<li>テストリスナーは Green の新タスクグループに一次的に設定される ALB リスナー</li>
<li><img alt="" src="_attachment/image_638.png" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>自動ロールバック</p>
<ul>
<li>デプロイ失敗かデプロイグループに設定したアラーム (例: CPU 使用率 80% 以上等) が発生した場合に以前のリビジョンにデプロイしなおす。</li>
<li>問題例: ALB のアラームをデブロイグループに設定、遅延が高まれば自動ロールバック</li>
<li><img alt="" src="_attachment/image_639.png" /></li>
</ul>
<p>問題例: ECS のデプロイメント</p>
<ul>
<li>The app is hosted on a cluster of Auto Scaling ECS instances and its deployments are handled by AWS CodeDeploy.</li>
<li>ALB health checks are not sufficient to tell that new version deployments are successful, rather you have custom validation scripts that verify all APIs of the application.</li>
<li>You want to make sure that there are no 5XX error replies on the new version before continuing production deployment and that you are notified via email if results failed.</li>
<li>You also want to configure automatic rollback to the older version when the validation fails.</li>
</ul>
<p>解答: AfterAllowTestTraffic で Lambda でテストするが、ロールバックは Alarm によって発生させる</p>
<ol>
<li>Create your validation scripts on AWS Lambda and define the functions on the AppSpec lifecycle hook to validate the app using test traffic.</li>
<li>Associate CloudWatch Alarms to your deployment group to have it trigger a rollback when the 5xx error alarm is active.</li>
<li>Have AWS CloudWatch Alarms trigger an AWS SNS notification when the threshold for 5xx is reached on CloudWatch.</li>
</ol>
<p>問題例: アプリケーションのエラーログでロールバック</p>
<ul>
<li>アプリケーションログを CloudWatch Logs に送信する。</li>
<li>ログ内のエラーメッセージをモニタリングするメトリクスフィルターを作成する。</li>
<li>エラー数が許容できない場合はアラームを開始する。</li>
</ul>
<p>サービスロール</p>
<ul>
<li>デプロイグループに指定し、デプロイターゲットのサービス等へのアクセスを許可する。</li>
<li>AWSCodeDeployRole ... ELB, ASG, タグ取得, ClaoudWatch Alarms 等</li>
<li>AWSCodeDeployRoleForECS</li>
<li>AWSCodeDeployRoleForLambda</li>
<li>ECS, Lambda ではサービスロールで必要な権限を与えられるが、EC2ではインスタンスロールの考慮も必要。</li>
</ul>
<p>CodeDeploy エージェント</p>
<ul>
<li>S3 から pull するためインスタンスロールに s3:Get*, s3:List* パーミッションが必要。</li>
<li>CodeDeploy エンドポイントに HTTPS/443 でアクセス<ul>
<li>パブリックサブネットならインターネット経由、プライベートなら VPC エンドポイント経由。</li>
<li>VPC エンドポイントは ECS や VPC Lambda でもプライベートサブネットなら必要。</li>
</ul>
</li>
<li>インスタンス上のインストールログを CloudWatch Logs で見るには CloudWatch エージェントを別途インストール。</li>
</ul>
<p>オンプレインスタンスのセットアップ</p>
<ol>
<li>オンプレインスタンスが使用する、CodeDeploy アクセス許可を持つ IAM ロールを作成する。</li>
<li>オンプレインスタンス上で sts assume-role で認証情報のセットを取得して保存する。</li>
<li>CodeDeploy エージェントをオンプレインスタンスにインストールする。</li>
<li><code>aws deploy register-on-premises-instance</code> でオンプレインスタンスを登録する。</li>
<li>オンプレミスインスタンスにタグを設定する。(コンソールか CLI コマンド)</li>
<li>タグに基づいてデプロイグループをセットアップする。</li>
<li>デプロイグループを使用してアプリケーションをデプロイする。</li>
</ol>
<p>AppSpec 内で見える環境変数 (カスタム環境変数を渡す方法はない)</p>
<ul>
<li>APPLICATION_NAME</li>
<li>DEPLOYMENT_ID</li>
<li>DEPLOYMENT_GROUP_NAME</li>
<li>DEPLOYMENT_GROUP_ID</li>
<li>LIFECYCLE_EVENT</li>
</ul>
<p>Bundle from S3</p>
<ul>
<li>BUNDLE_BUCKET</li>
<li>BUNDLE_KEY</li>
<li>BUNDLE_VERSION</li>
<li>BUNDLE_ETAG</li>
</ul>
<p>Bundle from GitHub</p>
<ul>
<li>BUNDLE_COMMIT</li>
</ul>
<h1 id="codepipeline">CodePipeline</h1>
<p>ステージ</p>
<ul>
<li>ソースステージ</li>
<li>ビルドステージ (オプショナル)</li>
<li>デプロイステージ (オプショナル)</li>
</ul>
<p>ソースステージ</p>
<ul>
<li>入力アーティファクトが更新されると自動でパイプラインが起動される。</li>
<li>CodeBuild のソースプロバイダー + ECR</li>
<li>AWS リソースの CodeCommit, ECR, S3 は CloudWatch Events/EventBridge で監視。</li>
<li>外部リソースの GitHub, Bitbucket  は CodeStarSourceConnection プロバイダーで Webhook で監視。</li>
</ul>
<p>ビルドステージ</p>
<ul>
<li>CodeBuild, Jenkins</li>
</ul>
<p>デプロイステージ</p>
<p><img alt="" src="_attachment/image_640.png" /></p>
<p>アクション</p>
<p><img alt="" src="_attachment/image_641.png" /></p>
<ul>
<li>Approval アクション: 手動承認 (SNS)<ul>
<li>Codepipeline コンソール上または SNS で通知される URL で Approve/Reject できる。(サブスクライバは任意に追加可能)</li>
</ul>
</li>
<li>カスタムアクション<ul>
<li>Codepipeline サービスから Job をポーリングして、Job 実行後にレスポンスを返す。</li>
</ul>
</li>
<li>パラレルアクション(=アクショングループ)とシーケンシャルアクション</li>
<li><strong>runOrder:</strong> シーケンスの順番。パラレルアクションは同じ runOrder になる。<ul>
<li>問題例: 複数の Lambda のデプロイを並行させることでパイプラインの処理時間を早める</li>
<li><img alt="" src="_attachment/image_642.png" /></li>
</ul>
</li>
</ul>
<p>アーティファクト</p>
<ul>
<li>各ステージのアーティファクトが S3 に置かれ、次のステージに渡される。</li>
<li>S3 バージョンを使用して作成の度にバージョニングされる。</li>
<li>デフォルトで S3 の AWS 管理キー (aws/s3) を作成して SSE-KMS 暗号化。</li>
<li>カスタマー管理キーでないとキーポリシーを変更できずクロスアカウントでの使用ができない。</li>
</ul>
<p>クロスリージョンアクション</p>
<ul>
<li>クロスリージョンでビルドプロバイダー/デプロイプロバイダー等を呼び出すことが可能。<ul>
<li>ソースアクション、サードパーティーアクション、カスタムアクションは不可。</li>
</ul>
</li>
<li>各リージョンにアーティファクトストア (S3バケット) と SSE-KMS キーが必要となる。</li>
<li>リージョン間でのアーティファクトのコピーが行われる。</li>
<li><a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-create-cross-region.html">https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-create-cross-region.html</a></li>
</ul>
<p>クロスアカウント</p>
<ul>
<li>パイプラインのある開発アカウントとデプロイ先の本番アカウントのクロスアカウント設定。</li>
<li>パイプライン側で KMS カスタマー管理キーを作成。デプロイ先アカウントから使用できるようキーポリシーを設定。</li>
<li>S3 バケットにもデプロイ先アカウントからアクセスできるようバケットポリシーを設定。</li>
<li>デプロイ先アカウントに CodeDeploy プロジェクトを作成。デプロイ先インスタンスのインスタンスロールに KMS, S3 へのアクセス権も設定。</li>
<li>この CodeDeploy を開発側アカウントのパイプラインから実行できるよう、クロスアカウントロールを作成して、パイプラインのサービスロールに設定。</li>
</ul>
<p>Ref. クロスアカウントロール</p>
<ul>
<li>ロールの信頼ポリシーでリモートアカウントからの AssumeRole を許可。</li>
<li>プリンシパルのポリシーでリモートロールへの AssumeRole を許可。</li>
</ul>
<p>EventBridge 連携</p>
<ul>
<li>単にパイプラインから Lambda 呼びたければ Invoke アクションがあるので、Fail の際などに呼ぶ場合にこちらを使う。</li>
</ul>
<p>問題例: CloudFormation アクションで CFn テンプレートのパラメータを指定して prod/staging/dev のコンフィグを分ける</p>
<ul>
<li>Launch a new pipeline using AWS CodePipeline that has multiple stages for each environment and configure it to use input parameters.</li>
<li>Switch the associated UserData of the EC2 instances to match the environment where the application stack is being launched using CloudFormation mappings.</li>
<li>Specify parameter overrides for AWS CloudFormation actions.</li>
</ul>
<h1 id="codestar">CodeStar</h1>
<p>Code サービスによる CI/CD パイプラインをアプリのテンプレートから簡単に作成できる。</p>
<ul>
<li>リポジトリ: CodeCommit / GitHub</li>
<li>デプロイターゲット: EC2 / Lambda / Beanstalk</li>
<li>パイプライン: CodePipeline</li>
<li>ビルドプロジェクト: CodeBuild </li>
<li>デプロイツール: CodeDeploy, CloudFormation, Beanstalk</li>
<li>CloudWatch メトリクス</li>
<li>プロジェクト管理ダッシュボード</li>
</ul>
<h1 id="s3">S3</h1>
<p>Ref.<a href="References/AWS%20-%20Security%20-%20S3,%20Glacier,%20RDS,%20DynamoDB.html">AWS - Security - S3, Glacier, RDS, DynamoDB</a></p>
<p>ライフサイクルルール</p>
<ul>
<li>バケットのオプション。一定期間が過ぎたオブジェクトのライフサイクルを指定。</li>
<li>移行 (Transition): 別のストレージクラスに移行。Glacier へのアーカイブも可能。</li>
<li>失効 (Expiration): 削除</li>
<li>フィルター要素<ul>
<li>キープレフィックスおよびタグで対象を選択できる</li>
</ul>
</li>
<li>バージョニングの最新とそれ以前で個別に設定できる。</li>
<li>問題例: LegalHold タグ true のドキュメント以外は 90 日で削除したい<ul>
<li>S3 イベントでオブジェクト作成時に Lambda 関数を開始する。LegalHold タグが存在しない場合は false の値を追加する。</li>
<li>LegalHold タグが false のフィルタールールを指定した S3 ライフサイクルポリシーを作成し、90 日より古いオブジェクトを削除するよう設定する。</li>
</ul>
</li>
</ul>
<h1 id="deployment-strategy">Deployment Strategy</h1>
<p><a href="AWS%20-%20Deployment%20Strategy.html">AWS - Deployment Strategy</a></p>
<p>用語</p>
<ul>
<li>ダークローンチ<ul>
<li>フィーチャーフラグで一部のインスタンスで機能を有効にする。</li>
</ul>
</li>
<li>セグメンテーション<ul>
<li>デプロイを小さなチャンクに分割することでリスク軽減。</li>
<li>リージョン, AZ, タグ, ASG, etc.</li>
</ul>
</li>
</ul>
<p>インプレース</p>
<ul>
<li>インスタンスが並列しないので低コスト。</li>
<li>CodeDeploy, Beanstalk (All at once)</li>
</ul>
<p>イミュータブル</p>
<ul>
<li>インプレースの反対。新しいインスタンスまたは並列環境を作ってデプロイする。</li>
</ul>
<p>ローリング</p>
<ul>
<li>本番環境の稼働中インスタンスを一部切り離してデプロイし、再びオンラインに戻すを繰り返す。</li>
<li>システム全体のダウンタイムなし。ダウングレードはある。</li>
<li>CodeDeploy: インプレースの OneAtATime, HalfAtATime, Custom</li>
<li>Beanstalk: ローリング, 追加バッチとローリング</li>
<li>EC2 Auto Scaling: AutoScalingRollingUpdate</li>
<li>ECS Service: deploymentController=ECS</li>
</ul>
<p>Blue/Green</p>
<ul>
<li>トラフィックを振り分けるため、トラフィックルーティングの仕組みが必要。</li>
<li>システムのダウングレードなし。</li>
<li>ロールバックが容易。</li>
<li>CodeDeploy, Beanstalk(Immutable)</li>
<li>EC2 Auto Scaling: AutoScalingReplacingUpdate</li>
</ul>
<h2 id="bluegreen">Blue/Green デプロイの実現方法</h2>
<p>Route53 CNAME 切り替え (AllAtOnce)</p>
<ul>
<li>エイリアス (CNAME) が指す ELB の DNS 名を切り替える。</li>
</ul>
<p>Route53 加重ラウンドロビン</p>
<p>ELB ターゲットグループ切り替え</p>
<p>ALB 加重ターゲットグループ</p>
<ul>
<li>Blue/Green のターゲットグループに重みを指定。</li>
<li>NLB にはない機能。</li>
</ul>
<p>Auto Scaling スケールアウト/スケールイン</p>
<ul>
<li>デフォルトの終了ポリシーが古い起動設定により起動されたインスタンスから終了させることを利用。</li>
<li>起動テンプレートでAMIを変更後、インスタンス数を増やしてから減らすと自動的に古いインスタンスがなくなる。</li>
</ul>
<p>API Gateway Canary ステージ</p>
<p>Lambda 加重エイリアス</p>
<ul>
<li>route-config 設定でセカンダリのバージョンと比率を設定。</li>
</ul>
<p>SAM の AWS::Serverless::Function</p>
<ul>
<li>DeploymentPreference プロパティで CodeDeploy の Lambda  デプロイメントを設定できる。</li>
</ul>
<p>CodeDeploy</p>
<ul>
<li>EC2:  ALB の加重ターゲットグループで移行。</li>
<li>ECS: 新しいタスクセットと ELB ターゲットグループを作成、加重ターゲットグループで移行。</li>
<li>Lambda: 加重エイリアスを使用。</li>
</ul>
<p>Elastic Beanstalk</p>
<ul>
<li>eb clone/swap による DNS カットオーバー</li>
<li>eb deploy の展開タイプ - イミュータブル (Immutable)</li>
</ul>
<h2 id="codedeploy_1">CodeDeploy のデプロイ</h2>
<p>CodeDeploy のデプロイタイプ</p>
<ul>
<li>EC2/オンプレ<ul>
<li>インプレース (=AllAtOnce 以外はローリング)</li>
<li>Blue/Green (=イミュータブル)</li>
</ul>
</li>
<li>ECS, Lamda<ul>
<li>Blue/Green のみ (仕組み的にコンテナやLambdaはインプレース切り替えの概念がない)</li>
</ul>
</li>
</ul>
<p>デプロイ設定</p>
<p><img alt="" src="_attachment/image_643.png" /></p>
<p>カスタム</p>
<ul>
<li>HalfAtOnce の代わりの割合か台数で必要な稼働中インスタンス数 (min. health) を指定する。</li>
</ul>
<p>EC2/オンプレ</p>
<ul>
<li>インプレース(=ローリング)<ul>
<li>稼働中インスタンスを停止せずに新バージョンのアプリを配置/起動。</li>
<li>各インスタンスでアプリを停止後、新リビジョンをインストールして起動・検証。</li>
</ul>
</li>
</ul>
<p>EC2</p>
<ul>
<li>Blue/Green デプロイ<ul>
<li>Green インスタンス群を起動、新リビジョンをインストールして起動・検証。</li>
<li>ELB で実現されるので ELB が必須。</li>
<li>「Auto Scaling グループの自動コピー」オプション<ul>
<li>ASG 全体の置き換えによるデプロイメントを行う。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>ECS</p>
<ul>
<li>新しいタスクセットと ELB ターゲットグループを作成、加重ターゲットグループで移行。</li>
</ul>
<p>Lambda</p>
<p>- 指定された新旧バージョンで加重エイリアス(カナリアリリース)を行う。
- route-configでセカンダリバージョンの比率を指定。</p>
<h2 id="elastic-beanstalk">Elastic Beanstalk のデプロイ</h2>
<h3 id="deployment-policy">デプロイポリシー (Deployment policy)</h3>
<p>All at once</p>
<ul>
<li>単純なインプレースデプロイ。新バージョンを全インスタンスに同時展開。</li>
<li>環境の全インスタンスのアプリケーションが短時間停止する。</li>
<li>展開終了までの合計時間は最短。インスタンスの追加コストなし。</li>
</ul>
<p>Rolling</p>
<ul>
<li>環境のインスタンスを複数バッチに分割、バッチごとに新バージョンをデプロイ。(インプレース)</li>
<li>バッチサイズ分のインスタンスを LB からデタッチしてデプロイ実施。ヘルスチェックが通ればそのバッチを LB に再アタッチ。全インスタンスにデプロイがされるまで繰り返し。</li>
<li>インスタンスの追加コストなし。</li>
</ul>
<p>Rolling with additional batch</p>
<ul>
<li>バッチサイズ分の新しいインスタンスにデプロイして環境に追加した後でローリングを実行。</li>
<li>追加バッチのインスタンスは最終的には消去される。</li>
</ul>
<p>Immutable (=Blue/Green)</p>
<ul>
<li>テンポラリな ASG を作成して新バージョンを展開したインスタンスのフルセットを起動。</li>
<li>新しいインスタンスでヘルスチェックが Fail した場合は終了し、元のインスタンスがそのまま残る。</li>
<li>Fail 時のロールバックが迅速。</li>
<li>Success した場合は Green のインスタンスをプロダクションの ASG に移動する。</li>
<li>Blue のインスタンスは削除されるのでイミュータブル。</li>
<li>一時的にインスタンスコストが倍。</li>
</ul>
<p>手動 Blue/Green デプロイ</p>
<ul>
<li>eb clone で既存環境のクローンを作成後、新バージョンをデプロイしてテスト。</li>
<li>eb swap で内部の CNAME を既存環境から新環境に切り替え。(DNS カットオーバー)</li>
<li><img alt="" src="_attachment/image_644.png" /></li>
<li><img alt="" src="_attachment/image_645.png" /></li>
<li>2つの環境を作って Route53 加重ルーティングをする例</li>
<li><img alt="" src="_attachment/image_646.png" /></li>
</ul>
<p>問題例: Serveless のバックエンド API 層と Web アプリケーション層を Blue/Green する要件</p>
<ul>
<li>Deploy the DynamoDB tables, Lambda functions, and Amazon ES domain using AWS CloudFormation.　<ul>
<li>Deploy changes with an AWS CodeDeploy blue/green deployment.</li>
</ul>
</li>
<li>Host the web application in AWS Elastic Beanstalk and set the deployment policy to <strong>Immutable</strong>.</li>
</ul>
<h2 id="ecs">ECS のデプロイ</h2>
<p>サービスの deploymentController 設定を次のいずれかに設定する:</p>
<ul>
<li>ECS<ul>
<li>ローリング更新</li>
<li>サービスのタスク定義を更新すると ECS はローリングデプロイを実施する。</li>
<li>古いバージョ ンのコンテナへの接続をドレイニングし、新しいコンテナを ALB に登録する。</li>
</ul>
</li>
<li>CODE_DEPLOY<ul>
<li>Blue/Green</li>
</ul>
</li>
<li>EXTERNAL<ul>
<li>ECS API でサービス・タスクを制御する外部のデプロイコントローラー</li>
</ul>
</li>
</ul>
<h1 id="infrastructure-as-codeconfiguration-management">Infrastructure as Code/Configuration Management</h1>
<p><a href="AWS%20-%20CloudFormation,%20Elastic%20Beanstalk,%20OpsWork.html">AWS - CloudFormation, Elastic Beanstalk, OpsWork</a></p>
<p><img alt="" src="_attachment/image_647.png" /></p>
<ul>
<li>CloudFormation は AWS リソースのプロビジョニングに特化。</li>
<li>Beanstalk, OpsWorks はインフラのプロビジョニング、アプリケーションのデプロイ、運用時のモニタリングまで全体をカバー。</li>
<li>Web アプリの定番構成 → Beanstalk</li>
<li>Web アプリでない、定番構成でない、既に Chef/Puppet 使っている → OpsWork</li>
</ul>
<h1 id="cloudformation">CloudFormation</h1>
<p>Pseudo Parameters</p>
<p><img alt="" src="_attachment/image_648.png" /></p>
<p>SSM Parameters Store 参照</p>
<pre><code>Parameters:
  InstanceType:
    Type: 'AWS::SSM::Parameter::Value&lt;String&gt;'
    Default: /EC2/InstanceType

  ImageId:
    Type: 'AWS::SSM::Parameter::Value&lt;AWS::EC2::Image::Id&gt;'
    Default: /EC2/AMI_ID
</code></pre>
<p>Mappings セクション</p>
<ul>
<li>リージョンごとに使用する AMI ID を指定するマッピングテーブルなどを定義する。<ul>
<li>AMI はリージョンリソースなので、リージョンごとに AMI ID が異なる。</li>
</ul>
</li>
<li>Fn::FindInMap function でアクセス<ul>
<li>!FindInMap [ <em>MapName, TopLevelKey, SecondLevelKey</em> ]</li>
</ul>
</li>
</ul>
<p>Conditions セクション</p>
<ul>
<li>テンプレート内で宣言的に条件指定を行って Resources, Outputs の生成を制御する。</li>
<li><img alt="" src="_attachment/image_649.png" /></li>
<li>各 Resource, Output の Condition 属性で参照する</li>
</ul>
<p>Outputs セクション</p>
<ul>
<li>スタック内の値をコンソールや CLI にアウトプットする。</li>
<li>ネストしたスタックの Outputs は 親スタックから Stack リソースの属性として参照できる。<ul>
<li>!GetAtt StackName.Output.Name</li>
</ul>
</li>
<li>Export することで Fn::ImportValue で他のスタックからも参照できる。</li>
<li>Export 名の名前空間は同一アカウントのリージョン内。</li>
</ul>
<p>CreationPolicy 属性</p>
<ul>
<li>生成完了ポリシー指定: 例) AutoScalingGroup リソースが作成時、グループ内の2個のインスタンスからシグナルがとどくまで生成完了とならず、次に進まない。</li>
</ul>
<pre><code class="language-yaml">CreationPolicy:
  ResourceSignal:
    Count: 2 
</code></pre>
<p>UpdatePolicy 属性</p>
<ul>
<li>AWS::AutoScaling::AutoScalingGroup<ul>
<li>AutoScalingRollingUpdate</li>
<li>AutoScalingReplacingUpdate</li>
</ul>
</li>
<li>AWS::Lambda::Alias<ul>
<li>Lambda の加重エイリアスを設定する。</li>
</ul>
</li>
</ul>
<pre><code>  alias:
    Type: AWS::Lambda::Alias
    Properties:
      FunctionName: !Ref function
      FunctionVersion: !GetAtt newVersion.Version
      Name: BLUE
      RoutingConfig:
        AdditionalVersionWeights:
          - FunctionVersion: !GetAtt version.Version
            FunctionWeight: 0.5
</code></pre>
<p>DeletionPolicy 属性</p>
<ul>
<li>Delete, Retain, Snapshot</li>
<li>スナップショット対象: EBS, RDS, ElastiCache, Redshift</li>
</ul>
<h3 id="_2">スタックのオプション</h3>
<p>TimeoutInMinutes</p>
<ul>
<li>スタックのステータスが CREATE_FAILED になるまでに待機可能な時間。</li>
</ul>
<p>DisableRollback</p>
<ul>
<li>ロールバック自体の無効化。</li>
<li>Fail した場合も残ったリソースはスタックごと手動で削除できる。</li>
</ul>
<p>OnFailure</p>
<ul>
<li>スタック作成に失敗した場合に実行するロールバック操作を指定。</li>
<li>DO_NOTHING、ROLLBACK、DELETE のいず れか。</li>
<li>DETETE ではスタックの情報そのものが消去されるのでスタックのログも見られない。</li>
<li>DisableRollback が有効な場合、OnFailure は設定できない。</li>
</ul>
<p>CAPABILITY_IAM / CAPABILITY_NAMED_IAM</p>
<ul>
<li>IAM リソースを作成するテンプレートの create-stack/update-stack には CAPABILITY_IAM または CAPABILITY_NAMED_IAM の capability の指定が必要になる。</li>
</ul>
<p>スタックのネスト</p>
<ul>
<li>AWS::CloudFormation::Stack リソースで別のテンプレートをネストする。</li>
<li>ネットワーク層とアプリ層のテンプレートをネストする例<ul>
<li>DependsOn で作成順序をコントロール。そうしないと並列で作成されてしまう。</li>
<li>ネットワークスタックの Outputs の値をアプリケーションスタックの Parameters で渡す。</li>
</ul>
</li>
<li>スタック更新時は親スタック (root stack) を更新する。</li>
</ul>
<p>クロススタックリファレンス (Export/ImportValue)</p>
<ul>
<li>ネストと異なり同時にスタックを作らない場合のスタックの関連付け 。</li>
<li>他のスタックで Export した名前を別スタックで ImportValue で参照する。</li>
</ul>
<p>MetaData 属性 (リソースメタデータ)</p>
<ul>
<li>各リソースの MetaData 属性に指定できる任意の Key-value オブジェクト。</li>
<li>AWS::CloudFormation::Init キーに指定されたオブジェクトの指定を cfn-init が処理。</li>
</ul>
<pre><code>AWSTemplateFormatVersion: '2010-09-09'
Resources:
  MyS3Bucket:
    Type: AWS::S3::Bucket
    Metadata:
      Object1: Location1
      Object2: Location2
</code></pre>
<p>UserData 属性 (EC2)</p>
<ul>
<li>Fn::Base64 でテンプレート内に記載した UserData スクリプトの全体を渡すことができる。</li>
<li>(参考) UserData 実行のアウトプットは /var/log/cloud-init-output.log に書き込まれる。<ul>
<li>cloud-init は UserData を実行する機能。</li>
</ul>
</li>
</ul>
<p>cfn-init</p>
<ul>
<li>パッケージのインストール、 ファイル作成、サービス開始などの初期化処理に使用。</li>
<li>MetaData に指定された AWS::CloudFormation::Init に記述された処理を実行する。</li>
<li>通常はインスタンスの UserData スクリプトの一部として実行される。</li>
<li>ログ出力: /var/log/cfn-init.log</li>
</ul>
<p>cfn-signal</p>
<ul>
<li>CreationPolicy 属性と WaitCondition リソースの ResourceSignal 属性で使用されるシグナルを送信するために使用</li>
<li>WaitCondition はテンプレートのリソースの1つとして作られ、このリソースが生成されるまでスタック生成全体が終了されないようにできる。</li>
</ul>
<p>cfn-hup</p>
<ul>
<li>リソースメタデータの変更が検出されたときにカスタムフックを実行するために使用される。</li>
<li>スタック更新で起動中インスタンス内で更新処理を実行したい場合に使う。</li>
<li>デーモンとしてバックグラウンド動作するので通常は UserData で起動する。</li>
</ul>
<p>cfn-get-metadata</p>
<ul>
<li>リソースメタデータを取得して独自処理をする場合に使用する。</li>
<li>MetaData の内容が JSON で取得される。</li>
</ul>
<p>トラブルシューティング</p>
<p><img alt="" src="_attachment/image_650.png" /></p>
<ul>
<li>プライベートサブネットのインスタンスからシグナルを送るために CloudFormation サービスに NAT 等でアクセスできるようにする必要がある。</li>
</ul>
<h3 id="_3">リソースの保護</h3>
<p>DeletionPolicy 属性</p>
<ul>
<li>スタックが削除される時にリソースを保持(Retain)またはバックアップ(Snapshot)できる。</li>
</ul>
<p>TerminationProtection: スタックの削除保護</p>
<ul>
<li>スタックの削除が実行できなくなる。スタック作成時と作成後にも設定できる。</li>
<li>削除保護を変更すると、ネストされたスタックにも反映される。</li>
</ul>
<p>スタックポリシー</p>
<ul>
<li>スタックにつけられるリソースベースポリシー。</li>
<li>重要なスタックリソースを変更する意図しないスタック更新を拒否できる。</li>
<li>まず全て Allow して、保護したいものを Deny で指定する</li>
</ul>
<p>ドリフト検出</p>
<ul>
<li>CloudFormation 外部でスタックのリソースに直接変更が行われたか検出できる。</li>
<li>AWS コンソールでスタックアクションからドリフト検出を実施し、ドリフト詳細の表示を行う。</li>
<li>スタック全体のステータス: NOT_CHECKED, IN_SYNC, DRIFTED</li>
<li>リソースのステータス: NOT_CHECKED, IN_SYNC, DELETED, MODIFIED</li>
<li>ネストされたスタックのドリフトは検出しない。ネストされたスタックに対して直接ドリフト検出の実行が必要。</li>
</ul>
<p>カスタムリソース</p>
<ul>
<li>外部リソースをカスタムリソースプロバイダー (Lambda 等) で作成・更新・削除する。SNS と S3 署名付き URL で実装。</li>
<li>ユースケース:<ul>
<li>空でない S3 バケットではスタック削除が Fail するため、Lambda カスタムリソースで削除するのは頻出のユースケース。(DeletaionPolicy が Delete でも Fail する)</li>
<li>リージョン毎に異なる AMI ID を Lambda カスタムリソースで取得して、カスタムリソースの Attribute として AMI ID を返すようなユースケース。</li>
</ul>
</li>
<li>Create/Update/Delete といったリクエストを SNS メッセージでカスタムリソースプロバイダに送信。<ul>
<li>カスタムリソースプロバイダがメッセージを処理し、Success/Fail の結果が S3 署名付き URL 経由で CloudFormation に返される。</li>
<li>Lambda を使用する場合は直接 Lambda の ARN を指定でき、SNS トピックを作成する必要がない。</li>
</ul>
</li>
</ul>
<p>CloudFormation スタックセット</p>
<ul>
<li>クロスアカウント/クロスリージョンに同一スタックを1度のオペレーションで作成、更新、削除できる。</li>
<li>全アカウントに AWS Config を展開したり、共通の IAM ロールを配布するなどの用途。</li>
<li>ターゲットアカウントにスタックを作成する前に、 管理者アカウントとターゲットアカウントの間に信頼関係をセットアップする必要がある。</li>
<li>スタックセットはリージョンリソースなので、他のリージョンで表示や変更できない。</li>
<li>StackSets のテンプレートがある: クロスアカウントで CloudTrail, Config を有効にするのに使われる</li>
<li><img alt="" src="_attachment/image_651.png" /></li>
</ul>
<p>AWS CDK (Cloud Development Kit/クラウド開発キット)</p>
<ul>
<li>プログラミング言語から CloudFormation テンプレートの構築・操作をコーディングするライブラリとツールキット。</li>
</ul>
<h1 id="elastic-beanstalk_1">Elastic Beanstalk</h1>
<ul>
<li>Web サーバ環境と Worker 環境 (Web server tier &amp; Worker tier)</li>
<li>プロビジョニング・負荷分散・モニタリングなどを自動設定:<ul>
<li>EC2, EBS, RDS, セキュリティグループ, IAM ロール</li>
<li>ELB, Auto Scaling</li>
<li>CloudWatch Alarms, SNS</li>
</ul>
</li>
<li>プラットフォームのアップデート。</li>
</ul>
<p>アプリケーション</p>
<ul>
<li>環境、環境設定、アプリケーションバージョンの入れ物</li>
<li>複数環境を起動できる。</li>
</ul>
<p>環境</p>
<ul>
<li>インフラ環境 (Web/Worker)</li>
<li>アプリケーションバージョン (アプリのコード) をデプロイする場所。</li>
</ul>
<p>アプリケーションバージョン</p>
<ul>
<li>eb deploy するたびにアプリケーションバージョンができる</li>
<li>ライフサイクル: バージョンの保持期限を個数又は日数で管理する</li>
</ul>
<p>環境タイプ</p>
<ul>
<li>単一インスタンス: Single-instance<ul>
<li>単一の Web サーバインスタンスに EIP がつき、単一の DB インスタンスができる。</li>
</ul>
</li>
<li>負荷分散: Load balanced<ul>
<li>ELB と Auto Scaling が付き、Multi-AZ を設定できる。</li>
<li>DB がプライマリー・スタンバイ構成になる。</li>
</ul>
</li>
</ul>
<p>保存済み設定: Saved configurations</p>
<ul>
<li>起動中の環境設定をテンプレートとして保存して他のリージョンやアカウントで展開できる</li>
<li>インスタンスタイプや ASG などの環境設定なので、コードや .ebextensions は含まれない。</li>
<li>eb config save dev-env --cfg prod<ul>
<li>サービス側に設定が保存される。</li>
<li>.elasticbeanstalk/saved_configs 配下に prod.cfg.yaml ができ、ローカルで直にファイルを編集できる。</li>
</ul>
</li>
<li>eb config put prod<ul>
<li>ローカルで編集した設定をサービス側に保存する。</li>
</ul>
</li>
<li>eb config dev-env --cfg prod<ul>
<li>サービス側に保存された設定を環境に適用。</li>
</ul>
</li>
</ul>
<p>.ebextensions フォルダ</p>
<ul>
<li>アプリケーションパッケージ内に配置する設定スクリプト</li>
<li>操作を指定した (分割された) 設定ファイルを配置。eb deploy で環境に適用。</li>
</ul>
<p><img alt="" src="_attachment/image_652.png" /></p>
<ul>
<li>services:<ul>
<li>各種サービスのコンフィグを設定: EC2, VPC, Auto Scaling, ELB, RDS  等。</li>
</ul>
</li>
<li>resources:<ul>
<li>CloudFromation テンプレートのリソース記述で任意のリソースを作成できる。</li>
<li>ただし DB のように消えたら困るリソースは環境外に個別に作成したほうがよい。</li>
</ul>
</li>
<li>commands<ul>
<li>インスタンス起動後、アプリケーションのファイルが展開される前に実行されるコマンド</li>
<li>バックアップや旧ファイルのクリーンアップなど。</li>
</ul>
</li>
<li>container_commands<ul>
<li>アプリケーションのファイルが展開された後、アプリのデプロイ前に実行される</li>
<li>デプロイ前の DB マイグレーションや設定ファイルの更新など</li>
<li><strong>leader_only: true</strong> ... 複数あるインスタンスのうち１つだけで実行</li>
</ul>
</li>
</ul>
<p>.platform/hooks フォルダ</p>
<ul>
<li>/opt/elasticbeanstalk/hooks/ で実行される<ul>
<li>preinit - アプリケーションのデプロイ前</li>
<li>appdeploy - アプリケーションのデプロイ中</li>
<li>postinit - アプリケーションのデプロイ後</li>
<li>configdeploy - ユーザによる設定変更時</li>
<li>restartappserver - ユーザによるリスタート時</li>
</ul>
</li>
<li>デプロイ後にコマンド実行するには .ebextentions/files で appdeploy/post フォルダにスクリプトを作成する</li>
</ul>
<p>デプロイポリシー</p>
<ul>
<li>All at once</li>
<li>Rolling</li>
<li>Rolling with additional batch</li>
<li>Immutable</li>
</ul>
<p>Worker 環境</p>
<ul>
<li>SQS キューのリッスンまたはスケジュールでタスクを処理する Worker アプリケーション。</li>
<li>スケジュールは cron.yaml で設定。</li>
<li>Web サーバ環境と並行して Worker 環境を立てて時間のかかる処理を非同期実行。</li>
</ul>
<p>Docker in Beanstalk</p>
<ul>
<li>プラットフォームに Docker を選ぶ場合 ECS の使用を選択できる。</li>
<li>EC2 Auto Scaling でスケーリングされる ECS クラスターが作成される。</li>
<li>環境のコンテナ群 (タスクセット) が ECS Service により起動される。</li>
<li>ECS Service Auto Scaling によるタスク数のスケーリングも設定される。</li>
</ul>
<p>設定の優先順位</p>
<ol>
<li>環境に直接 API (CLI) で適用される設定</li>
<li>保存済み設定</li>
<li>設定ファイル (.ebextensions)</li>
<li>デフォルト値</li>
</ol>
<p>問題例: Beanstalk からの RDS のデカップリング</p>
<ul>
<li>RDS is used as the database, and it is tightly coupled to the Elastic Beanstalk environment.</li>
<li>A DevOps Engineer noticed that if you terminate the environment, its database goes down as well.</li>
<li>This issue prevents you from performing seamless updates with blue-green deployments.</li>
<li>How can the DevOps Engineer decouple the database instance from the environment with the LEAST amount of data loss?</li>
</ul>
<p>解答</p>
<ul>
<li>Decouple the RDS instance from your Elastic Beanstalk environment using the blue/green deployment strategy to decouple. (Blue/Green で既存環境を稼働させてダウンタイム縮小しながら RDS をデカップリング)</li>
<li>Take an RDS DB snapshot of the database and enable deletion protection. (スナップショットと保護)</li>
<li>Set up a new Elastic Beanstalk environment with the necessary information to connect to the RDS instance.</li>
<li><strong>Before terminating the old Elastic Beanstalk environment, remove its security group rule first before proceeding.</strong></li>
<li>Beanstalk 環境のインスタンスから RDS に接続するには RDS 側の SG で環境の SG からの Ingress アクセスを許可する必要があるが、このルールによる依存関係の残したままだと環境の削除が FAIL する。</li>
<li>環境側の SG が RDS の SG に参照されたままなので、利用中あつかいになる。</li>
</ul>
<h1 id="aws-opsworks">AWS OpsWorks</h1>
<p><img alt="" src="_attachment/image_653.png" /></p>
<p>スタック</p>
<ul>
<li>複数レイヤにまとめられた AWS リソースのスタック</li>
</ul>
<p>レイヤー (Layer)</p>
<ul>
<li>機能別のインスタンスグループ<ul>
<li>ロードバランサー層、アプリケーションサーバ層、DB 層などのレイヤにまとめられた AWS リソース</li>
</ul>
</li>
<li>インスタンスタイプ<ul>
<li>24/7: 常時稼働</li>
<li>Time-based: スケジュールで起動・停止（例: 夜間バッチ）</li>
<li>Load-based: CPU などの負荷指標でスケール制御</li>
</ul>
</li>
</ul>
<p>クックブックとレシピ</p>
<ul>
<li>クックブックリポジトリ<ul>
<li>Git、S3、HTTP など、Chef クックブックの保存場所。</li>
</ul>
</li>
<li>レシピ<ul>
<li>レイヤーごとに実行される設定スクリプト。</li>
<li>OpsWorks スタックは各ライフサイクルイベントで対応するレシピを自動実行。</li>
<li>インスタンスにアプリケーションをデプロイする際、<code>Deploy</code> ライフサイクルイベントがトリガーされ、レイヤーのデプロイレシピがインスタンスで実行される。</li>
</ul>
</li>
</ul>
<p>ライフサイクルイベント</p>
<p>各レイヤーで<strong>ライフサイクルイベントごとに実行するレシピを指定</strong>できる。</p>
<ul>
<li>Setup<ul>
<li>This event occurs after a started instance has finished booting.</li>
</ul>
</li>
<li><strong>Configure</strong><ul>
<li>This event occurs on all of the stack's instances when one of the following occurs:<ul>
<li>An instance enters or leaves the online state.</li>
<li>You associate an EIP address with an instance or disassociate one from an instance.</li>
<li>You attach an ELB to a layer, or detach one from a layer.</li>
</ul>
</li>
<li>いずれか1つのインスタンスが<strong>オンライン/オフラインになった際に全てのインスタンスで実行</strong>される。</li>
</ul>
</li>
<li>Deploy<ul>
<li>This event occurs when you run a Deploy command, typically to deploy an application to a set of application server instances.</li>
</ul>
</li>
<li>Undeploy<ul>
<li>This event occurs when you delete an app or run an Undeploy command to remove an app from a set of application server instances.</li>
</ul>
</li>
<li>Shutdown<ul>
<li>This event occurs after you direct OpsWorks Stacks to shut an instance down but before the associated  EC2 instance is actually terminated.</li>
</ul>
</li>
</ul>
<p>問題例</p>
<p>You are working as a DevOps engineer for a leading telecommunications company which is planning to host a distributed system in AWS. Their system must be hosted on multiple Linux-based application servers which must use the same configuration file that tracks any changes in the cluster such as adding or removing a server. The configuration file is named as <em>tdojo-nodes.config</em> which contains the list of private IP addresses of the servers in the cluster and other metadata.</p>
<p>Which of the following is the MOST automated way to meet the above requirements?</p>
<p>解答</p>
<p>Layer the application server nodes of the cluster using AWS OpsWorks Stacks and add a Chef recipe associated with the <strong>Configure</strong> Lifecycle Event which populates the <em>tdojo-nodes.config</em> file. Set up a configuration which runs each layer's <strong>Configure</strong> recipes that updates the configuration file when a cluster change is detected.</p>
<p>自動ヒーリング</p>
<ul>
<li>OpsWorks Stacks agent との疎通確認でインスタンスのヘルスチェック。</li>
<li>Fail すると自動ヒーリングが新しいインスタンスのプロビジョンを実行。</li>
<li>Fail のイベントは EventBridge で監視できる。</li>
<li>OpsWorks は Auto Scaling を使用していないため必要。</li>
</ul>
<hr />
<h1 id="container-services">Container Services</h1>
<ul>
<li><a href="AWS%20-%20Container%20Services.html">AWS - Container Services</a></li>
</ul>
<h1 id="ecs_1">ECS</h1>
<p><img alt="" src="_attachment/20190731_AmazonECS_DeepDive_AWSBlackBelt_2.png" /></p>
<p>Task Definition</p>
<ul>
<li>(複数の)コンテナ定義、コンテナの CPU/メモリサイズ、タスク実行ロール</li>
<li>コンテナへのボリュームマッピングやポートマッピング</li>
<li>ネットワークモード (VPC)</li>
<li>docker-compose.yaml 相当の設定</li>
</ul>
<p>Service</p>
<ul>
<li>ロードバランシングされスケーリングも可能な、インバウンド接続される外部公開サービスの1単位</li>
<li>Task の desired count の維持 -&gt; Auto Healing</li>
<li>ELB によるトラフィックルーティング</li>
<li>起動方式: Launch Type (EC2/Fargate), Capacity Provider Strategy</li>
<li>デプロイ管理: Rolling update / Blue-Green（CodeDeploy）</li>
<li>Service Auto Scaling: CPUなどのメトリクスに応じてタスク数を増減</li>
</ul>
<p>Capacity Provider（CP）</p>
<ul>
<li>タスク実行インフラの抽象化。旧来の Launch Type（Fargate/EC2）より柔軟で、現在の推奨方式。</li>
<li>Capacity Storategy: <code>FARGATE</code> / <code>FARGATE_SPOT</code> / <code>EC2（ASG）</code> のタスク配分</li>
</ul>
<p>ECS クラスタ</p>
<ul>
<li>タスク実行環境の論理スコープ。VPC と実行環境設定 (Launch Type/CP) を設定。</li>
<li>クラスタごとに1つ以上の CP が登録できる (FARGATE CP &amp; EC2 CP)</li>
<li>Fargate であってもコンテナは VPC 内リソース。クラスタ作成時に VPC を設定する。</li>
</ul>
<p>ECS エージェント</p>
<ul>
<li>コンテナインスタンス (EC2) で起動するデーモン。ECS API のやり取りを行う。Fargate では意識不要。</li>
<li><strong>コンテナインスタンスロール</strong>が適用される。<ul>
<li>ECS クラスターの EC2 インスタンスのインスタンスロールのこと。</li>
<li>ECS API 系だけでなく、ECR の <code>ecr::GetAuthorizationToken</code> 権限も指定。</li>
<li>ただし、実際の pull はタスク実行ロールでコンテナランタイムが実施。</li>
</ul>
</li>
</ul>
<p>ECS エージェントの問題例: イメージを更新してタスクを再起動してもコンテナが更新されない場合がある</p>
<ul>
<li>正しく起動しているコンテナもあるので、クラスターインスタンスの ECS エージェントの異常が原因と考えられる。</li>
<li><img alt="" src="_attachment/image_655.png" /></li>
</ul>
<h2 id="taskdefinition">TaskDefinition</h2>
<p><img alt="" src="_attachment/image_656.png" /></p>
<p>family</p>
<ul>
<li>タスク定義の名前。family + revision でタスク定義を特定する。</li>
<li>タスク定義はイミュータブルなので、タスク定義更新時は新しい revision を作成する必要がある。</li>
</ul>
<p>タスクロール: taskRoleArn</p>
<ul>
<li>コンテナ内のアプリケーションに割り当てるロール。</li>
<li>ECS タスク ("ecs-tasks.amazonaws.com") に AssumeRole を許可する信頼ポリシーをもつロールを作成。</li>
<li>設定すると ECS Agent により AWS_CONTAINER_CREDENTIALS_RELATIVE_URI という環境変数が設定され、コンテナ内の SDK/CLI はこの環境変数があるとそちらからクリデンシャルを取得する。</li>
</ul>
<p>タスク実行ロール: executionRoleArn</p>
<ul>
<li>コンテナランタイムに使用されるロール。TaskDefinition に記載する諸々の処理に必要な権限。</li>
<li>コンテナイメージのプル、コンテナログの CloudWatch Logs への書き込み (ref. awslogs ロギングドライバ)、Secrets Manager/Systems Manager へのアクセス許可。</li>
</ul>
<p>networkMode</p>
<ul>
<li><img alt="" src="_attachment/image_657.png" /></li>
</ul>
<p>containerDefinitions</p>
<ul>
<li>各コンテナの定義 (containerDefinition) のリスト。</li>
<li>イメージや portMappings 等、docker run に指定するパラメータとなる。</li>
<li>memory/memoryReservation<ul>
<li>各コンテナのメモリ上限・予約指定 (オプショナル)</li>
<li>タスクサイズ (cpu/memory) がタスク全体の割り当てサイズを指定。</li>
</ul>
</li>
<li>環境変数の設定<ul>
<li>environment</li>
<li>secrets<ul>
<li>ASM/SSM Parameter Store のパラメータ名の ARN で参照。</li>
<li>タスク実行ロールでアクセス権が必要。</li>
</ul>
</li>
</ul>
</li>
<li>logConfiguration<ul>
<li>docker run --log-driver オプションの指定。</li>
<li>"awslogs" で CloudWatch にログを送れる。</li>
<li>問題例: ECS (ALB 使用) のログを取得する</li>
<li>Create the required IAM Policy and attach it to the ecsInstanceRole. Install the Amazon CloudWatch Logs agent on the Amazon ECS instances. Use the awslogs Log Driver in the Amazon ECS task definition.</li>
<li>Capture detailed information about requests sent to your load balancer by enabling access logging on the Application Load Balancer. Configure it to store the logs to the S3 bucket.</li>
</ul>
</li>
</ul>
<p>Task Definition の実行</p>
<ul>
<li>Task Definition を直接実行する run-task と、Service で指定数のタスク起動を維持する方法の2つがある。</li>
<li>Task Definition は EventBridge からも実行できる</li>
</ul>
<h2 id="service">Service</h2>
<p>Service は ECS Cluster 内に作成し、起動する Task Definition とタスク数等を指定する。</p>
<p>基本指定項目</p>
<ul>
<li>タスク定義: family &amp; revision</li>
<li>クラスター</li>
<li>サービス名</li>
<li>サービスタイプ<ul>
<li>REPLICA</li>
<li>DAEMON: インスタンス数と同じ数のタスクを実行する</li>
</ul>
</li>
<li>タスク数 (desired)</li>
<li>最小ヘルス率 (min)</li>
<li>最大率 (max)</li>
</ul>
<p>デプロイメントタイプ</p>
<ul>
<li>ローリングアップデート<ul>
<li>サービスのタスク定義を更新すると ECS がローリングデプロイを実施。</li>
</ul>
</li>
<li>Blue/Green<ul>
<li>CodeDeploy を使用。CodeDeploy アプリケーションが自動的に作成されう。</li>
</ul>
</li>
</ul>
<p>ネットワーク</p>
<ul>
<li>Fargate の場合 awsvpc ネットワークモードとし、コンテナが接続する VPC/サブネット(=AZ)、SG を指定する。</li>
</ul>
<p>ELB 連携</p>
<ul>
<li>起動したコンテナが ELB ターゲットグループに追加される。</li>
<li>インバウンド接続されるサーバを立てる場合には必須。</li>
<li>ALB, NLB, CLB を選択可能。</li>
<li>リスナールールの追加とその宛先ターゲットグループの設定を行う。<ul>
<li>タスク内に複数コンテナがあってもタスクからの外部公開ポートは1つという前提？</li>
<li>Service 毎にターゲットグループは1つの模様。CodeDeploy の AppSpec でも containerPort を1つしか指定できない。</li>
</ul>
</li>
</ul>
<p><img alt="" src="_attachment/image_658.png" /></p>
<p>動的ポートマッピングを ALB で使用するため、TaskDefinition のポートマッピング定義でホストポートを 0 (ANY) に設定することで動的にポートがアサインされる。</p>
<pre><code>      &quot;portMappings&quot;: [
        {
          &quot;hostPort&quot;: 0,
          &quot;protocol&quot;: &quot;tcp&quot;,
          &quot;containerPort&quot;: 80
        }
      ],
</code></pre>
<p>クラスタの EC2 インスタンスのセキュリティグループで、ALB にアサインしたセキュリティグループからの全トラフィックの接続を許可する。</p>
<p>ECS Service Auto Scaling</p>
<ul>
<li>平均 CPU 使用率などのメトリクスで Auto Scaling で Service の維持タスク数を増減する。</li>
<li>EC2 クラスタの場合、EC2 インスタンスも自動で増える訳でないので自前で EC2 Auto Scaling も調整する必要がある。(Beanstalk の Docker ECS を使うと両方のスケーリングを設定してくれる)</li>
</ul>
<p>forceNewDeployment</p>
<ul>
<li>UpdateService API のオプション</li>
<li>latest タグのレポジトリのイメージが更新されていた場合に、サービス更新しても新しいバージョンはデプロイされないが、このオプションを指定することで新しいイメージがデプロイされる。</li>
</ul>
<pre><code>aws ecs update-service --force-new-deployment --service store-prd --task-definition task-store-prd
</code></pre>
<p>タスク配置</p>
<p><img alt="" src="_attachment/image_659.png" /></p>
<ul>
<li>例: ポートマッピングでホストのポートを占有するタスクを複数個起動するには、その個数分のインスタンスが必要。</li>
<li>binpack<ul>
<li>コンテナをホスト集中することでコストを最適化</li>
<li>使用中のコンテナインスタンスの数を最小限に抑え、未使用の CPU またはメモリを最小に。</li>
</ul>
</li>
<li>spread<ul>
<li>均等配置。(instanceId または attribute:ecs.availability-zone)</li>
</ul>
</li>
</ul>
<h1 id="fargate">Fargate</h1>
<ul>
<li>ボリュームは TaskDefinition の cpu/memory で指定。</li>
</ul>
<p>Fargate のストレージ</p>
<ul>
<li>レイヤストレージ ... コンテナ毎に独立。</li>
<li>ボリュームストレージ ... コンテナ間で共有。タスク定義でマウントを指定する。</li>
<li>どちらも揮発性でタスク停止で消去される。</li>
</ul>
<p>awsvpc ネットワークモード</p>
<ul>
<li>タスク毎に ENI が割り当てられ、VPC に接続される。</li>
<li>タスク毎にセキュリティグループを指定できる。</li>
</ul>
<h1 id="ecr">ECR</h1>
<p>プライベートなコンテナイメージレポジトリ。 IAM ポリシーでアクセス制御できる。</p>
<p>認証情報の取得</p>
<ul>
<li>docker login でレポジトリにログインにする際の認証情報。</li>
<li><code>aws ecr get-login-password</code> (AWS CLI v2 )<ul>
<li>パスワードだけ吐き出す</li>
</ul>
</li>
</ul>
<pre><code>aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin
</code></pre>
<ul>
<li><code>aws ecr get-login</code> (AWS CLI v1)<ul>
<li><code>docker login -u AWS -p &lt;password&gt; -e none &lt;ecr_server&gt;</code> コマンド全体を吐き出す。</li>
</ul>
</li>
</ul>
<h1 id="app-mesh">App Mesh</h1>
<p>サービスメッシュによるコンテナの連携のマネージドサービス</p>
<p><img alt="" src="_attachment/image_660.png" /></p>
<hr />
<h1 id="serverless">Serverless</h1>
<p>Ref.
- <a href="References/AWS%20DVA%20-%20Lambda,%20API%20Gateway,%20SAM,%20AppSync.html">AWS DVA - Lambda, API Gateway, SAM, AppSync</a>
- <a href="References/AWS%20-%20Security%20-%20API%20Gateway,%20Lambda.html">AWS - Security - API Gateway, Lambda</a></p>
<p>API Gateway+Lambda で serverless API 構築</p>
<h1 id="lambda">Lambda</h1>
<p>忘れがちなユースケース</p>
<ul>
<li>ALB のターゲット: API Gateway 使わなくても HTTP インターフェース付与できる</li>
<li>CloudWatch Logs サブスクリプションフィルター</li>
<li>DynamoDB ストリーム</li>
</ul>
<p>タイムアウト</p>
<ul>
<li>デフォルト 3 秒。最大 15 分 (900 秒)</li>
</ul>
<p>実行ロール</p>
<p>同時実行数 (上限緩和申請可能)</p>
<ul>
<li>1000 (リージョンごと)</li>
<li>予約同時実行数: Reserved concurrency<ul>
<li>全体の同時実行数から特定の関数に予約する。</li>
</ul>
</li>
<li>プロビジョニング済み同時実行数: Provisioned concurrency<ul>
<li>スケールアップ時のレイテンシーを下げるためあらかじめコンテナがプロビジョンされる。</li>
<li>AWS Auto Scaling でプロビジョニングされた同時実行数をスケーリングすることもできる。</li>
</ul>
</li>
</ul>
<p>バージョン</p>
<ul>
<li>関数の公開時に「バージョン」を発行する。</li>
<li>バージョンはイミュータブル。$LATEST でコード・設定を変更して新たなバージョンを発行。</li>
</ul>
<p>エイリアス</p>
<ul>
<li>特定バージョンへのポインタ。ロールバックも可能。</li>
</ul>
<p>加重エイリアス</p>
<ul>
<li>２つのバージョンに比率指定でエイリアスを紐づけられる (Blue/Green)</li>
<li>routing-config</li>
</ul>
<p>環境変数</p>
<ul>
<li>すべての環境変数の合計サイズ(キーと値を合わせて)は 4KB まで。</li>
<li>DB のキー等の受け渡しは Secrets Manager 推奨。</li>
</ul>
<p>環境変数の暗号化</p>
<ul>
<li>保管時はデフォルトで AWS managed CMK で暗号化。関数が呼び出されると復号される。</li>
<li>伝送中の暗号化のためのヘルパー:<ul>
<li>管理コンソールで登録時にブラウザ側 KMS Encrypt で環境変数を暗号化。</li>
</ul>
</li>
</ul>
<p>呼び出しタイプ</p>
<ul>
<li>同期</li>
<li>非同期 (イベント)</li>
<li>ストリームベース (Pull モデル): DynamoDB Streams, Kinesis Data Streams, SQS<ul>
<li>内部的な Lambda 関数が自動にできてポーリング。</li>
<li>Lambda 実行ロールにイベントソースを読み込む権限が必要。</li>
</ul>
</li>
</ul>
<p>Lambda Layers</p>
<ul>
<li>ライブラリ的な ZIP ファイル。カスタムランタイムの本体も Layer に含められる。</li>
<li>1 つの関数で使用できる Layers は 5 つまで。</li>
<li>関数と全 Layers の合計サイズは、パッケージの解凍後サイズ制限の 250 MB まで。</li>
<li>レイヤーも関数同様にバージョンを持つ。</li>
</ul>
<p>VPC lambda</p>
<ul>
<li>関数から VPC 内の ENI にアタッチ。SG とサブネットを指定。</li>
<li>パブリック IP は割り当てられない (=IGW でパブリック IP への NAT が登録されない)</li>
<li>インターネットアクセスには NAT GW 必要。</li>
</ul>
<h1 id="api-gateway">API Gateway</h1>
<p>API エンドポイント = API の URL のこと。</p>
<ul>
<li>形式: {api-id}.execute-api.{region}.amazonaws.com</li>
</ul>
<p>リージョン API エンドポイント (デフォルト)</p>
<p>エッジ最適化 API エンドポイント:</p>
<ul>
<li>CloudFront に API エンドポイントをデプロイ。地理的に分散したアクセスのレイテンシー改善。</li>
</ul>
<p>プライベート API エンドポイント:</p>
<ul>
<li>インターフェイス VPC エンドポイント (AWS PrivateLink) としてデプロイ。</li>
</ul>
<p>統合バックエンド</p>
<ul>
<li>Lambda, AWSサービス, VPCリンク, HTTP, Mock</li>
</ul>
<p>CORS</p>
<ul>
<li>リソース (URL path) 単位で CORS を有効にできる。</li>
</ul>
<p>ステージ</p>
<ul>
<li>prod, staging, dev 等。エンドポイントのパスの一部に含まれる。<ul>
<li>https://{api-id}.execute-api.{region}.amazonaws.com/{stage}</li>
</ul>
</li>
<li>ステージへの「デプロイ」を行わない限り API は有効にならない。</li>
<li>ステージ変数: ${stageVariables} から参照できるステージ毎に異なる変数。</li>
</ul>
<p>オーソライザー: 認証・認可 </p>
<ul>
<li>IAM アクセス権限<ul>
<li>AWS 署名v4 認証。</li>
</ul>
</li>
<li>Cognito オーソライザー<ul>
<li>Cognito ユーザープールで認証して取得したトークン (JWT) を Authorization ヘッダで送信。</li>
</ul>
</li>
<li>JWT オーソライザー<ul>
<li>HTTP API のみサポート。</li>
<li>OpenID Connect/OAuth 2.0 準拠の IdP が発行した JWT による認証 (Cognito ユーザープール含む)</li>
</ul>
</li>
<li>Lambda オーソライザー<ul>
<li>カスタムのオーソライザー</li>
</ul>
</li>
</ul>
<p>リソースポリシー</p>
<ul>
<li>API Gateway のリソースベースポリシー。IAM ポリシーと併用できる。</li>
<li>呼び出し元のプリンシパル(IAM アカウント/ロール)、IP アドレス(範囲/CIDR)、VPC を指定。</li>
</ul>
<p>カナリアリリース</p>
<ul>
<li>指定した比率で特別なステージ「Canary」にリクエストを流せる。</li>
<li>Canary はステージ毎に有効化できる。</li>
<li>Canary はメインのステージに「昇格」できる。(Promote Canary)</li>
</ul>
<p>セキュリティ</p>
<ul>
<li>プライベート API エンドポイントとする。</li>
<li>AWS Shield で DDoS 対策されている。</li>
<li>WAF をステージに設定できる。</li>
<li>CloudFront レイヤーで Shield/WAF を設置。</li>
<li>「カスタムドメイン」の証明書設定<ul>
<li>ACM で証明書を管理できる。</li>
<li>ドメイン自体は Route53 等で API エンドポイントへ CNAME 登録</li>
</ul>
</li>
</ul>
<h1 id="aws-sam-serverless-application-model">AWS SAM (Serverless Application Model)</h1>
<p>SAM テンプレートで CloudFormation テンプレートより簡潔に次のリソースを定義できる:</p>
<ul>
<li>API Gateway, Lambda, DynamoDB, Step Functions </li>
<li>CloudFormation がサポートする全てのリソースも指定できる。</li>
</ul>
<p><img alt="" src="_attachment/image_661.png" /></p>
<ul>
<li>AWS::Serverless::Application: Nested Stack にあたる機能。<ul>
<li>SAM テンプレートの置き場所の URI か Serverless Application Repository の ARN を指定。</li>
</ul>
</li>
<li>AWS::Serverless::StateMachine: Step Functions</li>
</ul>
<p>CodeDeploy が組み込まれており Lambda の Blue/Green デプロイメントの指定ができる:</p>
<pre><code>MyLambdaFunction:
  Type: AWS::Serverless::Function
  Properties:
    Handler: index.handler
    Runtime: nodejs12.x
    CodeUri: s3://bucket/code.zip

    AutoPublishAlias: prod

    DeploymentPreference:
      Type: Canary10Percent10Minutes
      Alarms:
        # A list of alarms that you want to monitor
        - !Ref AliasErrorMetricGreaterThanZeroAlarm
        - !Ref LatestVersionErrorMetricGreaterThanZeroAlarm
      Hooks:
        # Validation Lambda functions that are run before &amp; after traffic shifting
        PreTraffic: !Ref PreTrafficLambdaFunction
        PostTraffic: !Ref PostTrafficLambdaFunction
</code></pre>
<p>AutoPublishAlias プロパティ</p>
<ul>
<li>Lambda のエイリアス名を指定する。</li>
<li>デプロイ時に関数が更新されていると自動的に関数バージョンを上げてそのエイリアスに紐づけてくれる。</li>
</ul>
<p>DeploymentPreference プロパティ</p>
<ul>
<li>デプロイタイプ (Canary10Percent10Minutes 等)</li>
<li>Pre-traffic / Post-traffic テストの Lambda 関数</li>
<li>CloudWatch alarms 監視と自動ロールバック</li>
</ul>
<h1 id="dynamodb">DynamoDB</h1>
<p>Ref.<a href="References/AWS%20DVA%20-%20S3,%20DynamoDB,%20ElastiCache,%20and%20other%20storage%20services.html">AWS DVA - S3, DynamoDB, ElastiCache, and other storage services</a></p>
<p>DynamoDB は台帳 (テーブル) を各プライマリーキーごとにページ (パーティション) にまとめて管理するようなイメージ
- プライマリキーで特定されるページに、ソートーキーで特定されるレコードが表に記録される感じ。</p>
<p>パーティションキー(ハッシュ属性)</p>
<ul>
<li>テーブル内でユニーク。</li>
</ul>
<p>ソートキー(範囲属性)</p>
<ul>
<li>複合プライマリキー=パーティションキー + ソートキー</li>
<li>同じパーティションキーに対してレコードを一意に識別するソートキー。</li>
<li>ソートキーにより項目がパーティション内でソートされ、範囲検索やタイムスタンプなら時系列検索が可能。</li>
<li>パーティションキーの値が同じ項目は同じパーティションに保存される。</li>
</ul>
<p><img alt="" src="_attachment/image_662.png" /></p>
<p>セカンダリインデックス</p>
<ul>
<li>プライマリキー以外の属性(代替キー)でクエリしたい場合に作る検索用テーブル。</li>
<li>作成時にはベーステーブルからインデックスにコピー (射影: Projection) する属性も指定する。</li>
</ul>
<p>ローカルセカンダリインデックス (LSI)</p>
<ul>
<li>ソートキーが複数必要な場合に利用する。追加のソートキーに対してパーティション内に作成されるインデックス。</li>
<li>テーブル作成時のみ作成でき、あとから追加・削除できない。</li>
</ul>
<p>グローバルセカンダリインデックス: GSI</p>
<ul>
<li>異なるプライマリキーで検索したい場合に使用するインデックス。</li>
<li>異なるプライマリキーで作った別テーブルにレプリケーションする仕組み。</li>
<li>後から作成・削除することも可能。</li>
<li>読み込みは結果整合性のみ</li>
</ul>
<p>問題例</p>
<ul>
<li>The table has an attribute of <em>DocumentName</em> that acts as the partition key and another attribute called <em>Category</em> as its sort key.</li>
<li>A DevOps Engineer was instructed to develop a feature that queries the <em>DocumentName</em> attribute yet uses a different sort key other than the existing one.</li>
<li>To fetch the latest data, strong read consistency must be used in the database tier.</li>
</ul>
<p>解答</p>
<ul>
<li>Set up a new DynamoDB table with a Local Secondary Index that uses the DocumentName attribute with a different sort key. Migrate the data from the existing table to the new table.</li>
</ul>
<p>誤答</p>
<ul>
<li>Add a Global Secondary Index that uses the DocumentName attribute and a different sort key<ul>
<li>is incorrect. Although it is possible to query data without using a scan command, it is still not enough because GSI does not support strong read consistency which is required in the scenario.</li>
</ul>
</li>
</ul>
<p>プロビジョンド型キャパシティモード</p>
<ul>
<li>テーブルに 1秒あたりの RCU/WCU を設定する。</li>
<li>RCU: 4KB単位: 結果整合性 2回/強い整合性 1回</li>
<li>WCU: 1KB単位: 結果整合性</li>
<li>実際の読み書きの有無に関わらず、設定したキャパシティにより課金が発生。</li>
<li>AWS Auto Scaling でスケーリング可能。</li>
<li>高負荷で一定量ならオンデマンドより安い</li>
</ul>
<p>オンデマンド型キャパシティーモード</p>
<ul>
<li>キャパシティを設定せず、読み書きに応じて自動スケール。発生したリクエストによる従量課金。</li>
<li>低トラフィックならプロビジョンドより安い</li>
</ul>
<p>DynamoDB ストリーム</p>
<ul>
<li>テーブルに行われた過去 24時間の追加・更新・削除の履歴を保持したシャード。</li>
<li>ほぼリアルタイム。WCU の２倍のスループットなのでスループットの問題はない。</li>
<li>データはシリアライズされ、特定パーティションキーへの変更は順序通りに取得可能。</li>
<li>Lambda 連携<ul>
<li>ストリーム型 (イベントソースマッピング)</li>
<li>DynamoDB ストリームの1つのシャードに 3つ以上のリーダーが同時に読み取るとスロットリングが発生する。3つ以上の Lambda を連携させる場合は1つの Lambda から SNS で分岐する。</li>
<li>DynamoDB ストリームを Lambda 連携で OpenSearch に投入し DynamoDB テーブルのデータを全文検索するユースケースがあった。</li>
</ul>
</li>
<li>KCL (Kinesis Client Library) を利用したアプリ開発<ul>
<li>KCL に DynamoDB Streams Kinesis Adapter を噛ませることで、DynamoDB ストリームに対して KCL を使用できる。</li>
<li>Lambda のスロットリングエラーに対し、KCL を利用したアプリケーション経由で Kinesis Data Analytics につないで分析処理を行う構成に変更するという問題があった。</li>
</ul>
</li>
</ul>
<p>バックアップ</p>
<ul>
<li>オンデマンドバックアップ<ul>
<li>テーブル全体のスナップショットを作成してアーカイブ。</li>
</ul>
</li>
<li>ポイントインタイムリカバリー<ul>
<li>直前 35日間の任意の時点にダウンタイムなしに復元可能。増分バックアップ。</li>
<li>ポイントインタイムリカバリーの「有効化」で有効にする。(デフォルト無効)</li>
</ul>
</li>
</ul>
<p>グローバルテーブル</p>
<ul>
<li>DynamoDB ストリームを利用したマルチリージョン・マルチマスターのレプリケーション。</li>
<li>レプリカテーブル<ul>
<li>リージョン毎にレプリケーションを受けるレプリカテーブルを作成する必要がある。</li>
<li>同一アカウントのみ。</li>
</ul>
</li>
<li>ディザスタリカバリ / 近いリージョンのレプリカにアクセスすることでレイテンシー削減。</li>
</ul>
<p>DAX: DynamoDB Accelerator</p>
<ul>
<li>VPC 内に配置される DynamoDB のインメモリキャッシュ。</li>
<li>EC2, Beanstalk, ECS 等からの read アクセスのスループット向上。</li>
<li>マイクロミリ秒のレイテンシ。通常の一桁ミリ秒のレイテンシが問題になる場合。</li>
<li>DynamoDB API 互換。コード改修少なく移行。</li>
</ul>
<p>TTL 機能</p>
<ul>
<li>テーブル内の項目を自動削除する TTL を設定できる。</li>
<li>TTL を指定する属性名をテーブルに設定して、項目にその属性を含める。</li>
</ul>
<p>問題例: アーカイブして 60日を過ぎたデータを削除するには</p>
<ul>
<li>テーブルで TTL を有効にする。60 日後のタイムスタンプを保持する属性を TTL 属性にする。</li>
<li>テーブルの DynamoDB Streams を有効にし、Lambda 関数でレコードを Kinesis Data Firehose 配信ストリームに配信する。</li>
<li>Kinesis Data Firehose 配信ストリームを作成して S3 バケットにデータをロードする。バケットにライフサイクルポリシーを設定しゼロ (0) 日後にデータを S3 Glacier Deep Archive にアーカイブする。</li>
</ul>
<p>Query API</p>
<ul>
<li>テーブル/インデックスからキーを指定してデータを取得する。</li>
<li>KeyConditionExpression: 取得する項目のキーを指定する条件式。</li>
<li>ProjectionExpression: 取得する属性をカンマで区切りで指定。指定しない場合は全属性が返される。</li>
<li>FilterExpression: クエリでローカルに取得されたデータをキー属性以外でさらにフィルタする条件式。</li>
<li>テーブル側でキーで検索し、ローカル側 (オンメモリ) で属性でフィルタする。</li>
</ul>
<p>Scan API</p>
<ul>
<li>テーブル/インデックスの全項目を取得して FilterExpression でローカルでフィルタ。非効率。</li>
<li>インデックスのない属性の特定の値の項目を取得するにはこの方法が必要になる。</li>
</ul>
<p>BatchGetItem/BatchWriteItem</p>
<ul>
<li>複数テーブルの複数項目の読み込み・書き込み処理のバッチ実行。</li>
<li>スループット向上。個々にコールすると RCU/WCU 使って無駄。</li>
<li>スレッド作らなくても並列処理してくれる。</li>
</ul>
<h1 id="step-functions">Step Functions</h1>
<p>Ref.<a href="References/AWS%20DVA%20-%20SQS,%20SNS,%20Step%20Functions.html">AWS DVA - SQS, SNS, Step Functions</a></p>
<p>ステートマシン</p>
<ul>
<li>
<p>実行方法</p>
<ol>
<li>コンソール・AWS CLI・SDK による実行 (StartExecution)</li>
<li>API Gateway: 統合バックエンドとして登録</li>
<li>CloudWatch Events: S3 の保存や EC2 起動を契機</li>
</ol>
</li>
<li>
<p>最大実行時間は 1年。</p>
</li>
</ul>
<p>呼び出し可能なサービス</p>
<ul>
<li>関数実行<ul>
<li>Lambda</li>
</ul>
</li>
<li>バッチジョブ系<ul>
<li>ECS : ECS タスク実行</li>
<li>AWS Batch : ジョブの起動、ジョブ完了の待機</li>
<li>Glue : ジョブの実行</li>
<li>SageMaker : トレーニングジョブ、トランスフォームジョブの起動</li>
</ul>
</li>
<li>レコード投入<ul>
<li>DynamoDB : アイテム取得、新規アイテム登録 </li>
<li>SNS : トピックへのメッセージ送信</li>
<li>SQS : キューへのメッセージ送信</li>
</ul>
</li>
<li>その他<ul>
<li>Activity: 自前のアプリケーションによる非同期コールバック</li>
<li>SDK サービス統合: 対応サービスの任意の API を実行</li>
<li><a href="https://docs.aws.amazon.com/step-functions/latest/dg/supported-services-awssdk.html">https://docs.aws.amazon.com/step-functions/latest/dg/supported-services-awssdk.html</a></li>
</ul>
</li>
</ul>
<h1 id="sns">SNS</h1>
<p>パブリッシャ</p>
<ul>
<li>Code シリーズの通知ルール</li>
<li>CodePipeline 承認アクション</li>
<li>S3 イベント:  SNS, SQS, Lambda。</li>
<li>CloudWatch アラーム: SNS, Auto Scaling, EC2 アクション。</li>
</ul>
<p>サブスクライバ</p>
<ul>
<li>Lambda, SQS, HTTP(S)</li>
<li>Email, SMS/モバイルプッシュ, Chatbot</li>
</ul>
<p>Fanout パターン</p>
<ul>
<li>SNS → SQS 連携による並列処理</li>
</ul>
<p><img alt="" src="_attachment/image_663.png" /></p>
<ul>
<li>複数の SQS キューを SNS トピックにサブスクライブさせることで１つのメッセージを並列処理。</li>
<li><strong>Lambda を直接サブスクライバにせず間に SQS を入れるのは非同期化のため。Lambda 処理の先がダウンしてもキューにデータが残っているので復旧後に処理できるため。</strong></li>
</ul>
<p>Amazon SES: Simple Email Service</p>
<p>メール配信</p>
<ul>
<li>REST API (HTTP)</li>
<li>SMTP エンドポイント</li>
</ul>
<p>メールの保管・処理</p>
<ul>
<li>S3 バケットに保存。</li>
<li>特定キーワードを含む場合に SNS のトピックにパブリッシュ。</li>
<li>Lambda 呼び出し。</li>
</ul>
<h2 id="cognito">Cognito</h2>
<table>
<thead>
<tr>
<th>Service</th>
<th>User Identity</th>
<th>Credential</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID プール</td>
<td>Cognito ID</td>
<td>STS 一時クリデンシャル</td>
</tr>
<tr>
<td>ユーザプール</td>
<td>ユーザディレクトリのユーザID</td>
<td>API トークン (JWT)</td>
</tr>
</tbody>
</table>
<p>Ref. SAML/OIDC</p>
<p>認証(=SSO)と認可のプロトコル。どちらもブラウザリダイレクトと公開鍵によるトークンの認証をベースにしている。</p>
<ul>
<li>
<p>SAML（Security Assertion Markup Language）</p>
<ul>
<li>主にエンタープライズ向け</li>
<li>IdP と SP で信頼関係を事前に構築</li>
<li>XMLベースのフォーマットを使って認証情報をやり取り</li>
</ul>
</li>
<li>
<p>OIDC (OpenID Connect)</p>
<ul>
<li>OAuth 2.0ベース、JSONベースのトークンを使う</li>
<li>RP から IdP にリダイレクトして認証依頼。</li>
<li>RP に利用許可する属性を IdP でのサインイン時に表示される同意画面でユーザが許諾。</li>
<li>認証後に IdP が JWT を発行、RP は IdP の公開鍵で JWT のシグネチャを検証する。</li>
</ul>
</li>
</ul>
<h3 id="cognito-id">Cognito ID プール</h3>
<ul>
<li>外部 IdP で認証されたアプリに一時クリデンシャルで AWS サービスの利用を許可する。</li>
<li>ID プールは渡された外部 IdP のトークンを検証し一時クリデンシャルを発行する。(AWS が RP の役割)<ul>
<li>STS ID フェデレーションの置き換え。</li>
</ul>
</li>
<li>OIDC側のユーザをAWSの特定のIAMロールにマッピングするためのルールを設定<ul>
<li>トークンのクレーム（subやaudなど）に基づいて、どのユーザーグループや条件がどのIAMロールを引き受けるかを定義</li>
</ul>
</li>
<li>未認証 ID (ゲスト) のサポート: ルールにあてはまらないユーザに対すロールを設定</li>
</ul>
<h3 id="cognito_1">Cognito ユーザープール</h3>
<p>認証とユーザデータベースの管理。JWT を発行する OIDC IdP のマネージドサービス。</p>
<ul>
<li>Webアプリ、モバイルアプリを認証して API キーを発行する。</li>
<li>API Gateway, ALB, AppSync へのアクセスに認証を追加できる。</li>
<li>ソーシャルサインインや SAML(=ADFS), OIDC の IdP など複数の認証方法が併用できる。<ul>
<li>外部のOIDCプロバイダーでユーザが認証された後、その認証情報をユーザープール側に取り込むことができる</li>
</ul>
</li>
<li>アプリ内でログイン画面を実装するか、ユーザプールのログイン画面 (Hosted UI) を表示できる。</li>
<li>ユーザープールのトークンで ID プールから一時クリデンシャルを取得することもできる。</li>
<li>認証に MFA も利用できる。</li>
<li>アダプティブ認証: リスクレベルに応じて MFA を要求したりブロック・メール通知できる。</li>
</ul>
<h2 id="sts">STS</h2>
<p>GetSessionToken</p>
<ul>
<li>MFA-protected な API 呼び出しに使う一時的クリデンシャルを取得する。</li>
<li>すでに認証済のユーザから STS に MFA 認証を依頼し、一時クリデンシャルを取得</li>
</ul>
<p>GetFederationToken</p>
<ul>
<li>カスタム ID ブローカーに設定された IAM ユーザの一時クリデンシャルを取得する。</li>
<li>Deprecated: Cognito ID プールを利用する。</li>
</ul>
<p>AssumeRoleWithSAML</p>
<ul>
<li>SAML 2.0 対応の IdP からの認証情報でロールを引き受け。</li>
</ul>
<p>AssumeRoleWithWebIdentity</p>
<ul>
<li>Open ID Connect (OIDC) 互換 IdP からの認証情報でロールを引き受け。</li>
</ul>
<h2 id="aws-sso">AWS SSO</h2>
<p>SAML 2.0 IdP のマネージドサービス。</p>
<p>SAML 2.0 をサポートする 各種 SaaS の SP にシングルサインオン。</p>
<ul>
<li>Office 365, G-suite, Slack, Box, Salesforce</li>
</ul>
<p>ID ディレクトリ</p>
<ol>
<li>AWS SSO 組み込みディレクトリ</li>
<li>AWS Directory Service 統合</li>
<li>オンプレ AD 統合:<ul>
<li>AWS Managed Microsoft AD でオンプレ AD ドメインと信頼関係を構成</li>
<li>AWS Directory Service <strong>AD Connector</strong> によるログイン転送</li>
</ul>
</li>
</ol>
<h2 id="aws-directory-service">AWS Directory Service</h2>
<p>Simple AD</p>
<ul>
<li>Samba v4 の Active Directory Compatible Server のマネージドサービス。</li>
<li>ドメインの信頼関係の設定はできない。あくまで AWS 上でユーザを管理。</li>
</ul>
<p>AWS Managed Microsoft AD</p>
<ul>
<li>Windows Server 上の AD によるフル機能 AD のマネージドサービス。</li>
<li>オンプレ AD ドメインとの信頼関係の構成: オンプレのドメインアカウントで Windows インスタンスにログインできる</li>
</ul>
<p>AWS Directory Service AD Connector</p>
<ul>
<li>AWS 環境からオンプレのドメインコントローラに通信をリダイレクトするプロキシサービス。</li>
</ul>
<h2 id="ad">AD 連携</h2>
<p>Ref. ADFS (Active Directory Federation Services)</p>
<ul>
<li>SAML/OIDC 対応 IdP として AD ユーザを外部サービスで使うためのフェデレーション</li>
<li>ADユーザにロールを引き受けさせるのに使用する</li>
</ul>
<p>AWS 管理コンソールへの SSO</p>
<ul>
<li>ADFS と AWS サインインエンドポイントで SAML 認証により管理コンソールへ SSO。<ul>
<li>エンドポイントが背後で AssumeRoleWithSAML でクリデンシャルを取得。</li>
</ul>
</li>
<li>AWS 管理コンソールの IAM 設定で ID プロバイダとして ADFS を追加する。<ul>
<li>この際 AssumeRoleWithSAML を許可するロールを関連づける。</li>
</ul>
</li>
<li>ユーザが組織内の ADFS サインオンページをブラウズすることでフローが開始する。</li>
</ul>
<p>Cognito ユーザープールと ADFS の SAML 連携</p>
<p>API Gateway や ALB にドメインアカウントで認証が可能。</p>
<ol>
<li>SAML IdP で Cognito ユーザープールを Relying Party として設定。</li>
<li>Cognito ユーザープールに SAML IdP と属性マッピングを登録。</li>
<li>Hosted UI から ADFS にリダイレクトして認証。</li>
</ol>
<p>AWS Managed Microsoft AD</p>
<ul>
<li>オンプレ AD ドメインとの信頼関係を構成</li>
<li>オンプレのドメインアカウントで Windows インスタンスにログイン</li>
</ul>
<p>AWS Directory Service AD Connector</p>
<ul>
<li>VPC の Windows インスタンスに AD Connector をドメインコントローラとして登録。</li>
<li>オンプレの AD へ中継する。</li>
</ul>
<p>AWS SSO で各種 SaaS やサービスにドメインアカウントでサインオン</p>
<ul>
<li>SSO の ID ディレクトリから AD Connector でログイン転送する</li>
<li>SSO の ID ディレクトリとして AWS Managed Microsoft AD を使用、オンプレ AD ドメインと信頼関係を構成</li>
</ul>
<hr />
<h1 id="logging-monitoring">Logging &amp; Monitoring</h1>
<p><a href="AWS%20-%20Logging,%20Monitoring,%20X-Ray.html">AWS - Logging, Monitoring, X-Ray</a></p>
<h1 id="_4">ロギング</h1>
<table>
<thead>
<tr>
<th>種類</th>
<th>保管・送信先</th>
<th>備考</th>
</tr>
</thead>
<tbody>
<tr>
<td>CloudWatch Logs</td>
<td>ログストリーム,<br>S3(手動エクスポート)</td>
<td>スケジュール実行の Lambda による Export API 実行や、サブスクリプションフィルター+Firehose で S3 への保存の自動化が可能。</td>
</tr>
<tr>
<td>CloudTrail</td>
<td>S3 (証跡),<br>CloudWatch Logs (オプショナル)</td>
<td></td>
</tr>
<tr>
<td>VPC Flow Logs</td>
<td>S3, CloudWatch Logs</td>
<td>VPC 内のトラフィックログ。取得は ENI で行われる</td>
</tr>
<tr>
<td>DNS ログ</td>
<td>S3, CloudWatch Logs, Kinesis Data Firehose</td>
<td>Route 53, VPC Route53 Resolver の DNS クエリログ。<br>Route 53 は CloudWatch Logs のみ。</td>
</tr>
<tr>
<td>S3 サーバアクセスログ</td>
<td>S3</td>
<td></td>
</tr>
<tr>
<td>ELB アクセスログ</td>
<td>S3</td>
<td></td>
</tr>
<tr>
<td>API Gateway アクセスログ</td>
<td>CloudWatch Logs</td>
<td></td>
</tr>
<tr>
<td>Web ACL トラフィックログ</td>
<td>Kinesis Data Firehose,<br>S3, CloudWatch Logs</td>
<td></td>
</tr>
<tr>
<td>CloudFront アクセスログ</td>
<td>S3</td>
<td><br></td>
</tr>
</tbody>
</table>
<ul>
<li>S3, ELB, CloudFront アクセスログは S3 のみ</li>
</ul>
<p>アプリケーションログ</p>
<ul>
<li>EC2 インスタンス/ECS: CloudWatch Agent から CloudWatch Logs へ</li>
<li>Beanstalk</li>
</ul>
<h2 id="cloudtrail">CloudTrail</h2>
<p>CloudTrail で API 操作, サインイン試行をロギング。(デフォルト有効 90日間のイベント保持)</p>
<p>証跡</p>
<ul>
<li>ログを S3 バケットに保管。オプションで CloudWatch Logs に送信。<ul>
<li>管理イベント、データイベント、Insights イベントのチェックボックスがある</li>
</ul>
</li>
<li>ログは SSE-KMS とダイジェストファイルで保護される。</li>
<li>デフォルトでマルチリージョンのログを保存する証跡となる。</li>
<li>中央アカウントのバケットへマルチアカウントのログ統合。<ul>
<li>クロスアカウントで証跡を 1つの S3 バケットに配信できる。</li>
<li>Organizations の組織証跡なら個別に設定しなくても一括でできる。</li>
</ul>
</li>
</ul>
<p>連携: CloudWatch Events で CloudTrail をイベントソースとしたルールを使用。</p>
<p>CloudTrail Insights</p>
<ul>
<li>リソースを変更する API 操作の異常検知。</li>
</ul>
<h2 id="cloudwatch-logs">CloudWatch Logs</h2>
<p>Lambda やインスタンスのログ収集。</p>
<p>CloudWatch エージェントでサーバのログ収集。</p>
<p>CloudTrail, VPC フローログ, DNS ログ, Web ACL トラフィックログも収集できる。</p>
<p>保持期間: 1日～10年、無制限で指定可能。</p>
<p>ログ保管コストを下げるため、S3 へ手動エクスポート or サブスクリプションフィルタ+Firehose</p>
<p>サブスクリプションフィルタ</p>
<ul>
<li>Kinesis Data Streams/Firehose, Lambda によるリアルタイム処理。</li>
<li>ロググループに転送先とフィルタ文字列を設定する (全てのログの転送も可能)</li>
<li>クロスアカウントの送信先 (Destination) も設定できる。</li>
<li>ログアグリゲーションの例:<ul>
<li>中央アカウントで CloudWatch Logs の Destination を作成。(put-destination) この Destination のターゲットを S3 に投入する Kinesis Firehose とする。</li>
<li>リモートアカウントに PutSubscriptionFilter を許可するリソースベースポリシーを Destination に付与する。(put-destination-policy)</li>
<li>各アカウントでは中央アカウントの Destination をターゲットにサブスクリプションフィルターを作成する。(put-subscription-filter)</li>
</ul>
</li>
<li>問題例:<ul>
<li>中央アカウントでは Kinesis Data Streams から Lambda で ES にデータ投入。<ul>
<li>ちなみに Firehose を使えば ES に直接投入できるが Lambda で何か前処理している？</li>
<li>ここで Data Streams を立てずに直接 Lambda だけにするとスループット問題が発生しうる。</li>
</ul>
</li>
<li>各アカウントは VPC フローログを CloudWatch Logs で受け、さらにサブスクリプションフィルターで中央アカウントの Kinesis Data Streams  に送信。</li>
<li><img alt="" src="_attachment/image_664.png" /></li>
</ul>
</li>
</ul>
<p>メトリクスフィルタ</p>
<ul>
<li>ログからメトリクスを発生させて CloudWatch アラーム連携。</li>
</ul>
<p>CloudWatch Logs Insights</p>
<ul>
<li>ダッシュボードでログのクエリと可視化。</li>
</ul>
<h2 id="kinesis">ログの処理: Kinesis</h2>
<p>Kinesis でログのリアルタイム処理、および、S3, Redshift, Amazon ES 等に保管して分析。</p>
<p>プロデューサー</p>
<ul>
<li>Kinesis エージェント: サーバのログファイルを Kinesis に自動送信</li>
<li>CloudWatch Logs サブスクリプションフィルタ</li>
<li>Kinesis Producer Library (KPL) によるカスタム実装</li>
<li>Log4J, NiFi などのサードパーティー</li>
</ul>
<p>Data Stream</p>
<ul>
<li>EC2・Lambda でシャードのデータ処理・送信を行うコンシューマを実装。</li>
<li>実装には KCL: Kinesis  Consumer Library (Java) などを使う。</li>
<li>リアルタイム (200ms 程度のレイテンシー)</li>
<li>データ保持: デフォルト 24 時間、最大 1 年</li>
</ul>
<p>Data Firehose</p>
<ul>
<li>コンシューマ不要で S3, Redshift, ES, Splunk に送信。</li>
<li>バッファリング設定に基づきバッファリング・連結。S3 のスループットで足りない場合等。</li>
<li>バッチで非同期に呼ばれる Lambda 関数でデータ変換も可能。</li>
<li>ほぼリアルタイム (Min 60-sec latency)</li>
</ul>
<p>Data Analytics</p>
<ul>
<li>SQL によるリアルタイムのストリーム処理を Data Stream/Firehose に挿入。</li>
</ul>
<h2 id="athena-es">ログ分析: Athena, ES</h2>
<p>Athena</p>
<ul>
<li>S3 に保管されたログを SQL で分析。</li>
<li>AWS Glue が S3 バケットをクローリングしデータカタログを作成。</li>
<li>インメモリ BI ツール QuickSight 連携でダッシュボード表示も。</li>
<li>暗号化された S3 ログも分析可能。</li>
</ul>
<p>Amazon ES</p>
<ul>
<li>保管されたログを Kibana で全文検索・ダッシュボード表示。</li>
</ul>
<p>問題例:</p>
<ul>
<li>A DevOps Engineer is designing a service that aggregates clickstream data in real-time.</li>
<li>The service should identify and create sessions from real-time clickstream events with a feature to do an ad hoc analysis.</li>
</ul>
<p>解答</p>
<p>Kinesis Data Stream -&gt; Data Analytics -&gt; Lambda -&gt; Data Firehose -&gt; S3 -&gt; Glue Crawler -&gt; Athena</p>
<ul>
<li>Collect the real-time clickstream data using Amazon Kinesis Data Stream then build and analyze the sessions using Kinesis Data Analytics.</li>
<li>The aggregated analytics will trigger the real-time events on Lambda and then send them to Kinesis Data Firehose which in turn, sends data to an S3 bucket.</li>
<li>The clickstream data is ingested to a table by an AWS Glue crawler that will be used by Amazon Athena for running queries and ad hoc analysis.</li>
</ul>
<h1 id="_5">モニタリング</h1>
<p>CloudWatch メトリクス</p>
<ul>
<li>インスタンスの CPU 状態や Lambda のエラー回数などを監視。</li>
<li>メトリクスにしきい値を設定し、CloudWatch アラームを発生させる。</li>
<li>標準メトリクス<ul>
<li>AWS サービスのメトリクス。デフォルトは標準解像度(分単位)。</li>
</ul>
</li>
<li>カスタムメトリクス<ul>
<li>CloudWatch Agent や PutMetricData API で発行。</li>
<li>EC2 インスタンスのメモリ使用量、EBS ボリュームの残りサイズ等。</li>
<li>標準解像度(分単位) / 高解像度(秒単位) から選択できる。</li>
</ul>
</li>
<li>ダッシュボード: メトリクスのグラフや統計の表示。</li>
</ul>
<p>CloudWatch アラーム</p>
<ul>
<li>アラームから SNS 通知、EC2 アクション(停止・再起動等)、Auto Scaling 連携。</li>
<li>通知なので直接アクションをとることはできない:<ul>
<li>SNS 経由でメール送信や Lambda 関数コール</li>
<li>EventTrigger のデータソースにならない</li>
</ul>
</li>
<li>各状態への移行に SNS 通知を設定できる<ul>
<li>OK: しきい値以下</li>
<li>ALARM: しきい値超過</li>
<li>INSUFFICIENT_DATA: 開始直後やメトリクスが利用できないなどデータ不足の状態</li>
</ul>
</li>
<li>Anomaly detection<ul>
<li>特定の値でなく標準偏差の幅をしきい値に指定する</li>
</ul>
</li>
</ul>
<h2 id="cloudwatch-eventseventbridge">CloudWatch Events/EventBridge</h2>
<p>CloudTrail, AWS Config 等のイベントソースと、他の AWS サービスをターゲットを指定したルールを設定。</p>
<p>ルール:</p>
<ul>
<li>イベントソースとターゲットを指定したルール。</li>
<li>スケジュールの場合はイベントソースにスケジュール式 (rate, cron) を指定</li>
</ul>
<p>ターゲット</p>
<ul>
<li>ECS タスクや EC2 CreateSnapshot API をターゲットにできるとのこと</li>
</ul>
<p>Event Bus</p>
<ul>
<li>クロスアカウントでのイベント送信。各アカウントはデフォルトのイベントバスを 1 つ持つ。</li>
<li>送信側アカウント<ul>
<li>受信側のイベントバスをターゲットとしてルールを設定する。</li>
</ul>
</li>
<li>受信側アカウント<ul>
<li>イベントバスで送信側アカウント ID を許可する。</li>
<li>送信側アカウントからのイベントをイベントソースとしたルールを設定する。</li>
</ul>
</li>
<li>中央アカウントのイベントバスに各アカウントからイベント送信するように設定、中央アカウントで 特定のイベントを Lambda 監視する、等のユースケース。</li>
</ul>
<p>S3 イベントとの違い</p>
<ul>
<li>S3 イベントはバケットレベルオプションとして指定し、取得できるのはオブジェクトレベルのイベントだけ。</li>
<li>CloudWatch Event の S3 データソースは管理イベントとデータイベント (オブジェクトレベル) 両方のイベントを対象にできる。<ul>
<li>オブジェクトレベルイベントを取るには CloudTrail の証跡がデータイベントに対して有効になっている必要がある</li>
</ul>
</li>
<li>S3 イベントのターゲットは SNS, SQS, Lambda だけ。</li>
</ul>
<h2 id="x-ray">X-Ray</h2>
<p>サービスマップ</p>
<ul>
<li>リクエストを追跡することでが作成されるサービスのマップ</li>
<li>次のようなことが可能<ul>
<li>依存関係ツリーの可視化</li>
<li>複数 AZ やリージョンで実行しているときに発生するレイテンシーやエラーを検出</li>
<li>正常に実行されていないサービスの特定</li>
</ul>
</li>
</ul>
<p>トレース</p>
<ul>
<li>各回のリクエスト呼び出しのメトリクスによるコールトレース。</li>
</ul>
<p>X-Ray デーモン</p>
<ul>
<li>2000/udp でリッスンし、ローカルの SDK から受信したセグメントデータを X-Ray サービスに PutTraceSegments API でバッチでアップロードする。</li>
<li>EC2 の場合<ul>
<li>ユーザデータスクリプトで X-Ray デーモンを落としてきてインストール。</li>
</ul>
</li>
<li>ECS の場合<ul>
<li>X-Ray デーモンを実行するコンテナをタスク定義に含める (サイドカーコンテナ)。</li>
<li>ポートマッピングを設定して 2000/udp へのトラフィックをマップする。</li>
<li>問題例: ECS で X-Ray を利用する</li>
<li>解答<ul>
<li>Produce a Docker image that runs the X-Ray daemon.</li>
<li>Upload the image to a Docker image repository, and then deploy it to your Amazon ECS cluster.</li>
<li>Configure the network mode settings and port mappings in your task definition file to allow traffic on UDP port 2000.</li>
</ul>
</li>
</ul>
</li>
<li>Lambda の場合<ul>
<li>Lambda コンソールで AWS X-Ray のアクティブトレースを有効化。<ul>
<li>関数の実行ロールにポリシーが追加される。</li>
</ul>
</li>
<li>X-Ray デーモンは Lambda ランタイムで自動的に実行される。</li>
<li>X-Ray SDK を関数パッケージにバンドルしてコードから使用する。</li>
</ul>
</li>
</ul>
<h1 id="governance-devsecops">Governance, DevSecOps</h1>
<p>Ref.
- <a href="AWS%20-%20DevSecOps,%20Configuration%20Management.html">AWS - DevSecOps, Configuration Management</a>
- <a href="References/AWS%20-%20Security%20-%20IAM,%20STS,%20Organization.html">AWS - Security - IAM, STS, Organization</a>
- <a href="References/AWS%20-%20Security%20-%20Governance,%20Incident%20Response.html">AWS - Security - Governance, Incident Response</a>
- <a href="References/AWS%20-%20Security%20-%20CloudFormation,%20Service%20Catalog,%20Control%20Tower.html">AWS - Security - CloudFormation, Service Catalog, Control Tower</a></p>
<h1 id="aws-config">AWS Config</h1>
<p>AWS リソース構成のスナップショットと変更履歴をS3に保存</p>
<p>CloudWatch Events 連携</p>
<ul>
<li>リソース変更時や Config ルールの Noncompliant 発生時に SSM Automation 以外を行いたい場合。</li>
</ul>
<p>Config アグリゲータ</p>
<ul>
<li>マルチアカウント/マルチリージョンの集計結果を中央アカウントに集約。</li>
<li><img alt="" src="_attachment/image_667.png" /></li>
</ul>
<h3 id="aws-config-rules">AWS Config Rules</h3>
<p>ルールによるコンプライアンス違反の検出。</p>
<ul>
<li>AWS Config で取得したリソース設定が Lambda 関数に送られてルール評価が実施される</li>
<li>ルール評価後、対象リソースの状態が Compliant/Noncompliant に更新される。</li>
<li>トリガー: リソース作成/変更時、定期 (1~24時間で任意)</li>
</ul>
<p>マネージドルール</p>
<ul>
<li><img alt="" src="_attachment/image_665.png" /></li>
<li><img alt="" src="_attachment/image_666.png" /></li>
</ul>
<p>カスタムルール</p>
<ul>
<li>ユーザが Lambda で実装。リソースの設定項目が Lambda 関数に送られる。</li>
</ul>
<p>修復アクション</p>
<ul>
<li>特定ルールの Noncompliant 発生時に実行する SSM Automation ランブックを指定。</li>
</ul>
<p>問題例: CloudTrail が全アカウントで有効になっているのを確認し、修復する</p>
<p><img alt="" src="_attachment/image_668.png" /></p>
<ul>
<li>Config ルールはデフォルトでは修復機能を持たないので下段は不正解。</li>
<li>ちなみに cloudtrail-enabled ルールは "Configuration changes" には使用できず periodical にする必要があるとのこと。</li>
</ul>
<h1 id="systems-manager">Systems Manager</h1>
<h3 id="ssm">SSM エージェント</h3>
<ul>
<li>インスタンスに SSM エージェントをインストールして SSM コンソールから見えるマネージドインスタンスとなる。</li>
<li>SSM エンドポイントにアウトバウンドでポーリングするのでインターネットアクセスか VPC エンドポイントが必要。</li>
<li>オンプレインスタンス<ul>
<li>ロールに紐づけたアクティベーション ID/Code を発行して SSM Agent に指定する。</li>
<li>オンプレインスタンスには SSM コンソールからタグづけできる。</li>
<li>コンソール上で「mi-」(managed-instance) プレフィックスで表示される。</li>
</ul>
</li>
</ul>
<h3 id="_6">リソースグループ</h3>
<ul>
<li>AWS リソースのグループ化。(タグベースと CloudFormation スタックベース、同一リージョンのみ)</li>
<li>Run Command など一括で実行できるようになる。<ul>
<li>リソースグループにまとめた EC2/オンプレインスタンスにパッチマネージャーを適用する、等。</li>
</ul>
</li>
</ul>
<h3 id="run-commandautomation">Run Command/Automation</h3>
<p><strong>Run Command</strong></p>
<ul>
<li>指定したインスタンス群でコマンドドキュメントを実行。</li>
<li>コンソール出力は S3 や CloudWatch Logs にアウトプットするよう指定可能。</li>
<li>CodeBuild の CI でインスタンスにコマンド実行する際、buildspec で ssh せずに Run Command を使うべきという問題例:</li>
</ul>
<blockquote>
<p>CodeBuild プロジェクトに必要な権限を持つ IAM ロールを設定し、buildspec.yaml から AWS 認証情報を削除する。scp や ssh のコマンドは、AWS Systems Manager の Run Command を使用して実行する。</p>
</blockquote>
<p><strong>Automation</strong> (Runbook の実行)</p>
<ul>
<li>インスタンスや AWS リソースに Runbook で定義した処理を実行する。</li>
<li>Runbook の例:<ul>
<li><strong>AWS-UpdateLinuxAmi</strong>:  ベース AMI をインスタンス起動してアップデート実行後に新しい AMI を作成するまでの一連のステップを行う。</li>
<li><strong>AWSSupport-ExecuteEC2Rescue</strong>: ログ収集やメモリダンプなどのトラブルシューティングを行う EC2Rescure を実行する。</li>
</ul>
</li>
<li>SSM Automation は Codepipeline アクションと統合していないため、Invoke アクションの Lambda などを経由して呼び出す。</li>
</ul>
<h3 id="ssm_1">SSM メンテナンスウィンドウ</h3>
<ul>
<li>スケジュールを指定して Run Command や Automation などのアクションを実行。</li>
<li><img alt="" src="_attachment/image_670.png" /></li>
</ul>
<h3 id="ssm_2">SSM パッチマネージャー</h3>
<ul>
<li>マネージドインスタンスに対するパッチ適用の自動化</li>
<li>Scan のみ / Scan &amp; Install の2方式</li>
<li>パッチ準拠状況のレポート（コンプライアンス状態の可視化）</li>
<li>オンプレ/ハイブリッド環境にも対応（SSM Agent &amp; Hybrid Activation）</li>
<li>State Manager / Run Command と連携</li>
</ul>
<p><strong>Patch Baseline</strong></p>
<ul>
<li>パッチ適用ルール設定</li>
<li>分類（Security / Critical など）</li>
<li>例外パッチ指定（Allow / Reject）</li>
<li>適用延期日数指定</li>
<li>OS種類ごとに作成する</li>
<li>スケジュール実行にはメンテナンスウィンドウに Run Command タスクの AWS-RunPatchBaseline を登録する。</li>
</ul>
<p><strong>Patch Group</strong></p>
<ul>
<li>Patch Group タグにより対象インスタンスを分類</li>
<li>Patch Baseline と Patch Group を関連付け</li>
<li>異なる Patch Group タグに同じベースラインを指定することもできる。同じベースラインを別のリソースグループにメンテナスウインドウをずらして実行する、等。</li>
</ul>
<h3 id="ssm_3">SSM コンプライアンスダッシュボード</h3>
<ul>
<li>パッチマネージャーのスキャン結果等、リソースのコンプライアンス状態を表示するダッシュボード。</li>
</ul>
<h3 id="ssm_4">SSM インベントリ</h3>
<ul>
<li>インスタンス内の OS・アプリケーションのインベントリ情報の収集・可視化。</li>
<li><img alt="" src="_attachment/image_672.png" /></li>
</ul>
<p>問題例</p>
<ul>
<li>Windows インスタンス群が一度にリブートしないようグループに分けてパッチを当てたい。</li>
</ul>
<p>解答</p>
<ul>
<li>Set up two Patch Groups with unique tags that you will assign to all of your Amazon EC2 Windows Instances.</li>
<li>Associate the predefined AWS-DefaultPatchBaseline baseline on both patch groups.</li>
<li>Set up two non-overlapping maintenance windows and associate each with a different patch group.</li>
<li>Register targets with specific maintenance windows using Patch Group tags.</li>
<li>Assign the AWS-RunPatchBaseline document as a task within each maintenance window which has a different processing start time</li>
</ul>
<h1 id="aws-service-catalog">AWS Service Catalog</h1>
<p>管理者が提供する CloudFormation テンプレート(=製品)を指定された IAM ロールと CFn パラメータ(=制約)で、エンドユーザが自身でプロビジョンする仕組み。</p>
<ul>
<li>テンプレート制約:  CloudFormation テンプレートのパラメータを制限。</li>
<li>起動制約:  製品を起動する際に使用するロールを指定。</li>
</ul>
<h2 id="ec2-image-builder">EC2 Image Builder</h2>
<ul>
<li>AMI とコンテナイメージの自動ビルド・検証・配布を行うパイプラインサービス。</li>
<li>ベースAMI更新やマルチアカウント配布を自動化。</li>
</ul>
<h1 id="aws-waf">AWS WAF</h1>
<p>統合サービス: ALB, CloudFront, API Gateway</p>
<p>ウェブ ACL &amp; ルール</p>
<ul>
<li>ウェブ ACL のリストにルールを投入する。</li>
<li>ACL なのでルールはリストの順番に評価され、最後にデフォルト Allow/Deny がある。</li>
<li>ウェブ ACL 単位で AWS リソースに割りあてる</li>
<li>マネージドルールグループ<ul>
<li>AWS や AWS Marketplace でセキュリティベンダ (F5, Fortinet 等) が提供するルールグループ</li>
</ul>
</li>
</ul>
<p>ルール</p>
<ul>
<li>ルールステートメント<ul>
<li>HTTP リクエスト各コンポーネントの正規表現マッチ</li>
<li>リクエストサイズ, Rate limit</li>
<li>IP, GeoIP</li>
<li>SQLi, XSS</li>
<li>例: 特定の User Agent によるリクエストのブロック。</li>
</ul>
</li>
<li>アクション: Block, Allow, Count の3種。</li>
<li>WAF v2 ではステートメントの AND/OR が指定できる。</li>
<li>IP ブラックリスト指定等も可能。</li>
</ul>
<h1 id="aws-shield">AWS Shield</h1>
<p>概要</p>
<ul>
<li>DDoS 対策。</li>
<li><a href="https://d1.awsstatic.com/webinars/jp/pdf/services/20170718_AWS-BlackBelt-Shield.pdf">https://d1.awsstatic.com/webinars/jp/pdf/services/20170718_AWS-BlackBelt-Shield.pdf</a></li>
</ul>
<p>Standard</p>
<ul>
<li>AWS サービスにデフォルト組み込みの L3/4 防御。</li>
<li>エッジロケーションでのパケットフィルタリング、トラフィックシェーピングなどによる DDoS 攻撃緩和。</li>
</ul>
<p>Advanced</p>
<ul>
<li>EC2(ENI), ELB, CloudFront, Route 53 と統合された高度な検出。<ul>
<li>WAF と異なり API Gateway は対象外。Web に限らないので ALB に限られない。</li>
</ul>
</li>
<li>AWS WAF が無料。</li>
</ul>
<p>問題例: Which among the options below can the Engineer implement as part of the company's DDoS attack surface reduction strategy to minimize the blast radius in their cloud infrastructure? (Select TWO.)</p>
<p>解答</p>
<ul>
<li>Use AWS Shield Advanced to enable enhanced DDoS attack detection and monitoring for application-layer traffic of the company's AWS resources. Ensure that every security group in the VPC only allows certain ports and traffic from authorized servers or services. Protect your origin servers by putting it behind a CloudFront distribution.</li>
<li>Set up AWS WAF rules that identify and block common DDoS request patterns to effectively mitigate a DDoS attack on the company's cloud infrastructure. Ensure that the Network Access Control Lists (ACLs) only allow the required ports and network addresses in the VPC.</li>
</ul>
<h1 id="aws-firewall-manager">AWS Firewall Manager</h1>
<p>Organizations の複数アカウントのリソースに WAF ルールとセキュリティグループを適用できる。</p>
<ul>
<li>アカウントが Organizations に所属している必要がある。</li>
</ul>
<p>リソースタイプ (CloudFront distribution や ALB など) にポリシーを設定する。</p>
<ul>
<li>新規追加されたリソースにも自動適用される。</li>
</ul>
<h1 id="amazon-inspector">Amazon Inspector (検閲官)</h1>
<p>インスタンスの脆弱性・セキュリティレポートを生成。</p>
<ul>
<li>apt, Windows Installer でインストールされたソフトウェアのバージョンと CVE 等を照合。</li>
<li>評価テンプレート: スケジュール、ルールパッケージ、SNS トピックを指定。</li>
<li>ルールパッケージ:<ul>
<li>CVE, CIS</li>
<li>ベストプラクティス</li>
<li>ネットワーク到達可能性ルール。</li>
</ul>
</li>
<li>エージェントレススキャン: SSM Agent 不要でEBSスナップショットを24時間ごとに評価。</li>
</ul>
<h1 id="amazon-macie">Amazon Macie</h1>
<p>S3 内の機密データ (PII, カード番号, 認証情報)、暗号化不備、共有状況などのリスク検出。</p>
<ul>
<li>S3 サーバアクセスログと CloudTrail のアクセスパターンから機械学習でリスク検知。</li>
<li>PII や知的財産などの機密データの検出。</li>
<li>ダッシュボード表示と CloudWatch Events のトリガー。</li>
</ul>
<h1 id="amazon-guardduty">Amazon GuardDuty (見張り役)</h1>
<p>脅威インテリジェンスによる既知の脅威と異常検出による未知の脅威の検出。</p>
<p><img alt="" src="_attachment/image_674.png" /></p>
<ul>
<li>CloudWatch Events 経由で Lambda による対応アクション (インスタンス隔離等)</li>
<li>独自の脅威インテリジェンス・IP セーフリストをアップロードすることも可能。</li>
<li>S3 Protection で S3 への脅威検知も対応。</li>
</ul>
<h1 id="amazon-detective">Amazon Detective</h1>
<p>GuardDutyが検出したセキュリティインシデントを可視化・調査するSIEM</p>
<p><img alt="" src="_attachment/image_675.png" /></p>
<ul>
<li>マルチアカウントのアクティビティログを集約。</li>
<li>GuardDuty 有効化が必要。</li>
</ul>
<h1 id="aws-security-hub">AWS Security Hub</h1>
<p>各種セキュリティサービスと統合し、組織アカウント横断で検出結果を収集・ダッシュボード表示。(XDR?)</p>
<p><img alt="" src="_attachment/image_676.png" /></p>
<ul>
<li>Firewall Manager により WAF, Shield Advanced, セキュリティグループの検出も統合される。</li>
<li>AWS Config のコンフォーマンスパックのコンプライアンスチェックも継続的に実施。<ul>
<li>AWS ベストプラクティスや CIS, PCI-DSS 等</li>
</ul>
</li>
<li>セキュリティイベントを CloudWatch Events 経由で Lambda 等と連携し、レスポンス自動化。</li>
</ul>
<p><img alt="" src="_attachment/image_677.png" /></p>
<h1 id="trusted-advisor">Trusted Advisor</h1>
<p><img alt="" src="_attachment/image_678.png" /></p>
<p>AWS Trusted Advisor のチェックの自動更新は Weekly-base</p>
<p>AWS Support API: Trusted Adviser の API</p>
<ul>
<li>DescribeTrustedAdvisorChecks</li>
<li>RefreshTrustedAdvisorCheck</li>
</ul>
<p>CloudWatch Events 連携で処理を自動化</p>
<ul>
<li>例:  Check Item Refresh Status イベントを Lambda 連携し、使用率の高い EC2 インスタンスがあれば SSM Automation でインスタンスをリサイズ</li>
<li>なお、グローバルサービスなので us-east-1 でしかイベントソースに表示されない</li>
</ul>
<p>CloudWatch メトリクスも CloudWatch Events 同様の項目で存在</p>
<ul>
<li>問題例: 使用されていない ELB の通知を実現できるオプション<ul>
<li>メトリクスからアラームで通知: Use Amazon CloudWatch to create alarms on Trusted Advisor metrics in order to detect the load balancers with low utilization. Specify an SNS topic for notification.</li>
<li>CloudWatch Events 連携: Utilize CloudWatch Events to monitor Trusted Advisor recommendation results. Set up a trigger to send an email using SNS to notify you about the results of the check.</li>
<li>スケジュール Lambda から Trusted Advisor API コール: Create a Lambda function and integrate it with CloudWatch Events. Configure the function to run on a regular basis and to check AWS Trusted Advisor via API. Based on the results, publish a message to an Amazon SNS Topic to notify the subscribers.</li>
</ul>
</li>
<li>Trusted Advisor ビルドインの通知もあるが、自動リフレッシュが Weekly-base なので Daily scheduled の Lambda による Trusted Advisor チェックリストの更新・取得のポーリングが正解とされる。</li>
</ul>
<h2 id="iam-access-analyzer">IAM Access Analyzer</h2>
<ul>
<li>リソースベースポリシーを分析し、外部プリンシパルと共有されるリソースを表示。</li>
<li>IAM ロール, S3 バケット, KMS キー, Lambda 関数/レイヤー, SQS キュー</li>
<li>例<ul>
<li>クロスアカウントが許可されたロールの確認</li>
<li>パブリックアクセスのバケットの確認</li>
</ul>
</li>
</ul>
<h2 id="s3-access-analyzer-access-analyzer-for-s3">S3 Access Analyzer (Access Analyzer for S3)</h2>
<ul>
<li>パブリックバケット・他の AWS アカウントに公開されたバケットを検出。</li>
<li>IAM Access Analyzer がベース。</li>
</ul>
<h1 id="aws-health">AWS Health</h1>
<p><a href="https://docs.aws.amazon.com/health/latest/ug/what-is-aws-health.html">https://docs.aws.amazon.com/health/latest/ug/what-is-aws-health.html</a></p>
<p><a href="https://aws.amazon.com/jp/premiumsupport/technology/personal-health-dashboard/">https://aws.amazon.com/jp/premiumsupport/technology/personal-health-dashboard/</a></p>
<p>AWS Service Health Dashboard</p>
<ul>
<li>AWS サービス全般の Health ステータスが表示される</li>
</ul>
<p>AWS Personal Health Dashboard</p>
<ul>
<li>アカウント固有の Health イベントのアラートやガイダンスを提供。</li>
<li>お客様の AWS 環境に関する明確な通知が事前に表示されます。</li>
<li>CloudWatch Events で AWS Personal Health Dashboard (AWS Health) イベントと連携できる。</li>
</ul>
<p>AWS Health API</p>
<ul>
<li>AWS Health 情報を取得する API</li>
</ul>
<p>AWS_RISK_CREDENTIALS_EXPOSED</p>
<ul>
<li>IAM クリデンシャルの露出の CloudWatch イベント</li>
<li>問題例:<ul>
<li>Set up three Lambda functions in AWS Step Functions that deletes the exposed IAM access key, summarizes the recent API activity for the exposed key using CloudTrail and sends notification to the IT Security team using Amazon SNS.</li>
<li>Create a CloudWatch Events rule with an aws.health event source and the AWS_RISK_CREDENTIALS_EXPOSED event to monitor any exposed IAM keys from the Internet.</li>
<li>Set the Step Functions as the target of the CloudWatch Events rule.</li>
</ul>
</li>
</ul>
<h1 id="_7">暗号化・クリデンシャル管理</h1>
<p>Ref. <a href="References/AWS%20-%20Security%20-%20KMS,%20Secrets%20Manager,%20ACM.html">AWS - Security - KMS, Secrets Manager, ACM</a></p>
<h2 id="kms">KMS</h2>
<ul>
<li>暗号化に使うデータキーと、それを暗号化するマスターキーを管理するサービス。(鍵で鍵を暗号化するエンベロープ暗号化を実現)</li>
<li>CMK: Customer Master Key<ul>
<li>KMS 内の HSM で暗号化された状態で保管されるマスターキー。</li>
<li>対象鍵 (AES256), 非対称鍵 (RSA, ECC) がサポートされている。</li>
<li>キーローテーションがある。</li>
</ul>
</li>
<li>CDK: Customer Data Key<ul>
<li>データの暗号化に使用するキー。使用時以外は CMK で暗号化されたものをローカル保存。</li>
<li>対象鍵のデータキーと非対称鍵のデータキーペアがある。<ul>
<li>非対称なら公開鍵をアプリに保存して暗号化時に使用、復号時のみ秘密鍵を Decrypt して復号という使い方もできる。</li>
<li>非対称は署名用途にも使える。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>暗号化の手順</p>
<ul>
<li>GenerateDataKey で取得した平文データキー (Plaintext) で暗号化し、暗号化したデータを暗号化データキー (CiphertextBlob) とともに保管。</li>
<li>平文データキーは廃棄。</li>
</ul>
<p>復号の手順</p>
<ul>
<li>Decrypt で暗号化データキーを復号し、そのキーで暗号化データを復号。</li>
</ul>
<p>API</p>
<ul>
<li>CreateKey<ul>
<li>CMK を生成。KeyID が返り CMK そのものは返らない。</li>
</ul>
</li>
<li>GenerateDataKey/GenerateDataKeyPair<ul>
<li>KeyID を指定してデータキーを生成。データキーとして Plaintext と暗号化されたデータキーの CiphertextBlob が返る。</li>
<li>Plaintext でデータを暗号化して Plaintext は捨てる。暗号化後のデータを CiphertextBlob とともに保管。</li>
</ul>
</li>
<li>Decrypt<ul>
<li>CiphertextBlob を復号。KeyId は CiphertextBlob に含まれるので指定不要。</li>
</ul>
</li>
<li>Encrypt<ul>
<li>GenerateDataKey のデータキーを暗号化に使用するので、通常は使用しない。</li>
<li>CMK の KeyId と最大 4KB までの任意のデータを指定して呼び出す。暗号化された CiphertextBlob が返る。</li>
<li>CiphertextBlob には CMK の情報と暗号化されたデータが含まれる。Decrypt 時は KeyId 指定不要。</li>
<li>Usecase-1:  DB パスワードなどサイズの小さなシークレットを暗号化する場合。</li>
<li>Usecase-2: データキーをクロスリージョンで共有するために、データキーを別リージョンの CMK で暗号化して渡す。</li>
</ul>
</li>
</ul>
<p><strong>KMS Grant（権限委譲）</strong></p>
<ul>
<li>キーポリシーを変更せずに、一時的にKMSキー操作権限を委譲するAPI</li>
<li><code>Decrypt</code>, <code>GenerateDataKey</code> などの権限を特定プリンシパルに付与</li>
<li>取得された Grant Token を指定して API を呼び出す</li>
<li>代表ユースケース：AWSサービス連携時の動的権限委譲、外部システムの復号権限付与</li>
</ul>
<p><strong>Encryption Context</strong></p>
<ul>
<li>対称鍵での Encrypt/GenerateDataKey 時に指定できる Key/Value ペアの追加認証情報。</li>
<li>復号時に同じ Key/Value を渡す必要がある。</li>
<li>CloudTrail 証跡を暗号化する CMK のキーポリシーの <code>kms:EncryptionContext</code> 条件で暗号化を行う証跡の ARN を指定して制限する際に使う。</li>
<li>目的: 意図しない KMS キーで証跡データを暗号化してしまうのを防ぎ、この証跡だけがこの KMS キーを利用できるように制限するため。</li>
</ul>
<p>Systems Manager Parameter Store</p>
<p>Secrets Manager</p>
<hr />
<h1 id="high-availability-fault-tolerance-disaster-recovery">High Availability, Fault Tolerance, Disaster Recovery</h1>
<p>Ref.
<a href="References/AWS%20-%20Auto%20Scaling,%20Multi%20AZ/Region/Account.html">AWS - Auto Scaling, Multi AZ/Region/Account</a>
<a href="References/AWS%20SAA%20-%20VPC,%20ELB,%20Auto%20Scaling,%20Route%2053,%20CloudFront,%20Direct%20Connect.html">AWS SAA - VPC, ELB, Auto Scaling, Route 53, CloudFront, Direct Connect</a>
<a href="References/AWS%20-%20Security%20-%20EC2,%20ELB,%20VPC.html">AWS - Security - EC2, ELB, VPC</a>
<img alt="" src="_attachment/image_679.png" /></p>
<h2 id="vpc">VPC</h2>
<p>リージョン内の複数 AZ にまたがって展開できる仮想ネットワーク</p>
<ul>
<li>AZに1つ以上のサブネットを配置</li>
<li>サブネットに EC2, RDS などのインスタンスを配置</li>
<li>個々の VPC に IP アドレス範囲 (CIDR) を持つ</li>
</ul>
<p>サブネット</p>
<ul>
<li>サブネットに AZ を紐づけることで、AZ 内にサブネットを置く。</li>
<li>1つの AZ に複数置ける。 </li>
</ul>
<p>ルートテーブル</p>
<ul>
<li>各種ゲートウェイ (IGW, NAT GW, VGW) へのルートを登録する。</li>
<li>ルートテーブルはサブネットに対して設定される。サブネット毎に個別にルートテーブルを指定。</li>
</ul>
<p>IGW (Internet Gateway)</p>
<ul>
<li>プライベート/パブリックIP 1対1の Static NAT でインターネットに出て行くゲートウェイ</li>
<li>パブリックサブネット: ルートテーブルでデフォルト GW に IGW が登録されているサブネット。</li>
</ul>
<p>VGW (Virtual Private Gateway)</p>
<ul>
<li>VPC からインターネット VPN または専用線 (Direct Connect) でオンプレ拠点と接続するGW。</li>
</ul>
<p>NAT Gateway</p>
<ul>
<li>プライベートサブネットから NAPT でインターネットに出て行くためのゲートウェイ。</li>
<li>パブリックサブネットに置かれる。ElP を使用する。</li>
<li>セキュリティグループを設定出来ない。背後のインスタンスの SG か NACL でコントロール。</li>
<li>論理的にサブネットに関連づけられる仮想ゲートウェイで ENI を持たないため SG 設定できない。</li>
</ul>
<p>NAT インスタンス</p>
<ul>
<li>Amazon Linux をベースに NAT を構成した AMI (amzn-ami-vpc-nat) のインスタンス。 </li>
<li>ログインできるため、ポート転送の設定や踏み台サーバとしての利用が可能。(NAT GW はできない)</li>
<li>セキュリティグループを関連づけてトラフィックをコントロールできる。</li>
<li>ユーザがソフトウェアアップデートやスケーリングを管理。</li>
</ul>
<p>セキュリティグループ</p>
<ul>
<li>ENI にアタッチされるホワイトリストベースの仮想 FW ルール。(評価順序はない)</li>
<li>ステートフルなので送受信で個別にルールを指定する必要はない。</li>
<li>プロトコル、ポート、インバウンド/アウトバウンド (Ingress/Egress)</li>
<li>デフォルトはアウトバウンド全許可のルールのみ (インバウンドは空=全拒否)</li>
<li>Peer に IP だけでなく別のセキュリティグループも指定できる。</li>
<li>許可するためのルールなので、ブラックリスト指定はできない。</li>
</ul>
<p>Network ACL (NACL)</p>
<ul>
<li>サブネットにつく仮想 FW ルール。サブネット単位で制御するような場合に使う。</li>
<li>ステートレスなのでインバウンド・アウトバウンドのパケットで個別設定する。<ul>
<li>クライアントへのレスポンスには一時ポート(Ephemeral ports) の 1024-65535 とかのポートレンジでルールが必要となる。</li>
</ul>
</li>
<li>デフォルトの NACL は Allow ルールのみで素通しになっている。(評価順序がある)</li>
<li>SG と異なり、Allow/Deny の指定ができるのでブブラックリス指定が可能。</li>
</ul>
<p>VPC エンドポイント</p>
<ul>
<li>VPC からインターネットを経由せずリージョン内でエンドポイントを持つ AWS サービスにアクセスできる。</li>
</ul>
<p>ゲートウェイエンドポイント</p>
<ul>
<li>大規模分散ストレージの S3 と DynamoDB のみ</li>
<li>サービスのゲートウェイをルートテーブルに指定する</li>
</ul>
<p>インターフェイスエンドポイント (PrivateLink)</p>
<ul>
<li>ENI としてサブネット内のプライベート IP アドレスを持つエンドポイントが現れる。<ul>
<li>サービスのエンドポイントと ENI が PrivateLink でリンクされる。</li>
</ul>
</li>
<li>VPC の DNS にサービスのデフォルトのホスト名が登録される<ul>
<li>&lt;サービス名&gt;.&lt;リージョン&gt;.amazonaws.com の A レコード</li>
</ul>
</li>
<li>ENI に関連付けたセキュリティグループでアクセス制御が可能</li>
</ul>
<p>エンドポイントポリシー</p>
<ul>
<li>VPC エンドポイントにアタッチされるポリシー。VPC から接続先 AWS サービスへのアクセス権を設定。</li>
<li>ゲートウェイエンドポイント・インターフェイスエンドポイント両方にある。</li>
</ul>
<p>VPC ピア接続 (VPC ピアリング)</p>
<ul>
<li>2つの VPC ルーター同士を接続する。</li>
<li>VPC ルートテーブルにお互いのプライベートアドレスへのルーティングを設定。<ul>
<li>サブネットの CIDR ブロックがかぶらないように設計する必要がある。</li>
</ul>
</li>
<li>クロスリージョン・クロスアカウントの VPC も接続可能。</li>
<li>推移的なピア接続は不可</li>
</ul>
<p>問題例: VPC 内の EC2 から S3 へのアップロードが失敗する ← VPC エンドポイントポリシーが原因</p>
<p>問題例: アウトバウンドの API 呼び出しエラーを確認するには？</p>
<ul>
<li>Log in to the AWS Management Console and look for <strong>REJECT</strong> records in the VPC flow logs which originated from the Auto Scaling group.</li>
<li>Verify that the egress security group rules of the Auto Scaling Group allow the outgoing traffic to the external API.</li>
</ul>
<h1 id="amazon-ec2-auto-scaling">Amazon EC2 Auto Scaling</h1>
<p>基本的には ELB と組み合わせてマルチ AZ (=複数サブネット) で利用する。</p>
<p><img alt="" src="_attachment/image_680.png" /></p>
<p>起動設定 (Launch configuration)</p>
<ul>
<li>基本的に EC2 起動設定と同じ: AMI ID、インスタンスタイプ、キーペア、SG、ボリューム、UserData によるスクリプト実行、タグなど</li>
<li>サブネット(AZ) は Auto Scaling グループの設定が優先される。</li>
</ul>
<p>起動テンプレート (Launch template)</p>
<ul>
<li>既存テンプレートから継承して別バージョンのテンプレートが作れる。</li>
<li>スポットインスタンスを起動できる (スポットフリートを起動テンプレートから作成)<ul>
<li>オンデマンドとミックスで使える。</li>
</ul>
</li>
</ul>
<p>Launch configuration/template を変更するとバージョン番号がインクリメントする。</p>
<p>同じセキュリティグループを使用すべきなので、ASG で SG が指定される。</p>
<p>Auto Scaling グループ</p>
<ul>
<li>ELB 統合<ul>
<li>Auto Scaling が ELB ターゲットグループに自動でインスタンスを追加・削除する。</li>
</ul>
</li>
<li>マルチ AZ でインスタンス数が均等になるようにバランシングされる。</li>
</ul>
<p>Scheduled Action (予定されたアクション)</p>
<ul>
<li>サイズ (Max,Min,Desired) の変更をスケジュール指定 (Cron, リピート, Once)</li>
</ul>
<p>動的スケーリングポリシー</p>
<ul>
<li>Target tracking scaling<ul>
<li><strong>CloudWatch メトリクスのターゲット値を維持</strong>するようスケールアウト/インする。</li>
<li>CPU 使用率、ネットワーク出力、ネットワーク入力、ALB リクエスト数。</li>
</ul>
</li>
<li>Step scaling<ul>
<li><strong>CloudWatch アラーム</strong>にスケーリング調整値を設定してインスタンス数を増減する。</li>
<li>例: 平均 CPU 使用率 50% 超過アラームと、80% 超過アラームそれぞれにインスタンス追加数を個別に設定。</li>
</ul>
</li>
<li>クールダウン (デフォルト300秒)<ul>
<li>スケーリング発生後に ASG 全体でスケーリングを抑制する期間 </li>
<li>アラームが連続して発生してもスケーリングを実施しないようにするため</li>
</ul>
</li>
<li>ウォームアップ<ul>
<li>新しいインスタンスが CloudWatch メトリクスの平均 CPU に影響しないように除外する期間</li>
<li>インスタンス内の OS のブートアップやアプリケーションの起動時間を考慮。</li>
<li>クールダウンがウォームアップより長くないとメトリクス反映前に再度スケーリングが発生してしまう。</li>
</ul>
</li>
<li>Disable scale-in<ul>
<li>Target Tracking/Step Scaling の特定ポリシーだけインスタンスの削除 (スケールイン) を無効化。</li>
<li>スケールアウトはしたいが、しばらくスケールインはさせたくないシナリオ（バッチ処理など）</li>
</ul>
</li>
</ul>
<p>ヘルスチェック</p>
<ul>
<li>Auto Healing<ul>
<li>異常 (impared) 判定されたインスタンスを終了 (terminate) し新しいインスタンスを起動する。</li>
</ul>
</li>
<li>EC2 のヘルスチェック (デフォルト)<ul>
<li>システムステータスチェック: EC2 のインフラ由来の問題の検出</li>
<li>インスタンスステータスチェック: ARP によるヘルスチェック</li>
</ul>
</li>
<li>ELB によるヘルスチェック (オプション)</li>
<li>カスタムヘルスチェック<ul>
<li>独自のヘルスチェック機能から Unhealthy 状態を Auto Scaling に通知する。</li>
</ul>
</li>
</ul>
<p>終了ポリシー (Termination Policy)</p>
<ul>
<li>デフォルト終了ポリシーの挙動:<ol>
<li>最もインスタンスの多い AZ を選択</li>
<li>Scale-in Protection がセットされていないインスタンスを選択</li>
<li>最も古い起動設定・テンプレートで起動されたものを選択</li>
<li>次の課金時間に最も近いものを選択。</li>
</ol>
</li>
</ul>
<p>Suspended Process オプション</p>
<ul>
<li>Auto Scaling グループで特定のイベント処理を停止:</li>
<li><img alt="" src="_attachment/image_681.png" /></li>
</ul>
<p>Detach アクション</p>
<ul>
<li>インスタンスを Auto Scaling グループと ELB ターゲットグループからデタッチする。</li>
<li>代わりのインスタンスが起動される。</li>
<li>インスタンスの<strong>フォレンジックなど</strong>の際に使う。</li>
</ul>
<p>Set to Standby アクション</p>
<ul>
<li>インスタンスを ELB ターゲットグループからデタッチする。</li>
<li>他のインスタンスにトラフィックが振り分けられて負荷が上がる。</li>
</ul>
<p>Set Scale In Protection</p>
<ul>
<li>スケールイン時に対象インスタンスが削除対象にならないようにする。</li>
<li>バッチ処理中のインスタンスやマスターノードなどに動的に設定する。</li>
</ul>
<p>ライフサイクルフック</p>
<ul>
<li>インスタンスの起動・終了時にインスタンス状態を Pending:Wait や Terminating:Wait に止めておく仕組み (デフォルト1時間)</li>
<li>アプリケーション初期化処理 (UserData) の待機や、終了時にログ待避やスナップショットなどを実施</li>
<li>イベント種類<ul>
<li>EC2_INSTANCE_LAUNCHING (Pending: Wait → Proceed)</li>
<li>EC2_INSTANCE_TERMINATING (Terminating: Wait → Proceed)</li>
</ul>
</li>
<li>通知設定<ul>
<li>SNS, SQS</li>
<li>EventBridge ... SSM RunCommand などを実施</li>
</ul>
</li>
<li>
<p>CompleteLifecycleAction API</p>
<ul>
<li>フック完了時に CLI や Lambda から COMPLETE/ABANDON の結果を通知する</li>
</ul>
</li>
<li>
<p>問題例:</p>
<ul>
<li>Delay the termination of unhealthy Amazon EC2 instances by adding a lifecycle hook to your Auto Scaling group to move instances in the Terminating state to the Terminating:Wait state.</li>
<li>Set up a CloudWatch Events rule for the EC2 Instance-terminate Lifecycle Action Auto Scaling Event with an associated AWS Systems Manager Automation document.</li>
<li>Trigger the CloudWatch agent to push the application logs and then resume the instance termination once all the logs are sent to CloudWatch Logs.</li>
</ul>
</li>
</ul>
<p><strong>CloudFormation による Auto Scaling 作成</strong></p>
<ul>
<li>CreationPolicy &gt; ResourceSignal で希望数のインスタンスからシグナルあるまで ASG 作成成功を待機。</li>
<li>起動設定の UserData で cfn-signal を実施。</li>
<li>スタック更新時でもデフォルトでは既存インスタンスは置き換わらない</li>
<li>UpdatePolicy を指定することでスタック更新時にインスタンスがリプレースされる:<ul>
<li>AutoScalingRollingUpdate: ASG 内で新しいインスタンスを立ててローリングアップデート</li>
<li>AutoScalingReplacingUpdate: ASG 全体を置き換える (Blue/Green)</li>
</ul>
</li>
<li>IgnoreUnmodifiedGroupSizeProperties<ul>
<li>スケジュールアクションで変更された ASG のサイズ (Max,Min,Desired) がスタック更新時に上書きされないようにするオプション</li>
</ul>
</li>
</ul>
<pre><code>    UpdatePolicy:
      AutoScalingRollingUpdate:
        MinInstancesInService: '1'
        MaxBatchSize: '2'
        PauseTime: PT1M
        WaitOnResourceSignals: 'true'
        # SuspendProcesses:
        # - list of processes to suspend ...
      AutoScalingScheduledAction:
        IgnoreUnmodifiedGroupSizeProperties: 'true'
</code></pre>
<pre><code>  　UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: 'true'
</code></pre>
<p><strong>CodeDeploy と Auto Scaling のインテグレーション</strong></p>
<ul>
<li>ASG の既存インスタンスとスケールアウトで新しく立ち上がるインスタンスに新しいリビジョンがデプロイされる。</li>
<li>デプロイタイプとしてインプレースとBlue/Green が指定可能。</li>
<li>Blue/Green では ASG そのものを置き換える方法も選択できる。</li>
<li>デプロイ中にスケールアウトが発生した場合、まだデプロイが成功したとみなされていないため、以前のリビジョンが新しく立ち上がるインスタンスにデプロイされる。それを防ぐためにはデプロイ中に <code>SuspendedProcess</code> オプションでインスタンス起動につながる以下の Auto Scaling 処理を停止する:<ul>
<li>AlarmNotification</li>
<li>ScheduledActions</li>
<li>ReplaceUnhealthy</li>
<li>AZRebalance</li>
</ul>
</li>
<li>common_functions.sh というスクリプトでやってくれるそう</li>
</ul>
<p>例: MinSize = MaxSize = 1 の ASG でインスタンスのリカバリを実現するユースケース</p>
<ul>
<li>クラスタの各インスタンスに固定で ENI をアサインするという要件があるため、1つの ASG にまとめられない。 </li>
<li>Set up a CloudFormation child stack template which launches an Auto Scaling group consisting of just one EC2 instance then provide a list of ENIs, hostnames and the specific AZs as stack parameters.</li>
<li>Set both the MinSize and MaxSize parameters of the Auto Scaling group to 1.</li>
<li>Add a user data script that will attach an ENI to the instance once launched.</li>
<li>Use CloudFormation nested stacks to provision a total of 10 nodes needed for the cluster, and deploy the stack using a master template.</li>
</ul>
<p>問題例: CloudFormation で AutoScalingRollingUpdate による ASG アップデートのトラブルシューティング</p>
<ul>
<li>何が Fail にしているのかを切り分けたい</li>
</ul>
<p>解答: Update を Fail になりにくくする設定を選ぶ</p>
<ul>
<li>In your <em>AutoScalingRollingUpdate</em> policy, set the <em>WaitOnResourceSignals</em> property to false.<ul>
<li><em>WaitOnResourceSignals</em> が true　だと <em>PauseTime</em> がタイムアウトとなる。</li>
<li>タイムアウトで Fail にならないようにする。アプリケーション起動などは失敗しているかもしれがないが、アップデート自体は Fail にならない。</li>
<li>Take note that if <em>WaitOnResourceSignals</em> is set to true, <em>PauseTime</em> changes to a timeout value.</li>
<li>AWS CloudFormation waits to receive a success signal until the maximum time specified by the PauseTime value.</li>
<li>If a signal is not received, AWS CloudFormation cancels the update.</li>
<li>Then, AWS CloudFormation rolls back the stack with the same settings, including the same <em>PauseTime</em> value.</li>
</ul>
</li>
<li>In your <em>AutoScalingRollingUpdate</em> policy, set the value of the <em>MinSuccessfulInstancesPercent</em> property to prevent AWS CloudFormation from rolling back the entire stack if only a single instance fails to launch<ul>
<li><em>MinSuccessfulInstancesPercent</em> が指定されていないと1台 Fail しただけでロールバックとなる。</li>
<li>Take note that setting the <em>MinSuccessfulInstancesPercent</em> property prevents AWS CloudFormation from rolling back the entire stack if only a single instance fails to launch.</li>
</ul>
</li>
<li>During a rolling update, suspend the following Auto Scaling processes: <em>HealthCheck</em>, <em>ReplaceUnhealthy</em>, <em>AZRebalance</em>, <em>AlarmNotification</em>, and <em>ScheduledActions</em><ul>
<li>Take note that if an unexpected scaling action changes the state of the Auto Scaling group during a rolling update, the update can fail. The failure can result from an inconsistent view of the group by AWS CloudFormation.</li>
<li>It is quite important to know that if you're using your Auto Scaling group with ELB, you should not suspend the following processes: <em>Launch</em>, <em>Terminate</em>, and <em>AddToLoadBalancer</em>. These processes are required to make rolling updates.</li>
</ul>
</li>
</ul>
<p>誤答</p>
<ul>
<li>Switch from <em>AutoScalingRollingUpdate</em> to <em>AutoScalingReplacingUpdate</em> policy by modifying the <em>UpdatePolicy</em> of the AWS::AutoScaling::AutoscalingGroup resource in the CloudFormation template. Set the <em>WillReplace</em> property to true<ul>
<li>incorrect because although the AutoScalingReplacingUpdate policy provides an immediate rollback of the stack without any possibility of failure, this solution is not warranted since the scenario asks for the options that will help troubleshoot the issue.</li>
</ul>
</li>
<li>Suspend the following Auto Scaling processes that are related with your ELB: <em>Launch</em>, Terminate, and <em>AddToLoadBalancer</em><ul>
<li>incorrect because these processes are required by the ELB to make rolling updates.</li>
</ul>
</li>
<li>Set the <em>WaitOnResourceSignals</em> property to true in your <em>AutoScalingRollingUpdate</em> policy<ul>
<li>The <em>WaitOnResourceSignals</em> property should be set to false instead of true, to determine what prevents the Auto Scaling group from being updated correctly during a stack update.</li>
</ul>
</li>
</ul>
<h1 id="elb">ELB</h1>
<p>外部公開サーバを高信頼・高可用性で構築するには必須。</p>
<p>ASG から連携されて使用される。</p>
<p>CodeDeploy の EC2, ECS の Blue/Green デプロイメントの実現手段</p>
<p>ECS (Service 使用時), Beanstalk (High Availability), OpsWorks でも使われる。</p>
<p>ターゲットグループ</p>
<ul>
<li>ターゲットの種類: インスタンス ID, IP アドレス, Lambda (ALB のみ)</li>
<li>ASG, ECS Service から統合されている。</li>
</ul>
<p>リスナー</p>
<ul>
<li>リスナールール: ルーティングのルールを定義する。</li>
<li>ルールの条件が満たされると指定されたターゲットグループに転送などのアクションをとる。</li>
</ul>
<p>ヘルスチェック</p>
<ul>
<li>TCP/HTTP/HTTPS でキープアライブ。</li>
<li>インターバルと Healthy/Unhealthy に移行する試行回数を指定。</li>
<li>Unhealthy に遷移で CloudWatch Events 通知。ヘルスチェックは続けるので Healthy に戻る場合も。</li>
<li>インスタンス再起動などの回復機能はない。</li>
</ul>
<p>負荷に応じて ELB 自体が自動スケーリング (スケールアウト/スケールイン)</p>
<ul>
<li>スケールアウトが間に合わないと 503 を返す。</li>
</ul>
<p>ALB: Application Load Balancer</p>
<ul>
<li>L7 (HTTP/HTTPS) レベルのロードバランシング</li>
<li>パスベースのルーティング: URL のパスで振り分け。</li>
<li>ホストベースのルーティング: Host ヘッダで振り分け。(複数ドメイン)</li>
<li>クエリ文字列/ヘッダベースのルーティング</li>
<li>HTTP/2, WebSockets サポート。</li>
<li>別の URL へのリダイレクト。</li>
<li>Lambda ターゲットのサポート。(NLB/CLB はサポートしない)<ul>
<li>非 VPC の Lambda も VPC Lambda も両方呼べる</li>
</ul>
</li>
<li>ユーザ認証: インスタンス上の Web アプリを改修せず認証を追加できる。<ul>
<li>Cognito ユーザープール統合:  ALB がユーザープールの Hosted UI にリダイレクト。</li>
<li>OpenID Connect (OIDC) 準拠 IdP 連携による認証。(Cognito 使わない ALB の機能)</li>
</ul>
</li>
</ul>
<p>NLB: Network Load Balancer</p>
<ul>
<li>L4 (TCP/UDPレベル) NAT ロードバランサー</li>
<li>UDP をサポート</li>
<li>大規模トラフィック対応: 毎秒数百万のリクエストを処理できる</li>
<li>静的 (Static) IP アドレスのサポート<ul>
<li>EIP で独自の固定 IP を設定することも可能。</li>
<li>FW などの制約で宛先を IP 指定しなければいけない場合など。</li>
</ul>
</li>
<li>送信元 IP アドレスの保持</li>
</ul>
<p>複数ポートのサポート</p>
<ul>
<li>同一インスタンスの複数ポートのサーバに負荷分散。(ALB/NLB でサポート)</li>
</ul>
<p>TLS オフロード (TLS Termination)</p>
<ul>
<li>ELB が TLS を終端しターゲット側は TLS 対応せずに済む</li>
<li>E2E 通信暗号化のため NLB/CLB で TCP pass through するという逆のユースケースも。<ul>
<li>ALB は HTTP プロキシなので TCP pass through ではない。</li>
</ul>
</li>
<li>(参考) ELB とターゲット間の HTTPS 通信<ul>
<li>オフロードにより ELB で終端してターゲットグループ設定で HTTPS を使用。</li>
</ul>
</li>
<li>(参考) HTTP to HTTPS リダイレクション<ul>
<li>HTTP (80) リスナーを作成し、443 へのリダイレクトアクションを設定する。</li>
</ul>
</li>
</ul>
<p>スティッキーセッション (Sticky session)</p>
<ul>
<li>設定された有効期限の間、同一ターゲットとセッションを維持。デフォルト無効。</li>
<li>ロードバランサーが設定する Cookie により実現。</li>
</ul>
<p>ELB と AZ</p>
<ul>
<li>ELB は AWS 管理のロードバランサーノードが各 AZ に自動配置される AZ スコープのサービス。</li>
<li>ELB 作成時にターゲットのサブネット(=AZ) を指定。<ul>
<li>ロードバランサーノード自身は AWS 管理 AZ に配置され、ターゲットとなる AZ 内のサブネットに転送。</li>
<li>DNS を引くとそれぞれの AZ のロードバランサーの IP が返ってくる。</li>
</ul>
</li>
<li>耐障害性 (Fault tolerance) のために<strong>マルチ AZ 設定が推奨</strong>される。</li>
<li><strong>ALB は2つ以上の AZ が必須</strong></li>
<li>ELB をパブリックサブネットに配置し、ターゲット（EC2/ECS）をプライベートサブネットに置く構成が一般的</li>
<li><strong>ALB には SG を指定可能</strong>。NLB は不可。</li>
</ul>
<h2 id="multi-az-ha">Multi AZ (HA)</h2>
<p><strong>Multi-AZ が暗黙的に提供されるサービス</strong></p>
<ul>
<li><strong>S3</strong>: One Zone-IA を除き、標準で Multi-AZ</li>
<li><strong>DynamoDB</strong></li>
</ul>
<p><strong>手動で Multi-AZ を有効化する必要があるサービス</strong></p>
<ul>
<li><strong>ELB, ASG, Beanstalk, EFS</strong><ul>
<li>AZ を指定して配置する必要がある</li>
</ul>
</li>
<li><strong>RDS, ElastiCache</strong><ul>
<li>Multi-AZ（フェイルオーバー用の同期スタンバイ DB）</li>
</ul>
</li>
<li><strong>Aurora</strong><ul>
<li>データは Multi-AZ に自動的に保存される</li>
<li>DB クラスターも Multi-AZ 構成が可能</li>
</ul>
</li>
<li><strong>OpenSearch</strong><ul>
<li>マルチマスター構成</li>
</ul>
</li>
<li><strong>Jenkins（セルフデプロイ版）</strong><ul>
<li>マルチマスター構成</li>
</ul>
</li>
</ul>
<p><strong>EFS: Elastic File System</strong>: VPC 配置の NFS 大規模分散ストレージ。</p>
<ul>
<li>デフォルトでマルチ AZ でレプリケーションされる分散ファイルストレージ</li>
<li>各 AZ にマウントターゲット (ENI) が作成され EC2 から NFS マウント。</li>
<li>何千ものインスタンスから同時にマウント可能。</li>
<li>ファイルシステムのアクセスセマンティクス (強い整合性やファイルのロックなど) を提供</li>
<li>EFS Standard: リージョン内の3つ以上のAZにレプリケーションされる。全 AZ にマウントターゲット。</li>
<li>EFS One Zone: 単一 AZ だけで保管。安価。指定 AZ のみにマウントターゲット。</li>
</ul>
<p><strong>ElastiCache for Redis</strong>: リードレプリカ, フェイルオーバー, マルチ AZ サポート (Memcached は不可)</p>
<p><strong>EBS は AZ スコープリソース</strong></p>
<ul>
<li>別 AZ ではアタッチできず、Multi-AZ 利用ではスナップショットを使ったハックが必要になる。</li>
<li>AMI はリージョンリソース。</li>
</ul>
<p>Amazon Data Lifecycle Manager (DLM)</p>
<ul>
<li>EBS ボリュームのスナップショット作成、保持、削除を自動化。</li>
</ul>
<h2 id="multi-region-disaster-recovery">Multi Region (Disaster Recovery)</h2>
<p><strong>マルチリージョン対応機能</strong></p>
<ul>
<li><strong>DynamoDB Global Tables</strong><ul>
<li>Streams による多方向レプリケーション</li>
</ul>
</li>
<li><strong>AWS Config Aggregators</strong><ul>
<li>マルチリージョン &amp; マルチアカウント対応</li>
</ul>
</li>
<li><strong>RDS Cross Region Read Replicas</strong><ul>
<li>DR/レイテンシー削減</li>
</ul>
</li>
<li><strong>Aurora Global Database</strong><ul>
<li>1つのリージョンがマスター、他リージョンはDR/レイテンシー削減</li>
</ul>
</li>
<li><strong>EBS ボリュームスナップショット・AMI・RDS スナップショット</strong><ul>
<li>他リージョンへコピー可能</li>
</ul>
</li>
<li><strong>VPC Peering</strong><ul>
<li>リージョン間をプライベート通信させる</li>
</ul>
</li>
<li><strong>Route53</strong><ul>
<li>グローバル DNS ネットワーク</li>
</ul>
</li>
<li><strong>S3 Cross Region Replication</strong></li>
<li><strong>CloudFront</strong><ul>
<li>エッジロケーションでのグローバル CDN</li>
</ul>
</li>
<li><strong>Lambda@Edge</strong><ul>
<li>エッジロケーションでグローバルに Lambda 実行（A/B テストなど）</li>
</ul>
</li>
<li><strong>CloudFormation StackSets</strong><ul>
<li>クロスアカウント/クロスリージョンに同一スタックを1 度のオペレーションで作成、更新、削除できる。</li>
</ul>
</li>
<li><strong>CodePipeline クロスリージョン・クロスアカウント</strong><ul>
<li>クロスリージョンや本番アカウントへのサービスデプロイ。</li>
<li>アーティファクトストア (S3) へのコピーやアクセスのためのポリシー設定必要になる。</li>
</ul>
</li>
</ul>
<h2 id="rds">RDS</h2>
<p>Ref.
<a href="References/AWS%20DVA%20-%20S3,%20RDS,%20DynamoDB,%20ElastiCache,%20and%20other%20storage%20services.html">AWS DVA - S3, RDS, DynamoDB, ElastiCache, and other storage services</a></p>
<p>可用性向上 → マルチAZ 構成に設定</p>
<ul>
<li>マルチ AZ 配置のマスター/スタンバイ構成となる</li>
</ul>
<p>負荷分散 → リードレプリカ</p>
<ul>
<li>リードレプリカがあればリードレプリカもマスターに昇格できる</li>
<li>リードレプリカは<strong>クロスリージョンのレプリケーションが可能</strong>。DR に利用できる。</li>
<li><img alt="" src="_attachment/image_684.png" /></li>
</ul>
<p>スナップショット</p>
<ul>
<li>自動バックアップ<ul>
<li>特定時刻 (過去 5分以内) の状態にリカバリするための機能。デフォルトで有効。</li>
<li>日次でスナップショットを自動的に作成し、差分のトランザクションログを保存する。</li>
<li>バックアップウィンドウと保持期間 (デフォルト7日、最大35日) を指定する。</li>
<li>DB インスタンスを削除されると同時に削除される。</li>
</ul>
</li>
<li>バックアップからのリストア<ul>
<li>新しいプライマリ DB インスタンスが作成され、自動スナップショットからリストアされる。</li>
<li>新しいエンドポイントを使用して作成される。エンドポイントが変わる！</li>
<li>アプリケーションが新しいエンドポイントに接続するように変更され、リストアが完了する。</li>
</ul>
</li>
<li>DB スナップショット (手動)<ul>
<li>スナップショットは DB インスタンスを削除しても削除されない。</li>
</ul>
</li>
<li>スナップショットをクロスリージョンの DR に使用する問題例</li>
<li><img alt="" src="_attachment/image_685.png" /></li>
</ul>
<p>メンテナンス</p>
<ul>
<li>OS や DB エンジンのバージョン更新。</li>
<li>わずかにパフォーマンスに影響が出る場合や DB インスタンスが少しの間オフラインになる場合も。</li>
<li>セキュリティやインスタンスの信頼性に関連するパッチは 「必須」として自動的にスケジューリング<ul>
<li>必須 – メンテナンスアクションがリソースに適用され、延期はできません。</li>
<li>利用可能 – 利用可能ですが自動的には適用されません。手動で適用できます。</li>
<li>次のウィンドウ – 次回のメンテナンスウィンドウ中にリソースに適用されます。</li>
<li>進行中 – メンテナンスアクションはリソースに適用中です。</li>
</ul>
</li>
</ul>
<p>メンテナンスウインドウ</p>
<ul>
<li>すべての DB インスタンスは週次 30分のメンテナンスウィンドウがある。</li>
<li>指定しない場合はランダムに設定される。</li>
<li>ほとんどの場合は 30分以内に終了するが、大規模なアップデートではその限りでない。</li>
</ul>
<p>マルチ AZ 配置のメンテナンス</p>
<ul>
<li>
<p>OS アップデート</p>
<ol>
<li>スタンバイにメンテナンスを実行後、スタンバイをプライマリに昇格。</li>
<li>旧プライマリはスタンバイになり、メンテナンス実行。</li>
</ol>
</li>
<li>
<p>DB エンジンバージョン更新</p>
<ul>
<li>プライマリとスタンバイ DB インスタンスを両方同時にアップグレード。</li>
<li>マルチ AZ 配置全体のデータベースエンジンがアップグレード時にオフラインとなる。<ul>
<li>プライマリ・スタンバイでは同じエンジンバージョンでないといけないため。</li>
</ul>
</li>
</ul>
</li>
<li>問題例: マルチ AZ 配置の DB バージョン更新にあたり、先にリードレプリカの CFn スタックを立てておくことでダウンタイムを減少させる。</li>
<li><img alt="" src="_attachment/image_686.png" /></li>
<li><img alt="" src="_attachment/image_687.png" /></li>
</ul>
<p>RDS イベント通知</p>
<ul>
<li>DB の設定変更、障害、フェイルオーバーなどの各種イベントを SNS で通知。</li>
</ul>
<p>問題例: クロスリージョンの Aurora DB のフェイルオーバーでダウンタイムを最小にするには？</p>
<ul>
<li>なお、Route53 を使用している。</li>
</ul>
<p>解答</p>
<ul>
<li>Launch a read replica of the primary database to the second region.</li>
<li>Set up Amazon RDS Event Notification to publish status updates to an SNS topic.</li>
<li>Create a Lambda function subscribed to the topic to monitor database health.</li>
<li>Configure the Lambda function to promote the read replica as the primary in the event of a failure.</li>
<li>Update the Route 53 record to redirect traffic from the primary region to the secondary region.</li>
<li>Route 53 フェイルオーバールーティングを使わないのは、おそらく Route 53 のヘルスチェックは Web 層のエラーの確認までしかできず、間接的にしか状態が分からないため。</li>
</ul>
<p>Amazon RDS Proxy</p>
<ul>
<li>Lambda が DB コネクションを大量に作成することで過負荷になるのを防ぐのに使う。</li>
</ul>
<p>RPO: Recovery Point Objective</p>
<ul>
<li>日本訳は「目標復旧時点」</li>
<li>インシデント発生した時点から直前のバックアップまでの間に、データが失われる可能性がある時間。</li>
</ul>
<p>RTO: Recovery Time Objective</p>
<ul>
<li>日本訳は「目標復旧時間」</li>
<li>システムがビジネスに大きな損害を与えることなく停止することができる時間、システムとデー タの復旧にかかる時間。</li>
</ul>
<p>問題例: クロスリージョンのリードレプリカで RPO を実現、Route53 のフェイルオーバールーティングで切り替え</p>
<ul>
<li>Clone the application stack except for RDS in a different AWS Region.</li>
<li>Create Read Replicas in the new region and configure the new application stack to point to the local Amazon RDS database instance.</li>
<li>Set up a failover routing policy in Route 53 that will automatically route traffic to the new application stack in the event of an outage</li>
</ul>
<p><img alt="" src="_attachment/image_689.png" /></p>
<p>回答: A</p>
<ul>
<li>B は動作します。ただし、pg_dump プロセスを実行すると、プライマリインスタンス上で大量の I/O が発生します。また、サイズの大きいデータベースの場合、SQL ダンプファイルのサイズが非常に大きくなります。</li>
<li>C は不正解です。スナップショットは 1 日 1回しか自動作成されず RPO 要件を満たさないため。</li>
<li>D は動作します。ただし、RPO 要件がわずか 4 時間なので、リージョン間レプリケーションは遅延が大きくなることがあり保証できない。</li>
</ul>
<h2 id="aurora">Aurora</h2>
<p>概要</p>
<ul>
<li>MySQL/PostgreSQL 互換<ul>
<li>MySQL/PostgreSQL を利用した既存アプリのコードがそのまま再利用できる、</li>
</ul>
</li>
<li>高スループット<ul>
<li>MySQL スループットの 5 倍、PostgreSQL スループットの 3 倍</li>
</ul>
</li>
<li>データベースのクラスター化とレプリケーションの自動化</li>
<li>スケーラビリティ<ul>
<li>10GB から 64TB まで自動でスケールアップ</li>
</ul>
</li>
<li>RDS 同様に、手動スナップショット、自動バックアップとポイントタイムリカバリ、メンテナンスウィンドウがある</li>
</ul>
<p>Aurora クラスター</p>
<ul>
<li>クラスターボリューム (マルチAZ)<ul>
<li>マルチ AZ の仮想 DB ストレージボリューム。3つの AZ に 6 つのコピーが作成される</li>
<li>シームレスにスケール (10GB-&gt;64TB) する仮想ストレージ</li>
</ul>
</li>
<li>DB クラスタ (オプションでマルチAZ)<ul>
<li>プライマリ DB インスタンスと Aurora レプリカ (リードレプリカ)</li>
<li>DB クラスタ作成時にマルチ AZ 配置を指定することでマルチ AZ となる。<ul>
<li>クラスタボリュームはデフォでマルチ AZ だが、DB クラスタではオプション。 </li>
</ul>
</li>
<li>リストアは数秒単位でクラスタを作成可能</li>
</ul>
</li>
</ul>
<p><img alt="" src="_attachment/File_19.png" /></p>
<p>Aurora Serverless</p>
<ul>
<li>DB インスタンスのオンデマンド Auto Scaling 構成。アプリの使用状況に応じてキャパシティーをスケール。</li>
<li>DB インスタンスクラスのサイズ指定せずデータベースエンドポイントを作成できる。</li>
</ul>
<p>暗号化</p>
<ul>
<li>AWS KMS キーによる暗号化を指定できる。</li>
<li>DB インスタンス作成時に有効にする。作成後は有効・無効の変更はできない。</li>
</ul>
<p>Aurora グローバルデータベース</p>
<ul>
<li>別リージョンにリードレプリカを配置する。</li>
<li>1 つのプライマリリージョン (マスター)と最大 5 つのセカンダリリージョン (読み取り専用) で構成。</li>
<li>問題例: コンプラ対応でカタログデータは Aurora Global DB に、顧客データを Aurora のリージョナル DB に保管する例:</li>
<li><img alt="" src="_attachment/image_688.png" /></li>
</ul>
<h1 id="aws-backup">AWS Backup</h1>
<p><a href="https://docs.aws.amazon.com/ja_jp/aws-backup/latest/devguide/whatisbackup.html">https://docs.aws.amazon.com/ja_jp/aws-backup/latest/devguide/whatisbackup.html</a></p>
<p>AWS 各種サービスのバックアップ</p>
<ul>
<li>AMI</li>
<li>EBS</li>
<li>RDS データベース</li>
<li>Aurora クラスター</li>
<li>EFS ファイルシステム</li>
<li>Storage Gateway ボリューム</li>
<li>DynamoDB テーブル</li>
<li>etc</li>
</ul>
<p>機能</p>
<ul>
<li>バックアップスケジュールと保存管理の自動化</li>
<li>バックアップモニタリングの一元化</li>
<li>DynamoDB、Aurora、DocumentDB、Neptune を除く 増分バックアップ。</li>
<li>AWS KMS 統合バックアップ暗号化</li>
<li>AWS Organizations によるアカウント間管理</li>
<li>AWS Backup Audit Manager によるバックアップ監査とレポートの自動化</li>
<li>AWS Backup Vault Lock による書き込み 1 回、読み取り多数 (WORM)</li>
</ul>
<h1 id="route-53">Route 53</h1>
<p>Ref. <a href="References/AWS%20SAA%20-%20VPC,%20ELB,%20Auto%20Scaling,%20Route%2053,%20CloudFront,%20Direct%20Connect.html">AWS SAA - VPC, ELB, Auto Scaling, Route 53, CloudFront, Direct Connect</a></p>
<p>ルーティングポリシー</p>
<ul>
<li>(レコードに複数リソースがある場合の) 動的なトラフィックルーティング。</li>
<li>シンプルルーティング<ul>
<li>レコード複数のリソース (IP アドレス等) がある場合は全ての値をランダムな順序で返す。</li>
</ul>
</li>
<li>Failover ルーティング<ul>
<li>DNS フェイルオーバーにより、ヘルスチェックで Healthy なエンドにのみルーティング。</li>
</ul>
</li>
<li>加重 (Weighted) ルーティング<ul>
<li>複数のリソースを重み付けして登録。重みの高いものに多くルーティングされる。</li>
<li>複数リソースに同じ名前とタイプでレコードを作成、レコードごとに重みを割り当てる。</li>
</ul>
</li>
<li>Latency (遅延) ルーティング<ul>
<li>ユーザ位置から最も遅延の少ないリージョンのリソースにルーティング。</li>
<li>Route 53 が継続的に計測する遅延の統計データに基づく。</li>
</ul>
</li>
<li>Geolocation (位置情報) ルーティング<ul>
<li>ユーザの位置情報に基づくルーティング。国やアメリカの州に結びつける。</li>
<li>ユースケース: ローカライズ、コンプライアンス、パフォーマンス。</li>
</ul>
</li>
<li>Geoproximity (地理近接性) ルーティング<ul>
<li>ユーザの位置情報とアクセス先リソースのリージョンの地理的近接性によるルーティング。</li>
<li>Route 53 Traffic Flow 専用のポリシー。</li>
</ul>
</li>
<li>複数値回答 (Multi-value) ルーティング<ul>
<li>ランダムに選ばれた最大8つの Healthy なレコードを応答。</li>
<li>シンプルルーティングの複数値と異なり各インスタンスにヘルスチェックが行われる。</li>
</ul>
</li>
</ul>
<p>ヘルスチェック</p>
<ul>
<li>Route 53 用の世界各地に15 以上あるヘルスチェッカーからエンドポイントにリクエスト。</li>
<li>1つも正常なエンドポイントがない場合、全てのエンドポイントを正常とみなして動作。</li>
<li>セキュリティグループ等にモニタリングパケットを受けられるよう設定が必要。<ul>
<li>aws route53 get-checker-ip-ranges</li>
</ul>
</li>
<li>ヘルスチェックの種類<ul>
<li>TCP ヘルスチェック<ul>
<li>エンドポイントとの TCP 接続の確立。</li>
</ul>
</li>
<li>HTTP/HTTPS ヘルスチェック<ul>
<li>エンドポイントからの HTTP  2xx または 3xx 応答。</li>
</ul>
</li>
<li>HTTP/HTTPS ヘルスチェックと文字列一致<ul>
<li>HTTP/HTTPS ヘルスチェックに加え、レスポンス本文から指定された文字列を検索。</li>
</ul>
</li>
<li>CloudWatch アラーム</li>
</ul>
</li>
</ul>
<p>Alias レコード</p>
<ul>
<li>CNAME のように別名がつけられる Route 53 固有の機能。</li>
<li>内部ドメイン名がアサインされる AWS サービスの公開ドメイン名を登録するのに使用。<ul>
<li>ELB, CloudFront, 静的 Web サイトの S3 バケットなど。</li>
</ul>
</li>
<li>CNAME よりレスポンスが高速。</li>
<li><img alt="" src="_attachment/image_690.png" /></li>
</ul>
<p>問題例: DR で別リージョンのバックアップ環境への DNS フェイルオーバーが必要という要件</p>
<ul>
<li>Set up health checks in Route 53 for non-alias records to each service endpoint. Configure the network access control list and the route table to allow Route 53 to send requests to the endpoints specified in the health checks.</li>
<li>Use a Failover routing policy configuration. Set up alias records in Route 53 that route traffic to AWS resources. Set the Evaluate Target Health option to Yes, then create all of the required non-alias records.</li>
<li>Latency ルーティングは不正解。目的が DR なので不適切。Latency は名前の通りレイテンシー低減が目的。</li>
</ul>
<h1 id="cloudfront">CloudFront</h1>
<p>エッジロケーションによる CDN サービス</p>
<ul>
<li>クライアントへのレスポンス向上。</li>
<li>オリジンサーバの負荷軽減。</li>
</ul>
<p>DNS が Geolocation で位置情報 DB から直近のエッジーサーバの IP を返す</p>
<ul>
<li>デフォルトのドメインは *.<a href="http://cloudfront.net">cloudfront.net</a><ul>
<li>デフォルトドメインの HTTPS サーバ証明書がデフォルトで作られる</li>
<li>カスタムドメイン使うには Alias or CNAME 設定と SSL/TLS 証明書設定。</li>
</ul>
</li>
<li>キャッシュによる DDoS 緩和。</li>
<li>WAF, AWS Shield が設定できる。(Shield Standard はデフォルトで有効)</li>
</ul>
<p><strong>オリジンの保護</strong></p>
<p>オリジンサーバに直接アクセスされた場合にオリジン側でブロックする手法。</p>
<p>S3 バケット</p>
<ul>
<li><strong>OAI (Origin Access Identity)</strong> というユーザをディストリビューションに設定する。S3 にはそのユーザからアクセスされているように見える。</li>
<li>バケットポリシーで OAI の ARN を Principal としてアクセスを許可する。</li>
</ul>
<p>S3 静的 Web ホスティング</p>
<ul>
<li>S3 静的 Web ホスティングはパブリック設定が必要なため保護できない。</li>
</ul>
<p>カスタムオリジン (EC2 Web サーバ, ALB等)</p>
<ul>
<li>CloudFront の<strong>オリジンカスタムヘッダー</strong>を利用し、指定されたヘッダをオリジンサーバ側でチェックしてアクセスを受け付ける。</li>
<li>定期的に変更される CloudFront の IP レンジを取得し、Lambda で EC2/ALB のセキュリティグループを動的に変更する方法もある。</li>
</ul>
<h3 id="https">トランスポート暗号化 (HTTPS)</h3>
<p><strong>ビューア → エッジ間</strong></p>
<p>デフォルトの *.cloudfront.net SSL 証明書</p>
<ul>
<li>標準で利用可能</li>
</ul>
<p>独自ドメイン使用</p>
<ul>
<li>X509 PEM 形式のサーバ証明書を ACM で発行/インポートし、CloudFront ディストリビューションに割り当てる。</li>
<li>us-east-1 (N.Virginia) の ACM で登登する必要がある。</li>
</ul>
<p>HTTPS 必須にする</p>
<ul>
<li>ディストリビューションのビューアプロトコルポリシーを設定。</li>
<li><code>Redirect HTTP to HTTPS</code></li>
<li><code>HTTPS Only</code></li>
</ul>
<p><strong>エッジサーバ → オリジン間</strong></p>
<p>S3 バケット・カスタムオリジン (ELB/EC2)</p>
<ul>
<li>Origin Protocol Policy を次のいずれかに設定:<ul>
<li><code>HTTPS Only</code></li>
<li><code>Match Viewer</code><ul>
<li><code>Viewer Protocol Policy</code> で <code>Redirect HTTP to HTTPS</code> / <code>HTTPS Only</code> を指定する場合</li>
</ul>
</li>
</ul>
</li>
<li>SSL プロトコル (TLSv1.2, TLSv1.1, TLSv1, SSLv3) を選択。</li>
<li>オリジンが ELB の場合、ACM で証明書をあてることができる。ELB のリージョンの ACM に登録。</li>
<li><a href="https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/using-https-cloudfront-to-custom-origin.html">https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/using-https-cloudfront-to-custom-origin.html</a></li>
</ul>
<p>S3 静的 Web ホスティング</p>
<ul>
<li>S3 静的 Web ホスティングは HTTPS 非対応。</li>
<li>S3 エンドポイント (<code>https://&lt;bucket&gt;.s3.&lt;region&gt;.amazonaws.com</code>) は HTTPS だが Web サイトのホスティングにはならない。</li>
</ul>
<p>CloudFront でカスタムドメインの証明書を使う場合、オリジンの ELB までの経路も HTTPS で保護したい場合、CloudFront 側の証明書は us-east-1 の ACM に登録し、もう1つの ELB の証明書は ELB と同じリージョンの ACM に登録する。</p>
<p>問題例:</p>
<ul>
<li>Their DevOps team needs to set up a CloudFront web distribution that uses a custom domain name where the origin is set to point to the ALB.</li>
<li>How can the DevOps Engineers properly implement an end-to-end HTTPS connection from the origin to the CloudFront viewers?</li>
</ul>
<p>解答: Origin (ALB) と CloudFront それぞれに証明書設定。</p>
<ul>
<li>Generate an SSL certificate that is signed by a trusted third-party certificate authority.</li>
<li>Import the certificate into AWS Certificate Manager and use it for the Application Load balancer.</li>
<li>Set the Viewer Protocol Policy to HTTPS Only in CloudFront and then use an SSL/TLS certificate from a 3rd party certificate authority which was imported to either AWS Certificate Manager or the IAM certificate store.</li>
</ul>
<p>署名付き URL/署名付き Cookie</p>
<ul>
<li>レンタルコンテンツ配信や限定されたユーザへのコンテンツ配信など。</li>
<li>署名付き Cookie<ul>
<li>URL を変更したくない場合や複数の URL が使用される HLS で使用する。</li>
<li>HLS: HTTP Live Streaming</li>
</ul>
</li>
<li>署名付き URL/Cookie の使用には CloudFront キーペアやキーグループを登録する。<ul>
<li>アプリケーション側が秘密鍵で署名付きURL/Cookie を署名し、CloudFront が公開鍵で検証する。</li>
</ul>
</li>
</ul>
<p>Restrict Bucket Access 設定</p>
<ul>
<li>OAI を設定するための CloudFront ディストリビューションの設定項目</li>
</ul>
<p>Restrict Viewer Access 設定</p>
<ul>
<li>署名付きURL/署名付きCookieがある場合のみアクセスを許可する設定項目</li>
</ul>
<p>フィールドレベル暗号化 (Field-Level Encryption)</p>
<ul>
<li>POST データの一部をエッジで暗号化、オリジンのみが復号できることで安全性を向上。</li>
<li>ディストリビューション設定で暗号化したい POST リクエストの一連のフィールドと暗号化に使用するパブリックキーを指定する。</li>
<li>鍵はキーペアを作成して公開鍵を CloudFront に設定する。(AWS KMS は使えない。Edge Location が KMS を呼べないため)</li>
</ul>
<p>地域制限: Geo restriction</p>
<ul>
<li>特定地域のユーザーによるアクセスを回避。<ul>
<li>承認された国のリストからのアクセスを許可。</li>
<li>禁止された国のリストからのアクセスを禁止。</li>
</ul>
</li>
<li>403 (Forbidden) を返す (カスタムエラーページの作成も可能)</li>
</ul>
<p>Lambda@Edge</p>
<ul>
<li>CloudFront エッジロケーションでリクエスト/レスポンスをフックでき、Lambda 関数でリクエストを書き換えたりキャッシュできる。</li>
<li>実行タイミング: Viewer Request -&gt; Origin Request -&gt; Origin Response -&gt; Viewer Response</li>
</ul>
<p>問題例: CloudFront を使ったシステムでのログイン処理の遅延への対処</p>
<p>回答:</p>
<ul>
<li>In the given scenario, you can use Lambda@Edge to to execute the authentication process in AWS locations closer to the users.</li>
<li>In addition, you can set up an origin failover by creating an origin group with two origins with one as the primary origin and the other as the second origin, which CloudFront automatically switches to when the primary origin fails. This will alleviate the occasional HTTP 504 errors that users are experiencing.</li>
</ul>
<p>問題例: スタティックな Single Page App を AWS でホストしてヘッダを追加したい</p>
<ul>
<li>The application has no server-side code and is just composed of a UI powered by Vue.js and Bootstrap.</li>
<li>Since the online calculator may contain sensitive financial data, adding HTTP response headers such as X-Content-Type-Options, X-Frame-Options and X-XSS-Protection should be implemented to comply with the OWASP standards.</li>
</ul>
<p>回答:</p>
<ul>
<li>Host the application on an S3 bucket configured for website hosting.</li>
<li>Set up a CloudFront web distribution and set the S3 bucket as the origin with the origin response event set to trigger a Lambda@Edge function.</li>
<li>Add the required security headers in the HTTP response using the Lambda function.</li>
</ul>
<h2 id="aws-certificate-manager-acm">AWS Certificate Manager: ACM</h2>
<ul>
<li>証明書管理とデプロイ<ul>
<li>オンプレサーバや AWS の統合サービスへの証明書デプロイ</li>
</ul>
</li>
<li>統合サービス<ul>
<li>ALB/NLB, CloudFront, API Gateway, Elastic Beanstalk</li>
</ul>
</li>
<li>証明書はインポートするか ACM が生成するパブリック証明書 (ACM 証明書) を使用。<ul>
<li>ACM 証明書は統合サービスで無料で利用できる証明書</li>
</ul>
</li>
</ul>
<h1 id="multi-account">Multi Account</h1>
<h2 id="aws-organization">AWS Organization</h2>
<p>Ref. <a href="References/AWS%20-%20Security%20-%20IAM,%20STS,%20Organization.html">AWS - Security - IAM, STS, Organization</a></p>
<ul>
<li>複数アカウントを階層的なポリシーで管理。</li>
<li>一括請求と SCP (Service Control Policy) によるアクセス許可ガードレール。</li>
<li>各アカウントの<strong>ルートユーザの権限を制限できる</strong>点が特に重要。</li>
<li>マスターアカウント: Organization を作成したアカウント。管理アカウントとなる。</li>
<li>OU にメンバーアカウントを所属させる。(Root OU に直接含めることもできる)</li>
<li>上位 OU から SCP のポリシーが継承される。</li>
<li>CloudTrail 組織証跡</li>
</ul>
<p>例: 本番アカウントに対して「開発者が直接デプロイできないようにする」とき</p>
<ul>
<li>本番 OU に SCP で CloudFormation/EC2 の Create/Update を Deny</li>
<li>ただしパイプラインが使用するロールのみを Allow</li>
</ul>
<h2 id="control-tower">Control Tower</h2>
<p>Ref. <a href="References/AWS%20-%20Security%20-%20CloudFormation,%20Service%20Catalog,%20Control%20Tower.html">AWS - Security - CloudFormation, Service Catalog, Control Tower</a></p>
<p>マルチアカウント管理の問題を解決する Landing Zone を適用するサービス。</p>
<p>アカウントの各種設定、監査ログ集約、ガードレールなどのデプロイを自動化。</p>
<p>SCP (予防的ガードレール) と Config Rules (発見的ガードレール)。</p>
<p>Landing Zone</p>
<ul>
<li>ベストプラクティスに基づいて構成したアカウントをガバナンスを効かせてスケーラブルに自動展開する仕組み。</li>
<li>マスター、ログアーカイブ、監査アカウントを使用する。</li>
<li><img alt="" src="_attachment/image_691.png" /></li>
<li>アカウントの発行・管理<ul>
<li>Organizations を使用してマルチアカウント環境を作成</li>
</ul>
</li>
<li>サインオンの構成<ul>
<li>AWS SSO を使用して ID 管理、フェデレーテッドアクセスを提供</li>
</ul>
</li>
<li>監査用ログ集約<ul>
<li>CloudTrail ログや S3 に保存される AWS Config のログを集中管理</li>
<li>CloudWatch によるアラート</li>
</ul>
</li>
<li>ガードレール<ul>
<li>Organization, AWS Config で実装。</li>
</ul>
</li>
</ul>
<h1 id="hybrid">Hybrid</h1>
<h2 id="aws-vm-importexport">AWS VM Import/Export</h2>
<ul>
<li>VM イメージ (VHD, OVA) と EC2 インスタンス間のインポート・エクスポート。</li>
</ul>
<h2 id="aws-application-discovery-service-ads">AWS Application Discovery Service (ADS)</h2>
<ul>
<li>オンプレサーバの各種情報を収集。ADS のダッシュボードで確認。<ul>
<li>アプリケーションの検出、依存関係、性能 (CPU, RAM, I/O, etc.)。</li>
</ul>
</li>
<li>AWS Migration Hub と統合 → 移行の進捗をトラッキング</li>
<li>エージェントレス型<ul>
<li>VMware vCenter Server 環境</li>
<li>AWS Agentless Discovery Connector (OVA 形式の仮想アプライアンス) を使用する。</li>
</ul>
</li>
<li>エージェント型<ul>
<li>Ubuntu, CentOS, RedHat, Windows Server</li>
</ul>
</li>
<li>問題例:<ul>
<li>The company is using a VMWare vCenter Server for data center management of their vSphere environments and virtual servers.</li>
<li>A DevOps engineer is tasked to implement a solution that will collect various information from their on-premises and EC2 instances, such as operating system details, MAC address, IP address, and many others.</li>
<li>The Operations team should also be able to analyze the collected data in a visual format.</li>
</ul>
</li>
<li>解答<ul>
<li>Using the AWS Application Discovery Service, deploy the <strong>Agentless Discovery Connector in an OVA file format to your VMware vCenter</strong> and then <strong>install the AWS Discovery Agents on the EC2 instances to</strong> collect the required data.</li>
<li>Use the AWS Migration Hub Dashboard to analyze your hybrid infrastructure.</li>
</ul>
</li>
</ul>
<p><img alt="" src="_attachment/image_692.png" /></p>
<p>Direct Connect</p>
<ul>
<li>オンプレ拠点 (オフィスや DC) と VPC を専用線で接続</li>
<li>セットアップに数週間はかかるしお高い。</li>
<li>Direct Connect ロケーション<ul>
<li>AWS と通信事業者などの AWS Direct Connect パートナーが IX に用意した相互接続ポイント。</li>
<li>東京リージョンは東京2カ所、大阪1カ所、台北2カ所。</li>
</ul>
</li>
<li>プライベート接続<ul>
<li>VPC/オンプレ相互にプライベート IP を使用。</li>
<li>VPC のサブネットに接続。</li>
</ul>
</li>
<li>パブリック接続<ul>
<li>AWS のパブリックサービスへの接続。</li>
<li>パブリック IP に接続するためにオンプレ側もパブリック IP (NAT) が必要。</li>
</ul>
</li>
</ul>
<p>Transit Gateway</p>
<ul>
<li>複数 VPC 同士やオンプレとの Direct Connect や VPN を HUB となるゲートウェイで接続。</li>
<li>スター型ネットワークでルーティングテーブルの制御を Transit Gateway で集中管理。</li>
<li>VPN ピア接続は推移的な通信ができないため複数 VPC だとそれぞれピア接続を設定したり Direct Connect や VPN を接続する必要があり複雑になるが、Transit Gateway なら集中接続できる。</li>
</ul>
<p><img alt="" src="_attachment/image_693.png" /></p>
<ul>
<li>テストの設定が DynamoDB に入っている</li>
</ul>
<p><img alt="" src="_attachment/image_694.png" />
<img alt="" src="_attachment/image_695.png" /></p>
</article>

    </main>
    <footer class="footer" role="contentinfo">
        <span class="footer__title" id="title">AWS - DevOps - Overview</span>
        <span class="footer__percentage" aria-live="polite"><span id="scrollPercentage">0%</span></span>
    </footer>
    <script src="static/script.js"></script>
</body>
</html>